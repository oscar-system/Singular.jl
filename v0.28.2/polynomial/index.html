<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multivariate polynomials · Singular.jl</title><meta name="title" content="Multivariate polynomials · Singular.jl"/><meta property="og:title" content="Multivariate polynomials · Singular.jl"/><meta property="twitter:title" content="Multivariate polynomials · Singular.jl"/><meta name="description" content="Documentation for Singular.jl."/><meta property="og:description" content="Documentation for Singular.jl."/><meta property="twitter:description" content="Documentation for Singular.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Singular.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><span class="tocitem">Coefficient rings</span><ul><li><a class="tocitem" href="../integer/">Integers</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../modn/">Integers mod n</a></li><li><a class="tocitem" href="../modp/">Integers mod p</a></li><li><a class="tocitem" href="../transExt/">Function fields</a></li><li><a class="tocitem" href="../GF/">Finite fields</a></li><li><a class="tocitem" href="../nemo/">Nemo rings and fields</a></li></ul></li><li class="is-active"><a class="tocitem" href>Multivariate polynomials</a><ul class="internal"><li><a class="tocitem" href="#Multivariate-polynomial-functionality"><span>Multivariate polynomial functionality</span></a></li></ul></li><li><a class="tocitem" href="../noncommutative/">Noncommutative algebras</a></li><li><a class="tocitem" href="../ideal/">Ideals</a></li><li><a class="tocitem" href="../qring/">Quotient Rings</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module/">Finitely generated modules</a></li><li><a class="tocitem" href="../vector/">Free modules and vectors</a></li></ul></li><li><a class="tocitem" href="../alghom/">Algebra Homomorphisms</a></li><li><a class="tocitem" href="../resolution/">Resolutions</a></li><li><a class="tocitem" href="../matrix/">Matrices</a></li><li><a class="tocitem" href="../caller/">Interpreter Functionality</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Multivariate polynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multivariate polynomials</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oscar-system/Singular.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/polynomial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multivariate-polynomials"><a class="docs-heading-anchor" href="#Multivariate-polynomials">Multivariate polynomials</a><a id="Multivariate-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-polynomials" title="Permalink"></a></h1><p>Singular.jl allows the creation of multivariate polynomials over any of the coefficient rings described above.</p><p>The default multivariate polynomial type in Singular.jl is the Singular <code>spoly</code> type.</p><p>The associated polynomial ring is represented by a parent object which can be constructed by a call to the <code>polynomial_ring</code> constructor.</p><p>The types of the polynomial ring parent objects and elements thereof are given in the following table according to the library providing them.</p><table><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Singular</td><td style="text-align: right"><code>spoly{T}</code></td><td style="text-align: right"><code>Singular.PolyRing{T}</code></td></tr></table><p>These types are parameterised by the type of elements in the coefficient ring of the polynomials.</p><p>All polynomial types belong directly to the abstract type <code>MPolyRingElem</code> and all the polynomial ring parent object types belong to the abstract type <code>MPolyRing</code>.</p><h2 id="Multivariate-polynomial-functionality"><a class="docs-heading-anchor" href="#Multivariate-polynomial-functionality">Multivariate polynomial functionality</a><a id="Multivariate-polynomial-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-polynomial-functionality" title="Permalink"></a></h2><p>Singular.jl polynomials provides all the Multivariate Polynomial Ring functionality described by AbstractAlgebra.jl.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial">https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial</a></p><p>In particular, Singular polynomials are sparse distributed, but do not have random access. Instead, they implement iterator access to terms. This is due to their storage in a linked list, for efficient implementation of Groebner basis algorithms.</p><p>Some polynomial rings may also implement part of the Euclidean Ring interface, where this is appropriate.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface">https://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface</a></p><p>Below, we describe the functionality that is specific to the Singular multivariate polynomials that is not documented in the general multivariate interface.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><pre><code class="language-julia hljs">polynomial_ring(R::Union{Ring, Field}, s::AbstractVector{&lt;:VarName};
               cached::Bool = true, ordering = :degrevlex,
               ordering2::Symbol = :comp1min, degree_bound::Int = 0)</code></pre><p>Returns a tuple, <span>$S, x$</span> consisting of a multivariate polynomial ring <span>$S$</span> and an array <span>$x$</span> of variables (from which polynomials can be constructed). The ring <span>$R$</span> must be a valid Singular coefficient ring, or any Nemo/AbstractAlgebra coefficient ring. The array <span>$s$</span> must be a list of strings corresponding to how the variables will be printed. By default, there will only be one Singular polynomial ring in the system for each combination of coefficient ring, list of variable names, ordering and degree bound. This is accomplished by making use of a global cache. If this is not the desired behaviour, <code>false</code> can be passed to the optional argument <code>cached</code>.</p><p>If the first ordering <code>ordering</code> is specified as a symbol, then two orderings can be specified, one for term ordering of the polynomials, and another for ordering of module components. They can occur in either order, the first taking precedence over the other, when the polynomials are used to represent module generators. If either is not specified, the indicated default is used. The options for polynomial term ordering are, <code>:lex</code>, <code>:deglex</code>, <code>:degrevlex</code>, <code>:neglex</code>, <code>:negdeglex</code> and <code>:negdegrevlex</code>, and the options for module component ordering are <code>comp1min</code> and <code>comp1max</code>.</p><p>If the first ordering <code>ordering</code> is specified as a non-symbol, the second ordering <code>ordering2</code> will be ignored. For specifying non-symbolic term orderings, please see the Term orderings section below.</p><p>If one has an a priori bound on the degree in each variable of a polynomial (including for all intermediate computations in this ring), one can specify it using the <code>degree_bound</code> optional parameter. Singular may then be able to use a more efficient representation internally, which will use less memory and allow for faster arithmetic. By default, Singular uses a bound of 16 bits internally for the exponent of each variable, however this is a signed value, so that the default is for nonnegative exponents that fit in 15 bits.</p><p>Note that internally, Singular may use a higher bound than specified, if it will not increase the amount of storage required.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Singular polynomial ring (ZZ),(x,y,z),(dp(3),C), spoly{n_Z}[x, y, z])

julia&gt; S, vars = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]; ordering=:deglex)
(Singular polynomial ring (QQ),(x,y),(Dp(2),C), spoly{n_Q}[x, y])

julia&gt; T, x = polynomial_ring(ZZ, [&quot;x$i&quot; for i in 1:5];
              ordering=:comp1max, ordering2=:degrevlex, degree_bound=5)
(Singular polynomial ring (ZZ),(x1,x2,x3,x4,x5),(c,dp(5),L(5)), spoly{n_Z}[x1, x2, x3, x4, x5])</code></pre><p>See also the convenience macros below for simple use cases.</p><p>The following function allows creating a Singular polynomial ring from a given polynomial ring of type AbstractAlgebra.Generic.MPolyRing:</p><pre><code class="language-julia hljs">polynomial_ring(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true, ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min, degree_bound::Int = 0)  where {T &lt;: RingElement}</code></pre><p>Polynomials can be constructed using arithmetic operations on the generators, but this can be extremely inefficient. For this purpose, Singular polynomials support construction using a build context, as described in the AbstractAlgebra documentation:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial">https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial</a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])

julia&gt; C = MPolyBuildCtx(R)
Builder for an element of Singular polynomial ring (ZZ),(x,y),(dp(2),C)

julia&gt; push_term!(C, ZZ(1), [1, 2])
x*y^2

julia&gt; push_term!(C, ZZ(3), [1, 1])
x*y^2 + 3*x*y

julia&gt; push_term!(C, -ZZ(1), [0, 1])
x*y^2 + 3*x*y - y

julia&gt; f = finish(C)
x*y^2 + 3*x*y - y</code></pre><h3 id="Term-orderings"><a class="docs-heading-anchor" href="#Term-orderings">Term orderings</a><a id="Term-orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Term-orderings" title="Permalink"></a></h3><p>A general term ordering can be constructed as a product of one or more of the following block orderings.</p><article><details class="docstring" open="true"><summary id="Singular.ordering_lp"><a class="docstring-binding" href="#Singular.ordering_lp"><code>Singular.ordering_lp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_lp(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the lexicographical ordering (:lex)  (the Singular ordering <code>lp</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L96-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_ip"><a class="docstring-binding" href="#Singular.ordering_ip"><code>Singular.ordering_ip</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_ip(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the Singular ordering <code>ip</code>. This stands for what the Singular manual refers to as &quot;reverse lexicographical ordering&quot; (and is elsewhere sometimes called &quot;inverse lexicographical ordering), i.e. a lexicographical ordering from the right with <code>1 &lt; x_1 &lt; ... &lt;x_n</code>.</p><p>Note that this reverses the &quot;natural&quot; order <code>x_1 &gt; ... &gt; x_n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L114-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_rp"><a class="docstring-binding" href="#Singular.ordering_rp"><code>Singular.ordering_rp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_rp(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the inverse lexicographical ordering (:invlex) (the Singular ordering <code>ip</code>).</p><p>Note that this reverses the &quot;natural&quot; order <code>x_1 &gt; ... &gt; x_n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L104-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_dp"><a class="docstring-binding" href="#Singular.ordering_dp"><code>Singular.ordering_dp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_dp(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the degree reverse lexicographical ordering (:degrevlex) (the Singular ordering <code>dp</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L124-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_Dp"><a class="docstring-binding" href="#Singular.ordering_Dp"><code>Singular.ordering_Dp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_Dp(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the degree lexicographical ordering (:deglex) (the Singular ordering <code>Dp</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L132-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_wp-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#Singular.ordering_wp-Tuple{Vector{Int64}}"><code>Singular.ordering_wp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ordering_wp(w::Vector{Int})</code></pre><p>Represents a block of variables with the weighted reverse lexicographical ordering. The weight vector <code>w</code> is expected to consist of positive integers only. (the Singular ordering <code>wp</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L140-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_Wp-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#Singular.ordering_Wp-Tuple{Vector{Int64}}"><code>Singular.ordering_Wp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ordering_Wp(w::Vector{Int})</code></pre><p>Represents a block of variables with the weighted lexicographical ordering. The weight vector is expected to consist of positive integers only. (the Singular ordering <code>Wp</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L150-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_Ip"><a class="docstring-binding" href="#Singular.ordering_Ip"><code>Singular.ordering_Ip</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_Ip(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the degree inverse lexicographical ordering (:deginvlex) (the Singular ordering <code>Ip</code>).</p><p>Note that this reverses the &quot;natural&quot; order <code>x_1 &gt; ... &gt; x_n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L160-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_ls"><a class="docstring-binding" href="#Singular.ordering_ls"><code>Singular.ordering_ls</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_ls(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the negative lexicographical ordering (:neglex) (the Singular ordering <code>ls</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L170-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_is"><a class="docstring-binding" href="#Singular.ordering_is"><code>Singular.ordering_is</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_is(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the negative inverse lexicographical ordering (:neginvlex) (the Singular ordering <code>is</code>)</p><p>Note that this reverses the &quot;natural&quot; order <code>x_1 &gt; ... &gt; x_n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L188-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_rs"><a class="docstring-binding" href="#Singular.ordering_rs"><code>Singular.ordering_rs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_rs(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the negative inverse lexicographical ordering (:neginvlex) (the Singular ordering <code>is</code>)</p><p>Note that this reverses the &quot;natural&quot; order <code>x_1 &gt; ... &gt; x_n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L178-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_ds"><a class="docstring-binding" href="#Singular.ordering_ds"><code>Singular.ordering_ds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_ds(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the negative degree reverse lexicographical ordering (:negdegrevlex) (the Singular ordering <code>ds</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L198-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_Ds"><a class="docstring-binding" href="#Singular.ordering_Ds"><code>Singular.ordering_Ds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ordering_Ds(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the negative degree reverse lexicographical ordering (:negdeglex). (the Singular ordering <code>Ds</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L207-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_ws-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#Singular.ordering_ws-Tuple{Vector{Int64}}"><code>Singular.ordering_ws</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ordering_ws(w::Vector{Int})</code></pre><p>Represents a block of variables with the general weighted reverse lexicographical ordering. The weight vector <code>w</code> is expected to have a nonzero first entry. (the Singular ordering <code>ws</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L216-L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_Ws-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#Singular.ordering_Ws-Tuple{Vector{Int64}}"><code>Singular.ordering_Ws</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ordering_Ws(w::Vector{Int})</code></pre><p>Represents a block of variables with the general weighted lexicographical ordering. The weight vector <code>w</code> is expected to have a nonzero first entry. (the Singular ordering <code>Ws</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L226-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_a-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#Singular.ordering_a-Tuple{Vector{Int64}}"><code>Singular.ordering_a</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ordering_a(w::Vector{Int})</code></pre><p>Represents an extra weight vector that may precede any monomial ordering. An extra weight vector does not define a monomial ordering by itself: it can only be used in combination with other orderings to insert an extra line of weights into the ordering matrix. (the Singular ordering <code>a</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L236-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_M-Tuple{Matrix{Int64}}"><a class="docstring-binding" href="#Singular.ordering_M-Tuple{Matrix{Int64}}"><code>Singular.ordering_M</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ordering_M(m::Matrix{Int}; checked::Bool = true)</code></pre><p>Represents a block of variables with a general matrix ordering. The matrix <code>m</code> is expected to be invertible, and this is checked by default. (the Singular ordering <code>M</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L247-L253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_C-Tuple{}"><a class="docstring-binding" href="#Singular.ordering_C-Tuple{}"><code>Singular.ordering_C</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ordering_C()</code></pre><p>Represents an ascending ordering on vector components <code>gen(1) &lt; gen(2) &lt; ...</code>. All monomial block orderings preceding the component ordering have higher precedence, and all succeeding monomial block orderings have lower precedence. It is not necessary to specify this ordering explicitly since it appended automatically to an ordering lacking a component specification. (the Singular ordering <code>C</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L268-L277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.ordering_c-Tuple{}"><a class="docstring-binding" href="#Singular.ordering_c-Tuple{}"><code>Singular.ordering_c</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ordering_c()</code></pre><p>Represents a descending ordering on vector components <code>gen(1) &gt; gen(2) &gt; ...</code>. All monomial block orderings preceding the component ordering have higher precedence, and all succeeding monomial block orderings have lower precedence. (the Singular ordering <code>c</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/orderings.jl#L280-L287">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">polynomial_ring(QQ, &quot;x&quot;.*string.(1:8), ordering = ordering_M([1 2; 3 5])*ordering_lp(3)*ordering_wp([1, 2, 3]))

polynomial_ring(QQ, &quot;x&quot;.*string.(1:5), ordering = ordering_dp(3)*ordering_dp())</code></pre><h3 id="Polynomial-ring-macros"><a class="docs-heading-anchor" href="#Polynomial-ring-macros">Polynomial ring macros</a><a id="Polynomial-ring-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-ring-macros" title="Permalink"></a></h3><p>For convenience, we provide some macros for constructing polynomial rings and injecting the variables into scope. These are easier to use, but have some limitations. In particular, they can only be used at the top level by the user, and cannot be used programmatically or in library code (it is not possible to inject an arbitrary number of variables into scope inside a function).</p><p>The macros are designed for simple use cases, and do not offer the full power of the most general constructor above.</p><pre><code class="language-julia hljs">@polynomial_ring(R, s, n, o)</code></pre><p>Given a coefficient ring <span>$R$</span>, a root variable name, e.g. <code>&quot;x&quot;</code>, a number of variable <span>$n$</span> and a polynomial term ordering <code>o</code>, create the variables <code>x1, x2, ..., xn</code> and inject them into scope, and return the corresponding polynomial ring <code>S</code>.</p><pre><code class="language-julia hljs">@polynomial_ring(R, s, n)</code></pre><p>As per the previous macro, with a default of <code>:degrevlex</code> for the polynomial term ordering.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = @polynomial_ring(ZZ, &quot;x&quot;, 5, :deglex)
Singular polynomial ring (ZZ),(x1,x2,x3,x4,x5),(Dp(5),C)

julia&gt; T = @polynomial_ring(QQ, &quot;y&quot;, 10)
Singular polynomial ring (QQ),(y1,y2,y3,y4,y5,y6,y7,y8,y9,y10),(dp(10),C)</code></pre><h3 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Singular.has_global_ordering-Tuple{PolyRing}"><a class="docstring-binding" href="#Singular.has_global_ordering-Tuple{PolyRing}"><code>Singular.has_global_ordering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_global_ordering(R::PolyRingUnion)</code></pre><p>Return <code>true</code> if the given ring has a global ordering, i.e. if <span>$1 &lt; x$</span> for each variable <span>$x$</span> in the ring. This include <code>:lex</code>, <code>:deglex</code> and <code>:degrevlex</code> orderings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L39-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.has_mixed_ordering-Tuple{PolyRing}"><a class="docstring-binding" href="#Singular.has_mixed_ordering-Tuple{PolyRing}"><code>Singular.has_mixed_ordering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_mixed_ordering(R::PolyRingUnion)</code></pre><p>Return <code>true</code> if the given ring has a mixed ordering, i.e. if <span>$1 &lt; x_i$</span> for a variable <span>$x_i$</span> and <span>$1&gt;x_j$</span> for another variable <span>$x_j$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L50-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.has_local_ordering-Tuple{PolyRing}"><a class="docstring-binding" href="#Singular.has_local_ordering-Tuple{PolyRing}"><code>Singular.has_local_ordering</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_local_ordering(R::PolyRingUnion)</code></pre><p>Return <code>true</code> if the given ring has a local ordering, i.e. if <span>$1 &gt; x$</span> for all variables <span>$x$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L60-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.degree_bound-Tuple{PolyRing}"><a class="docstring-binding" href="#Singular.degree_bound-Tuple{PolyRing}"><code>Singular.degree_bound</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree_bound(R::PolyRing)</code></pre><p>Return the internal degree bound in each variable, enforced by Singular. This is the largest positive value any degree can have before an overflow will occur. This internal bound may be higher than the bound requested by the user via the <code>degree_bound</code> parameter of the <code>polynomial_ring</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L124-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractAlgebra.Generic.total_degree-Tuple{spoly}"><a class="docstring-binding" href="#AbstractAlgebra.Generic.total_degree-Tuple{spoly}"><code>AbstractAlgebra.Generic.total_degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">total_degree(p::spoly)</code></pre><p>Return the total degree (largest sum of exponents of any monomial) of <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L235-L239">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractAlgebra.order-Tuple{spoly}"><a class="docstring-binding" href="#AbstractAlgebra.order-Tuple{spoly}"><code>AbstractAlgebra.order</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">order(p::spoly)</code></pre><p>Return the order of <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L245-L249">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R = @polynomial_ring(ZZ, &quot;x&quot;, 3)
Singular polynomial ring (ZZ),(x1,x2,x3),(dp(3),C)

julia&gt; n = nvars(R)
3

julia&gt; has_global_ordering(R) == true
true

julia&gt; c = characteristic(R)
0

julia&gt; L = degree_bound(R)
1048575

julia&gt; exps = leading_exponent_vector(x1*x2 + 3x1*x2^2 + x3 + 2)
3-element Vector{Int64}:
 1
 2
 0

julia&gt; deg = total_degree(x1*x2 + 3x1*x2^2 + x3 + 2)
3

julia&gt; ord = order(x1*x2 + 3x1*x2^2 + x3 + 2)
0</code></pre><h3 id="Differential-functions"><a class="docs-heading-anchor" href="#Differential-functions">Differential functions</a><a id="Differential-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-functions" title="Permalink"></a></h3><p>Working over any coefficient ring, basic functionality involving differential operations is available.</p><article><details class="docstring" open="true"><summary id="Singular.jet-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem"><a class="docstring-binding" href="#Singular.jet-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.jet</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jet(x::spoly{T}, n::Int) where T &lt;: Nemo.RingElem</code></pre><p>Return the truncation of <span>$x$</span> up to degree <span>$n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L1270-L1274">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem"><a class="docstring-binding" href="#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem"><code>AbstractAlgebra.derivative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">derivative(x::spoly{T}, n::Int) where T &lt;: Nemo.RingElem</code></pre><p>Return the derivative of <span>$x$</span> with respect to the variable of index <span>$n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L1280-L1284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T&lt;:AbstractAlgebra.RingElem"><a class="docstring-binding" href="#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>AbstractAlgebra.derivative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">derivative(x::spoly{T}, v::spoly{T}) where T &lt;: Nemo.RingElem</code></pre><p>Return the derivative of <span>$x$</span> with respect to the variable <span>$v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L1291-L1295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.jacobian_ideal-Union{Tuple{spoly{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><a class="docstring-binding" href="#Singular.jacobian_ideal-Union{Tuple{spoly{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.jacobian_ideal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jacobian_ideal(p::spoly{T}) where T &lt;: Nemo.RingElem</code></pre><p>Return the ideal generated by all partial derivatives of <span>$x$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L1302-L1306">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.jacobian_matrix-Union{Tuple{spoly{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><a class="docstring-binding" href="#Singular.jacobian_matrix-Union{Tuple{spoly{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.jacobian_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jacobian_matrix(p::spoly{T}) where T &lt;: Nemo.RingElem</code></pre><p>Return the column matrix <span>$\{\frac{\partial p}{\partial x_i}\}_i$</span> of partial derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L1313-L1317">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Singular.jacobian_matrix-Union{Tuple{Array{spoly{T}, 1}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><a class="docstring-binding" href="#Singular.jacobian_matrix-Union{Tuple{Array{spoly{T}, 1}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.jacobian_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jacobian_matrix(a::Vector{spoly{T}}) where T &lt;: Nemo.RingElem</code></pre><p>Return the matrix <span>$\{\frac{\partial a_i}{\partial x_j}\}_{ij}$</span> of partial derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L1328-L1332">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Singular polynomial ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])

julia&gt; f = x^2*y*z + z^2*x + x*y*z
x^2*y*z + x*y*z + x*z^2

julia&gt; g = jet(f, 3)
x*y*z + x*z^2

julia&gt; derivative(f, 1)
2*x*y*z + y*z + z^2

julia&gt; derivative(f, y)
x^2*z + x*z

julia&gt; J = jacobian_ideal(f)
Singular ideal over Singular polynomial ring (QQ),(x,y,z),(dp(3),C) with generators (2*x*y*z + y*z + z^2, x^2*z + x*z, x^2*y + x*y + 2*x*z)

julia&gt; Jf1 = jacobian_matrix(f)
[2*x*y*z + y*z + z^2
x^2*z + x*z
x^2*y + x*y + 2*x*z]

julia&gt; Jf2 = jacobian_matrix([f, g])
[2*x*y*z + y*z + z^2, x^2*z + x*z, x^2*y + x*y + 2*x*z
y*z + z^2, x*z, x*y + 2*x*z]</code></pre><h3 id="Content-and-primitive-part"><a class="docs-heading-anchor" href="#Content-and-primitive-part">Content and primitive part</a><a id="Content-and-primitive-part-1"></a><a class="docs-heading-anchor-permalink" href="#Content-and-primitive-part" title="Permalink"></a></h3><p>When coefficient rings have a meaningful GCD function, the following functions are available.</p><article><details class="docstring" open="true"><summary id="AbstractAlgebra.primpart-Tuple{spoly}"><a class="docstring-binding" href="#AbstractAlgebra.primpart-Tuple{spoly}"><code>AbstractAlgebra.primpart</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">primpart(x::SPolyUnion)</code></pre><p>Return the primitive part of the polynomial, i.e. the polynomial divided by the GCD of its coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L970-L975">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractAlgebra.content-Tuple{spoly}"><a class="docstring-binding" href="#AbstractAlgebra.content-Tuple{spoly}"><code>AbstractAlgebra.content</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">content(x::SPolyUnion)</code></pre><p>Return the content of the polynomial, i.e. the GCD of its coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L983-L987">source</a></section></details></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R = @polynomial_ring(ZZ, &quot;x&quot;, 2)
Singular polynomial ring (ZZ),(x1,x2),(dp(2),C)

julia&gt; f = 3x1^2 + 3x1*x2 + 6x2^2
3*x1^2 + 3*x1*x2 + 6*x2^2

julia&gt; p = primpart(f)
x1^2 + x1*x2 + 2*x2^2

julia&gt; c = content(f)
3</code></pre><h3 id="Homogeneous-polynomials"><a class="docs-heading-anchor" href="#Homogeneous-polynomials">Homogeneous polynomials</a><a id="Homogeneous-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Homogeneous-polynomials" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Singular.homogenize-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T&lt;:AbstractAlgebra.RingElem"><a class="docstring-binding" href="#Singular.homogenize-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.homogenize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">homogenize(p::spoly{T}, v::spoly{T}) where T &lt;: Nemo.RingElem</code></pre><p>Multiply each monomial in p by a suitable power of the variable <code>v</code> and return the corresponding homogeneous polynomial. The variable <code>v</code> must have weight <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/b13cd564bea6da6f530c9aaa9b59cd21a5eedfe9/src/poly/poly.jl#L1173-L1179">source</a></section></details></article><h3 id="Multivariate-Factorisation"><a class="docs-heading-anchor" href="#Multivariate-Factorisation">Multivariate Factorisation</a><a id="Multivariate-Factorisation-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Factorisation" title="Permalink"></a></h3><p>For the Singular base fields <code>QQ</code> and <code>Fp</code> a function to compute a squarefree factorization is available.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; R = @polynomial_ring(QQ, &quot;x&quot;, 4)
Singular Polynomial Ring (QQ),(x1,x2,x3,x4),(dp(4),C)

julia&gt; f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2;

julia&gt; Fac = factor(f)
123 * (x4^5 + 57*x2^3)^3 * (x1^2 + x1 + 1)^2 * (x2*x3 + x1)^2</code></pre><p>For the Singular base rings <code>QQ</code>, <code>ZZ</code> and <code>Fp</code> a function to compute the multivariate factorization is available.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; R = @polynomial_ring(ZZ, &quot;x&quot;, 4)
Singular Polynomial Ring (ZZ),(x1,x2,x3,x4),(dp(4),C)

julia&gt; f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2;

julia&gt; Fac = factor(f)
123 * (x2*x3 + x1)^2 * (x4^5 + 57*x2^3)^3 * (x1^2 + x1 + 1)^2</code></pre><h3 id="Change-of-coefficient-rings"><a class="docs-heading-anchor" href="#Change-of-coefficient-rings">Change of coefficient rings</a><a id="Change-of-coefficient-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Change-of-coefficient-rings" title="Permalink"></a></h3><p>It is possible to change the coefficient ring of a given polynomial <span>$p$</span> via the function &#39;change<em>base</em>ring&#39;.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])

julia&gt; p = x^5 + y^3+1
x^5 + y^3 + 1

julia&gt; p2 = change_base_ring(QQ, p)
x^5 + y^3 + 1

julia&gt; parent(p2)
Singular polynomial ring (QQ),(x,y),(dp(2),C)</code></pre><p>It also possible to work with Nemo rings by casting to a suitable Singular type via <code>CoefficientRing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">R, (x, y) = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;])

p = x^5 + y^3+1

p2 change_base_ring(CoefficientRing(Nemo.QQ), p)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nemo/">« Nemo rings and fields</a><a class="docs-footer-nextpage" href="../noncommutative/">Noncommutative algebras »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 27 November 2025 10:33">Thursday 27 November 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
