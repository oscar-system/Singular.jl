<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multivariate polynomials · Singular.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Singular.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><span class="toctext">Coefficient rings</span><ul><li><a class="toctext" href="integer.html">Integers</a></li><li><a class="toctext" href="rational.html">Rational field</a></li><li><a class="toctext" href="modn.html">Integers mod n</a></li><li><a class="toctext" href="modp.html">Integers mod p</a></li><li><a class="toctext" href="GF.html">Finite fields</a></li><li><a class="toctext" href="nemo.html">Nemo rings and fields</a></li></ul></li><li class="current"><a class="toctext" href="polynomial.html">Multivariate polynomials</a><ul class="internal"><li><a class="toctext" href="#Multivariate-polynomial-functionality-1">Multivariate polynomial functionality</a></li></ul></li><li><a class="toctext" href="ideal.html">Ideals</a></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="module.html">Finitely generated modules</a></li><li><a class="toctext" href="vector.html">Free modules and vectors</a></li></ul></li><li><a class="toctext" href="alghom.html">Algebra Homomorphisms</a></li><li><a class="toctext" href="resolution.html">Resolutions</a></li><li><a class="toctext" href="matrix.html">Matrices</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="polynomial.html">Multivariate polynomials</a></li></ul><a class="edit-page" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/polynomial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Multivariate polynomials</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Multivariate-polynomials-1" href="#Multivariate-polynomials-1">Multivariate polynomials</a></h1><p>Singular.jl allows the creation of multivariate polynomials over any of the coefficient rings described above.</p><p>The default multivariate polynomial type in Singular.jl is the Singular <code>spoly</code> type.</p><p>The associated polynomial ring is represented by a parent object which can be constructed by a call to the <code>PolynomialRing</code> constructor.</p><p>The types of the polynomial ring parent objects and elements thereof are given in the following table according to the library providing them.</p><table><tr><th>Library</th><th>Element type</th><th>Parent type</th></tr><tr><td>Singular</td><td><code>spoly{T}</code></td><td><code>Singular.PolyRing{T}</code></td></tr></table><p>These types are parameterised by the type of elements in the coefficient ring of the polynomials.</p><p>All polynomial types belong directly to the abstract type <code>MPolyElem</code> and all the polynomial ring parent object types belong to the abstract type <code>MPolyRing</code>.</p><h2><a class="nav-anchor" id="Multivariate-polynomial-functionality-1" href="#Multivariate-polynomial-functionality-1">Multivariate polynomial functionality</a></h2><p>Singular.jl polynomials implement the Multivariate Polynomial Ring interface of AbstractAlgebra.jl.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/mpolynomial_rings.html">https://nemocas.github.io/AbstractAlgebra.jl/mpolynomial_rings.html</a></p><p>In particular, Singular polynomials are sparse distributed, but do not have random access. Instead, they implement iterator access to terms. This is due to their storage in a linked list, for efficient implementation of Groebner basis algorithms.</p><p>Some polynomial rings may also implement part of the Euclidean Ring interface, where this is appropriate.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html">https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html</a></p><p>Below, we describe the functionality that is specific to the Singular multivariate  polynomials that is not documented in the general multivariate interface.</p><h3><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h3><pre><code class="language-julia">PolynomialRing(R::Union{Ring, Field}, s::Array{String, 1};
   cached::Bool = true, ordering::Symbol = :degrevlex,
      ordering2::Symbol = :comp1min, degree_bound::Int = 0)</code></pre><p>Returns a tuple, <span>$S, x$</span> consisting of a multivariate polynomial ring <span>$S$</span> and an array <span>$x$</span> of variables (from which polynomials can be constructed). The ring <span>$R$</span> must be a valid Singular coefficient ring, or any Nemo/AbstractAlgebra coefficient ring. The array <span>$s$</span> must be a list of strings corresponding to how the variables will be printed. By default, there will only be one Singular polynomial ring in the system for each combination of coefficient ring, list of variable names, ordering and degree bound. This is accomplished by making use of a global cache. If this is not the desired behaviour, <code>false</code> can be passed to the optional argument <code>cached</code>. </p><p>Two orderings can be specified, one for term ordering of the polynomials, and another for ordering of module components. They can occur in either order, the first taking precedence over the other, when the polynomials are used to represent module generators. If either is not specified, the indicated default is used.</p><p>The options for polynomial term ordering are the symbols, <code>:lex</code>, <code>:deglex</code>, <code>:degrevlex</code>, <code>:neglex</code>, <code>:negdeglex</code> and <code>:negdegrevlex</code>, and the options for module component ordering are <code>comp1min</code> and <code>comp1max</code>.</p><p>If one has an a priori bound on the degree in each variable of a polynomial (including for all intermediate computations in this ring), one can specify it using the <code>degree_bound</code> optional parameter. Singular may then be able to use a more efficient representation internally, which will use less memory and allow for faster arithmetic. By default, Singular uses a bound of 16 bits internally for the exponent of each variable, however this is a signed value, so that the default is for nonnegative exponents that fit in 15 bits.</p><p>Note that internally, Singular may use a higher bound than specified, if it will not increase the amount of storage required.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, z) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])

S, vars = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;]; ordering=:deglex)

T, x = PolynomialRing(ZZ, [&quot;x$i&quot; for i in 1:5];
       ordering=:comp1max, ordering2=:degrevlex, degree_bound=5)</code></pre><p>See also the convenience macros below for simple use cases.</p><p>The following function allows creating a Singular polynomial ring from a given polynomial ring of type AbstractAlgebra.Generic.MPolyRing:</p><pre><code class="language-julia">PolynomialRing(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true, ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min, degree_bound::Int = 0)  where {T &lt;: RingElement}</code></pre><p>Polynomials can be constructed using arithmetic operations on the generators, but this can be extremely inefficient. For this purpose, Singular polynomials support construction using a build context, as described in the AbstractAlgebra documentation:</p><p><a href="https://nemocas.git hub.io/AbstractAlgebra.jl/mpolynomial_rings.html">https://nemocas.github.io/AbstractAlgebra.jl/mpolynomial_rings.html</a></p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;])
C = MPolyBuildCtx(R)

push_term!(C, ZZ(1), [1, 2])
push_term!(C, ZZ(3), [1, 1])
push_term!(C, -ZZ(1), [0, 1])
f = finish(C)</code></pre><h3><a class="nav-anchor" id="Polynomial-ring-macros-1" href="#Polynomial-ring-macros-1">Polynomial ring macros</a></h3><p>For convenience, we provide some macros for constructing polynomial rings and injecting the variables into scope. These are easier to use, but have some limitations. In particular, they can only be used at the top level by the user, and cannot be used programmatically or in library code (it is not possible to inject an arbitrary number of variables into scope inside a function).</p><p>The macros are designed for simple use cases, and do not offer the full power of the most general constructor above.</p><pre><code class="language-julia">@PolynomialRing(R, s, n, o)</code></pre><p>Given a coefficient ring <span>$R$</span>, a root variable name, e.g. <code>&quot;x&quot;</code>, a number of variable <span>$n$</span> and a polynomial term ordering <code>o</code>, create the variables <code>x1, x2, ..., xn</code> and inject them into scope, and return the corresponding polynomial ring <code>S</code>.</p><pre><code class="language-julia">@PolynomialRing(R, s, n)</code></pre><p>As per the previous macro, with a default of <code>:degrevlex</code> for the polynomial term ordering.</p><p><strong>Examples</strong></p><pre><code class="language-julia">S = @PolynomialRing(ZZ, &quot;x&quot;, 5, :deglex)

T = @PolynomialRing(QQ, &quot;y&quot;, 10)</code></pre><h3><a class="nav-anchor" id="Basic-manipulation-1" href="#Basic-manipulation-1">Basic manipulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.nvars-Tuple{PolyRing}" href="#AbstractAlgebra.Generic.nvars-Tuple{PolyRing}"><code>AbstractAlgebra.Generic.nvars</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nvars(R::PolyRing)</code></pre><blockquote><p>Return the number of variables in the given polynomial ring.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.symbols-Tuple{PolyRing}" href="#AbstractAlgebra.Generic.symbols-Tuple{PolyRing}"><code>AbstractAlgebra.Generic.symbols</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symbols(R::PolyRing)</code></pre><blockquote><p>Return symbols for the generators of the polynomial ring <span>$R$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.has_global_ordering-Tuple{PolyRing}" href="#Singular.has_global_ordering-Tuple{PolyRing}"><code>Singular.has_global_ordering</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">has_global_ordering(R::PolyRing)</code></pre><blockquote><p>Return <code>true</code> if the given ring has a global ordering, i.e. if <span>$1 &lt; x$</span> for each variable <span>$x$</span> in the ring. This include <code>:lex</code>, <code>:deglex</code> and <code>:degrevlex</code> orderings.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.has_mixed_ordering-Tuple{PolyRing}" href="#Singular.has_mixed_ordering-Tuple{PolyRing}"><code>Singular.has_mixed_ordering</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">has_mixed_ordering(R::PolyRing)</code></pre><blockquote><p>Return <code>true</code> if the given ring has a mixed ordering, i.e. if <span>$1 &lt; x_i$</span> for a variable <span>$x_i$</span> and <span>$1&gt;x_j$</span> for another variable <span>$x_j$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.has_local_ordering-Tuple{PolyRing}" href="#Singular.has_local_ordering-Tuple{PolyRing}"><code>Singular.has_local_ordering</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">has_local_ordering(R::PolyRing)</code></pre><blockquote><p>Return <code>true</code> if the given ring has a local ordering, i.e. if <span>$1 &gt; x$</span> for all variables <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.characteristic-Tuple{PolyRing}" href="#AbstractAlgebra.Generic.characteristic-Tuple{PolyRing}"><code>AbstractAlgebra.Generic.characteristic</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">characteristic(R::PolyRing)</code></pre><blockquote><p>Return the characteristic of the polynomial ring, i.e. the characteristic of the coefficient ring.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.degree_bound-Tuple{PolyRing}" href="#Singular.degree_bound-Tuple{PolyRing}"><code>Singular.degree_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">degree_bound(R::PolyRing)</code></pre><blockquote><p>Return the internal degree bound in each variable, enforced by Singular. This is the largest positive value any degree can have before an overflow will occur. This internal bound may be higher than the bound requested by the user via the <code>degree_bound</code> parameter of the <code>PolynomialRing</code> constructor.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.lead_exponent-Tuple{spoly}" href="#Singular.lead_exponent-Tuple{spoly}"><code>Singular.lead_exponent</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lead_exponent(p::spoly)</code></pre><blockquote><p>Return the exponent vector of the leading term of the given polynomial. The return value is a Julia 1-dimensional array giving the exponent for each variable of the leading term.</p></blockquote></div></section><pre><code class="language-none">total_degree(p::spoly)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.order-Tuple{spoly}" href="#Singular.order-Tuple{spoly}"><code>Singular.order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">order(p::spoly)</code></pre><blockquote><p>Returns the order of <span>$p$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-none">R = @PolynomialRing(ZZ, &quot;x&quot;, 3)

n = ngens(R)
has_global_ordering(R) == true
c = characteristic(R)
L = degree_bound(R)
exps = lead_exponent(x1*x2 + 3x1*x2^2 + x3 + 2)
deg = total_degree(x1*x2 + 3x1*x2^2 + x3 + 2)
ord = order(x1*x2 + 3x1*x2^2 + x3 + 2) </code></pre><h3><a class="nav-anchor" id="Content-and-primitive-part-1" href="#Content-and-primitive-part-1">Content and primitive part</a></h3><p>When coefficient rings have a meaningful GCD function, the following functions are available.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.primpart-Tuple{spoly}" href="#AbstractAlgebra.Generic.primpart-Tuple{spoly}"><code>AbstractAlgebra.Generic.primpart</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">primpart(x::spoly)</code></pre><blockquote><p>Return the primitive part of the polynomial, i.e. the polynomial divided by the GCD of its coefficients.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.content-Tuple{spoly}" href="#AbstractAlgebra.Generic.content-Tuple{spoly}"><code>AbstractAlgebra.Generic.content</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">content(x::spoly)</code></pre><blockquote><p>Return the content of the polynomial, i.e. the GCD of its coefficients.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R = @PolynomialRing(ZZ, &quot;x&quot;, 2)

f = 3x1^2 + 3x1*x2 + 6x2^2

p = primpart(f)
c = content(f)</code></pre><h3><a class="nav-anchor" id="Multivariate-Factorisation-1" href="#Multivariate-Factorisation-1">Multivariate Factorisation</a></h3><p>For the Singular base fields <code>QQ</code> and <code>Fp</code> a function to compute a  squarefree factorization is available.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.factor_squarefree-Tuple{spoly}" href="#Singular.factor_squarefree-Tuple{spoly}"><code>Singular.factor_squarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_squarefree(x::spoly)</code></pre><blockquote><p>Returns a squarefree factorization of <span>$x$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R = @PolynomialRing(QQ, &quot;x&quot;, 4)

f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2

Fac = factor(f)</code></pre><p>For the Singular base rings <code>QQ</code>, <code>ZZ</code> and <code>Fp</code> a function to compute the multivariate factorization is available.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.factor-Tuple{spoly}" href="#Singular.factor-Tuple{spoly}"><code>Singular.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor(x::spoly)</code></pre><blockquote><p>Returns the factorization of <span>$x$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R = @PolynomialRing(ZZ, &quot;x&quot;, 4)

f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2

Fac = factor(f)</code></pre><h3><a class="nav-anchor" id="Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials-1" href="#Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials-1">Conversion between Singular.jl polynomials and MPoly polynomials</a></h3><p>There are conversion functions between the polynomial ring implementation from Singular.jl and the generic MPoly implementation from AbstractAlgebra.jl.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.AsEquivalentSingularPolynomialRing-Union{Tuple{MPolyRing{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.AsEquivalentSingularPolynomialRing-Union{Tuple{MPolyRing{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.AsEquivalentSingularPolynomialRing</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">AsEquivalentSingularPolynomialRing(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true,
  ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min,
  degree_bound::Int = 0)  where {T &lt;: RingElem}</code></pre><blockquote><p>Return a Singular (multivariate) polynomial ring over the base ring of <span>$R$</span> in variables having the same names as those of R.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.AsEquivalentAbstractAlgebraPolynomialRing-Union{Tuple{PolyRing{n_unknown{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.AsEquivalentAbstractAlgebraPolynomialRing-Union{Tuple{PolyRing{n_unknown{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.AsEquivalentAbstractAlgebraPolynomialRing</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">AsEquivalentAbstractAlgebraPolynomialRing(R::Singular.PolyRing{Singular.n_unknown{T}}; ordering::Symbol = :degrevlex)  where {T &lt;: RingElem}</code></pre><blockquote><p>Return an AbstractAlgebra (multivariate) polynomial ring over the base ring of <span>$R$</span> in variables having the same names as those of R.</p></blockquote></div></section><p><strong>Examples</strong></p><p>Conversion of generic AbstractAlgebra polynomials to Singular.jl polynomials:</p><pre><code class="language-julia">K = Nemo.ZZ
R, (x, y) = AbstractAlgebra.Generic.PolynomialRing(K, [&quot;x&quot;, &quot;y&quot;]);
Rsing, vars_Rsing = Singular.AsEquivalentSingularPolynomialRing(R);
Rsing(x + y) == Rsing(x) + Rsing(y)</code></pre><p>Conversion of Singular.jl polynomials to generic AbstractAlgebra polynomials:</p><pre><code class="language-julia">K = Nemo.ZZ
S, (u, v) = Singular.PolynomialRing(K, [&quot;u&quot;, &quot;v&quot;])
Saa, (uu, vv) = Singular.AsEquivalentAbstractAlgebraPolynomialRing(S)
Saa(u) + Saa(v) == Saa(u) + Saa(v)</code></pre><footer><hr/><a class="previous" href="nemo.html"><span class="direction">Previous</span><span class="title">Nemo rings and fields</span></a><a class="next" href="ideal.html"><span class="direction">Next</span><span class="title">Ideals</span></a></footer></article></body></html>
