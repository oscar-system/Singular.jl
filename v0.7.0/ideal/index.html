<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Ideals · Singular.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Singular.jl</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><span class="tocitem">Coefficient rings</span><ul><li><a class="tocitem" href="../integer/">Integers</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../modn/">Integers mod n</a></li><li><a class="tocitem" href="../modp/">Integers mod p</a></li><li><a class="tocitem" href="../transExt/">Function fields</a></li><li><a class="tocitem" href="../GF/">Finite fields</a></li><li><a class="tocitem" href="../nemo/">Nemo rings and fields</a></li></ul></li><li><a class="tocitem" href="../polynomial/">Multivariate polynomials</a></li><li class="is-active"><a class="tocitem" href="">Ideals</a><ul class="internal"><li><a class="tocitem" href="#Ideal-functionality"><span>Ideal functionality</span></a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module/">Finitely generated modules</a></li><li><a class="tocitem" href="../vector/">Free modules and vectors</a></li></ul></li><li><a class="tocitem" href="../alghom/">Algebra Homomorphisms</a></li><li><a class="tocitem" href="../resolution/">Resolutions</a></li><li><a class="tocitem" href="../matrix/">Matrices</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">Ideals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Ideals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/ideal.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Ideals"><a class="docs-heading-anchor" href="#Ideals">Ideals</a><a id="Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Ideals" title="Permalink"></a></h1><p>Singular.jl allows the creation of ideals over a Singular polynomial ring. These are internally stored as a list of (polynomial) generators. This list of generators can also have the property of being a Groebner basis.</p><p>The default ideal type in Singular.jl is the Singular <code>sideal</code> type.</p><p>Ideals objects have a parent object which represents the set of ideals they belong to, the data for which is given by the polynomial ring their generators belong to.</p><p>The types of ideals and associated parent objects are given in the following table according to the library provding them.</p><table><tbody><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Singular</td><td style="text-align: right"><code>sideal{T}</code></td><td style="text-align: right"><code>Singular.IdealSet{T}</code></td></tr></tbody></table><p>These types are parameterised by the type of elements of the polynomial ring over which the ideals are defined.</p><p>All ideal types belong directly to the abstract type <code>Module{T}</code> and all the ideal set parent object types belong to the abstract type <code>Set</code>.</p><h2 id="Ideal-functionality"><a class="docs-heading-anchor" href="#Ideal-functionality">Ideal functionality</a><a id="Ideal-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-functionality" title="Permalink"></a></h2><p>Singular.jl ideals implement standard operations one would expect on modules. These include:</p><ul><li><p>Operations common to all AbstractAlgebra objects, such as <code>parent</code>, <code>base_ring</code>, <code>elem_type</code>, <code>parent_type</code>, <code>parent</code>, <code>deepcopy</code>, etc.</p></li><li><p>Addition</p></li></ul><p>Also implements is the following operations one expects for ideals:</p><ul><li><p>Multiplication</p></li><li><p>Powering</p></li></ul><p>Below, we describe all of the functionality for Singular.jl ideals that is not included in this list of basic operations.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>Given a Singular polynomial ring <span>$R$</span>, the following constructors are available for creating ideals.</p><pre><code class="language-julia">Ideal(R::PolyRing{T}, ids::spoly{T}...) where T &lt;: Nemo.RingElem
Ideal(R::PolyRing{T}, ids::Vector{spoly{T}}) where T &lt;: Nemo.RingElem</code></pre><p>Construct the ideal over the polynomial ring <span>$R$</span> whose (polynomial) generators are given by the given parameter list or array of polynomials, respectively. The list may be empty, resulting in the zero ideal.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])

I1 = Ideal(R, x*y + 1, x^2)
I2 = Ideal(R, [x*y + 1, x^2])</code></pre><h3 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#GroupsCore.ngens-Tuple{sideal}" id="GroupsCore.ngens-Tuple{sideal}"><code>GroupsCore.ngens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ngens(I::sideal)</code></pre><p>Return the number of generators in the internal representation of the ideal <span>$I$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L25" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#GroupsCore.gens-Tuple{sideal}" id="GroupsCore.gens-Tuple{sideal}"><code>GroupsCore.gens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gens(I::sideal)</code></pre><p>Return the generators in the internal representation of the ideal <span>$I$</span> as an array.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L34" target="_blank">source</a></section></article><p>Singular.jl overloads the <code>setindex!</code> and <code>getindex</code> functions so that one can access the generators of an ideal using array notation.</p><pre><code class="language-julia">I[n::Int]</code></pre><article class="docstring"><header><a class="docstring-binding" href="#Base.iszero-Tuple{sideal}" id="Base.iszero-Tuple{sideal}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iszero(I::sideal)</code></pre><p>Return <code>true</code> if the given ideal is algebraically the zero ideal.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L70" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.iszerodim-Tuple{sideal}" id="Singular.iszerodim-Tuple{sideal}"><code>Singular.iszerodim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iszerodim(I::sideal)</code></pre><p>Return <code>true</code> if the given ideal is zero dimensional, i.e. the Krull dimension of <span>$R/I$</span> is zero, where <span>$R$</span> is the polynomial ring over which <span>$I$</span> is an ideal..</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L77" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.dimension-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" id="Singular.dimension-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dimension(I::sideal{spoly{T}}) where T &lt;: Nemo.RingElem</code></pre><p>Given an ideal <span>$I$</span> this function computes the Krull dimension of the ring <span>$R/I$</span>, where <span>$R$</span> is the polynomial ring over which <span>$I$</span> is an ideal. The ideal must be over a polynomial ring and a Groebner basis.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L85" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.isconstant-Tuple{sideal}" id="AbstractAlgebra.isconstant-Tuple{sideal}"><code>AbstractAlgebra.isconstant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isconstant(I::sideal)</code></pre><p>Return <code>true</code> if the given ideal is a constant ideal, i.e. generated by constants in the polynomial ring over which it is an ideal.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L128" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.isvar_generated-Tuple{sideal}" id="Singular.isvar_generated-Tuple{sideal}"><code>Singular.isvar_generated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isvar_generated(I::sideal)</code></pre><p>Return <code>true</code> if each generator in the representation of the ideal <span>$I$</span> is a generator of the polynomial ring, i.e. a variable.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L136" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#LinearAlgebra.normalize!-Tuple{sideal}" id="LinearAlgebra.normalize!-Tuple{sideal}"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize!(I::sideal)</code></pre><p>Normalize the polynomial generators of the ideal <span>$I$</span> in-place. This means to reduce their coefficients to lowest terms. In most cases this does nothing, but if the coefficient ring were the rational numbers for example, the coefficients of the polynomials would be reduced to lowest terms.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L151" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-none">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])

I = Ideal(R, x^2 + 1, x*y)

n = ngens(I)
p = I[1]
I[1] = 2x + y^2
isconstant(I) == false
isvar_generated(I) == false
iszerodim(I) == false

S, (u, v) = PolynomialRing(QQ, ["u", "v"])
J = Ideal(S, u^2 + 1, u*v)
dimension(std(J)) == 0</code></pre><h3 id="Containment"><a class="docs-heading-anchor" href="#Containment">Containment</a><a id="Containment-1"></a><a class="docs-heading-anchor-permalink" href="#Containment" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Base.contains-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem" id="Base.contains-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains{T &lt;: AbstractAlgebra.RingElem}(I::sideal{T}, J::sideal{T})</code></pre><p>Returns <code>true</code> if the ideal <span>$I$</span> contains the ideal <span>$J$</span>. This will be expensive if <span>$I$</span> is not a Groebner ideal, since its standard basis must be computed.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L272" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, x^2 + 1, x*y)
J = Ideal(R, x^2 + 1)

contains(I, J) == true</code></pre><h3 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h3><p>Checking whether two ideals are algebraically equal is very expensive, as it usually requires computing Groebner bases. Therefore we do not overload the <code>==</code> operator for ideals. Instead we have the following two functions.</p><article class="docstring"><header><a class="docstring-binding" href="#Base.isequal-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem" id="Base.isequal-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isequal{T &lt;: AbstractAlgebra.RingElem}(I1::sideal{T}, I2::sideal{T})</code></pre><p>Return <code>true</code> if the given ideals have the same generators in the same order. Note that two algebraically equal ideals with different generators will return <code>false</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L293" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.equal-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem" id="Singular.equal-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.equal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">equal(I1::sideal{T}, I2::sideal{T}) where T &lt;: AbstractAlgebra.RingElem</code></pre><p>Return <code>true</code> if the two ideals are contained in each other, i.e. are the same ideal mathematically. This function should be called only as a last resort; it is exceptionally expensive to test equality of ideals! Do not define <code>==</code> as an alias for this function!</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L308" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, x^2 + 1, x*y)
J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)

isequal(I, J) == false
equal(I, J) == true</code></pre><h3 id="Intersection"><a class="docs-heading-anchor" href="#Intersection">Intersection</a><a id="Intersection-1"></a><a class="docs-heading-anchor-permalink" href="#Intersection" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Singular.intersection-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem" id="Singular.intersection-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection{T &lt;: Nemo.RingElem}(I::sideal{T}, J::sideal{T})</code></pre><p>Returns the intersection of the two given ideals.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L345" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, x^2 + 1, x*y)
J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)

V = intersection(I, J)</code></pre><h3 id="Quotient"><a class="docs-heading-anchor" href="#Quotient">Quotient</a><a id="Quotient-1"></a><a class="docs-heading-anchor-permalink" href="#Quotient" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Singular.quotient-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem" id="Singular.quotient-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.quotient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quotient{T &lt;: Nemo.RingElem}(I::sideal{T}, J::sideal{T})</code></pre><p>Returns the quotient of the two given ideals. Recall that the ideal quotient <span>$(I:J)$</span> over a polynomial ring <span>$R$</span> is defined by <span>$\{r \in R \;|\; rJ \subseteq I\}$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L379" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, x^2 + 1, x*y)
J = Ideal(R, x + y)

V = quotient(I, J)</code></pre><h3 id="Leading-terms"><a class="docs-heading-anchor" href="#Leading-terms">Leading terms</a><a id="Leading-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Leading-terms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.lead-Tuple{sideal}" id="AbstractAlgebra.lead-Tuple{sideal}"><code>AbstractAlgebra.lead</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lead(I::sideal)</code></pre><p>Return the ideal generated by the leading terms of the polynomials generating <span>$I$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L327" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, x^2 + 1, x*y)

V = lead(I)</code></pre><h3 id="Saturation"><a class="docs-heading-anchor" href="#Saturation">Saturation</a><a id="Saturation-1"></a><a class="docs-heading-anchor-permalink" href="#Saturation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Singular.saturation-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem" id="Singular.saturation-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.saturation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">saturation{T &lt;: Nemo.RingElem}(I::sideal{T}, J::sideal{T})</code></pre><p>Returns the saturation of the ideal <span>$I$</span> with respect to <span>$J$</span>, i.e. returns the quotient ideal <span>$(I:J^\infty)$</span> and the number of iterations.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L399" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, (x^2 + x*y + 1)*(2y^2+1)^3, (2y^2 + 3)*(2y^2+1)^2)
J = Ideal(R, 2y^2 + 1)

S = saturation(I, J)</code></pre><h3 id="Standard-basis"><a class="docs-heading-anchor" href="#Standard-basis">Standard basis</a><a id="Standard-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-basis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Statistics.std-Tuple{sideal}" id="Statistics.std-Tuple{sideal}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">std(I::sideal; complete_reduction::Bool=false)</code></pre><p>Compute a Groebner basis for the ideal <span>$I$</span>. Note that without <code>complete_reduction</code> set to <code>true</code>, the generators of the Groebner basis only have unique leading terms (up to permutation and multiplication by constants). If <code>complete_reduction</code> is set to <code>true</code> (and the ordering is a global ordering) then the Groebner basis is unique.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L445" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.fglm-Tuple{sideal, Symbol}" id="Singular.fglm-Tuple{sideal, Symbol}"><code>Singular.fglm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fglm(I::sideal, ::Symbol)</code></pre><p>Compute a Groebner basis for the zero - dimensional ideal <span>$I$</span> in the ring <span>$R$</span> using the FGLM algorithm. All involved orderings have to be global.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L496" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.satstd-Union{Tuple{T}, Tuple{sideal{spoly{T}}, sideal{spoly{T}}}} where T&lt;:AbstractAlgebra.FieldElem" id="Singular.satstd-Union{Tuple{T}, Tuple{sideal{spoly{T}}, sideal{spoly{T}}}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.satstd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>satstd{T &lt;: Nemo.FieldElem}(I::sideal{spoly{T}}, J::sideal{spoly{T}}) Given an ideal <span>$J$</span> generated by variables, computes a standard basis of <code>saturation(I, J)</code>. This is accomplished by dividing polynomials that occur throughout the std computation by variables occuring in <span>$J$</span>, where possible. Thus the result can be obtained faster than by first computing the saturation and then the standard basis.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L477" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.lift_std-Tuple{sideal}" id="Singular.lift_std-Tuple{sideal}"><code>Singular.lift_std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lift_std(I::sideal)</code></pre><p>computes the Groebner base G of I and the transformation matrix T such that (Matrix(G) = Matrix(I) * T)</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L633" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.lift_std_syz-Tuple{sideal}" id="Singular.lift_std_syz-Tuple{sideal}"><code>Singular.lift_std_syz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lift_std_syz(I::sdeal)</code></pre><p>computes the Groebner base G of I, the transformation matrix T and the syzygies of M. Returns G,T,S (Matrix(G) = Matrix(I) * T, 0=Matrix(M)*Matrix(S))</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L620" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, x^2 + x*y + 1, 2y^2 + 3)
J = Ideal(R, 2*y^2 + 3, x^2 + x*y + 1)

A = std(I)

R, (x, y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, (x*y + 1)*(2x^2*y^2 + x*y - 2) + 2x*y^2 + x, 2x*y + 1)
J = Ideal(R, x)

B = satstd(I, J)

R, (x, y, z) = PolynomialRing(QQ, ["x", "y", "z"], ordering = :lex)
I = Ideal(R, y^3+x^2, x^2*y+x^2, x^3-x^2, z^4-x^2-y)
J = fglm(I, :degrevlex)</code></pre><h3 id="Reduction"><a class="docs-heading-anchor" href="#Reduction">Reduction</a><a id="Reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Base.reduce-Tuple{sideal, sideal}" id="Base.reduce-Tuple{sideal, sideal}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>reduce(I::sideal, G::sideal) Return an ideal whose generators are the generators of <span>$I$</span> reduced by the ideal <span>$G$</span>. The ideal <span>$G$</span> is required to be a Groebner basis. The returned ideal will have the same number of generators as <span>$I$</span>, even if they are zero.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L527" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.reduce-Tuple{spoly, sideal}" id="Base.reduce-Tuple{spoly, sideal}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduce(p::spoly, G::sideal)</code></pre><p>Return the polynomial which is <span>$p$</span> reduced by the polynomials generating <span>$G$</span>. It is assumed that <span>$G$</span> is a Groebner basis.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L541" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, ["x", "y"])

f = x^2*y + 2y + 1
g = y^2 + 1

I = Ideal(R, (x^2 + 1)*f + (x + y)*g + x + 1, (2y^2 + x)*f + y)
J = std(Ideal(R, f, g))

V = reduce(I, J)

h1 = (x^2 + 1)*f + (x + y)*g + x + 1

h2 = reduce(h1, J)</code></pre><h3 id="Elimination"><a class="docs-heading-anchor" href="#Elimination">Elimination</a><a id="Elimination-1"></a><a class="docs-heading-anchor-permalink" href="#Elimination" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Singular.eliminate-Tuple{sideal, Vararg{spoly, N} where N}" id="Singular.eliminate-Tuple{sideal, Vararg{spoly, N} where N}"><code>Singular.eliminate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eliminate(I::sideal, polys::spoly...)</code></pre><p>Given a list of polynomials which are variables, construct the ideal corresponding geometrically to the projection of the variety given by the ideal <span>$I$</span> where those variables have been eliminated.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L562" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, t) = PolynomialRing(QQ, ["x", "y", "t"])

I = Ideal(R, x - t^2, y - t^3)

J = eliminate(I, t)</code></pre><h3 id="Syzygies"><a class="docs-heading-anchor" href="#Syzygies">Syzygies</a><a id="Syzygies-1"></a><a class="docs-heading-anchor-permalink" href="#Syzygies" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Singular.syz-Tuple{sideal}" id="Singular.syz-Tuple{sideal}"><code>Singular.syz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">syz(I::sideal)</code></pre><p>Compute the module of syzygies of the ideal.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L602" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)

F = syz(I)

M = Singular.Matrix(I)
N = Singular.Matrix(F)

# check they are actually syzygies
iszero(M*N)</code></pre><h3 id="Free-resolutions"><a class="docs-heading-anchor" href="#Free-resolutions">Free resolutions</a><a id="Free-resolutions-1"></a><a class="docs-heading-anchor-permalink" href="#Free-resolutions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Singular.fres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64, String}} where T&lt;:AbstractAlgebra.FieldElem" id="Singular.fres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64, String}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.fres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> fres{T &lt;: Nemo.FieldElem}(id::Union{sideal{spoly{T}}, smodule{spoly{T}}},
  max_length::Int, method::String="complete")</code></pre><p>Compute a free resolution of the given ideal/module up to the maximum given length. The ideal/module must be over a polynomial ring over a field, and a Groebner basis. The possible methods are "complete", "frame", "extended frame" and "single module". The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal/module. The <code>max_length</code> can be set to <span>$0$</span> if the full free resolution is required.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L651" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.sres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64}} where T&lt;:AbstractAlgebra.FieldElem" id="Singular.sres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.sres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> sres{T &lt;: Nemo.FieldElem}(id::sideal{spoly{T}}, max_length::Int)</code></pre><p>Compute a (free) Schreyer resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal. The <code>max_length</code> can be set to <span>$0$</span> if the full free resolution is required.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L681" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, ["x", "y"])

I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)

F1 = fres(std(I), 0)
F2 = sres(std(I), 2)</code></pre><h3 id="Differential-operations"><a class="docs-heading-anchor" href="#Differential-operations">Differential operations</a><a id="Differential-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-operations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Singular.jet-Tuple{sideal, Int64}" id="Singular.jet-Tuple{sideal, Int64}"><code>Singular.jet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>jet(I::sideal, n::Int) Given an ideal <span>$I$</span> this function truncates the generators of <span>$I$</span> up to degree <span>$n$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L741" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, z) = PolynomialRing(QQ, ["x", "y", "z"])

I = Ideal(R, x^5 - y^2, y^3 - x^6 + z^3)

J1 = jet(I, 3)</code></pre><h3 id="Operations-on-zero-dimensional-ideals"><a class="docs-heading-anchor" href="#Operations-on-zero-dimensional-ideals">Operations on zero-dimensional ideals</a><a id="Operations-on-zero-dimensional-ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-zero-dimensional-ideals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Singular.vdim-Tuple{sideal}" id="Singular.vdim-Tuple{sideal}"><code>Singular.vdim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>vdim(I::sideal) Given a zero-dimensional ideal <span>$I$</span> this function computes the dimension of the vector space <span>$R/I$</span>, where <span>$R$</span> is the polynomial ring over which <span>$I$</span> is an ideal. The ideal must be over a polynomial ring over a field, and a Groebner basis.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L758" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.kbase-Tuple{sideal}" id="Singular.kbase-Tuple{sideal}"><code>Singular.kbase</code></a> — <span class="docstring-category">Method</span></header><section><div><p>kbase(I::sideal) Given a zero-dimensional ideal <span>$I$</span> this function computes a vector space basis of the vector space <span>$R/I$</span>, where <span>$R$</span> is the polynomial ring over which <span>$I$</span> is an ideal. The ideal must be over a polynomial ring over a field, and a Groebner basis.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L775" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.highcorner-Tuple{sideal}" id="Singular.highcorner-Tuple{sideal}"><code>Singular.highcorner</code></a> — <span class="docstring-category">Method</span></header><section><div><p>highcorner(I::sideal) Given a zero-dimensional ideal <span>$I$</span> this function computes a The highest corner of <span>$I$</span>. The output is a polynomial. The ideal must be over a polynomial ring over a field, and a Groebner basis.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L794" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, ["x", "y"]; ordering=:negdegrevlex)

I = Ideal(R, 3*x^2 + y^3, x*y^2)

I = std(I)

n = vdim(I)
J = kbase(I)
f = highcorner(I)</code></pre><h3 id="Operations-over-local-rings"><a class="docs-heading-anchor" href="#Operations-over-local-rings">Operations over local rings</a><a id="Operations-over-local-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-over-local-rings" title="Permalink"></a></h3><p>If the base ring <code>R</code> is a local ring, a minimal generating set can be computed using the following function</p><article class="docstring"><header><a class="docstring-binding" href="#Singular.minimal_generating_set-Tuple{sideal}" id="Singular.minimal_generating_set-Tuple{sideal}"><code>Singular.minimal_generating_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>minimal<em>generating</em>set(I::sideal) Given an ideal <span>$I$</span> in ring <span>$R$</span> with local ordering, this returns an array containing the minimal generators of <span>$I$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L819" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, ["x", "y"]; ordering=:negdegrevlex)

has_local_ordering(R) == true

I = Ideal(R, y, x^2, (1 + y^3) * (x^2 - y))

min = minimal_generating_set(I)</code></pre><h3 id="Independent-sets-of-monomial-ideals"><a class="docs-heading-anchor" href="#Independent-sets-of-monomial-ideals">Independent sets of monomial ideals</a><a id="Independent-sets-of-monomial-ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-sets-of-monomial-ideals" title="Permalink"></a></h3><p>Let <span>$I$</span> be an ideal of <span>$K[x_1, ..., x_n].$</span> An <code>independent set</code> is a subset <span>$u \subseteq \{x_1, ..., x_n\},$</span> such that <span>$I \cap K[u]= 0.$</span> In case <span>$u$</span> cannot be enlarged, it is called <code>non-extendable independent set</code>. If in addition <span>$|u| = dim(K[x_1, ..., x_n]/I),$</span><span>$u$</span> is called <code>maximal independent set</code>. Using Singular.jl one can compute non-extendable, resp. maximal independent sets for monomial ideals. If an arbitrary ideal <span>$I$</span> is passed to the function, the computation is performed on the leading ideal of <span>$I$</span>.</p><article class="docstring"><header><a class="docstring-binding" href="#Singular.independent_sets-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.FieldElem" id="Singular.independent_sets-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.independent_sets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">independent_sets(I::sideal{spoly{T}}) where T &lt;: Nemo.FieldElem</code></pre><p>Returns all non-extendable independent sets of <span>$lead(I)$</span>. <span>$I$</span> has to be given by a Groebner basis.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L838" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.maximal_independent_set-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.FieldElem" id="Singular.maximal_independent_set-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.maximal_independent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">maximal_independent_set(I::sideal{spoly{T}}; all::Bool = false) where T &lt;: Nemo.FieldElem</code></pre><p>Returns, by default, an array containing a maximal independet set of <span>$lead(I)$</span>. <span>$I$</span> has to be given by a Groebner basis. If the additional parameter "all" is set to true, an array containing all maximal independent sets of <span>$lead(I)$</span> is returned.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/a38fef31a27dd96caa74cc7aac476e5bd7bbfded/src/ideal/ideal.jl#L863" target="_blank">source</a></section></article><pre><code class="language-julia">R, (x, y, u, v, w) = PolynomialRing(QQ, ["x", "y", "u", "v", "w"])

has_local_ordering(R) == true

I = Ideal(R, x*y*w, y*v*w, u*y*w, x*v)

I = std(I)

L1 = independent_sets(I)

L2 = maximal_independent_set(I)

L3 = maximal_independent_set(I, all = true)

</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../polynomial/">« Multivariate polynomials</a><a class="docs-footer-nextpage" href="../module/">Finitely generated modules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 28 September 2021 15:12">Tuesday 28 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>