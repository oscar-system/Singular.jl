<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ideals · Singular.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Singular.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><span class="toctext">Coefficient rings</span><ul><li><a class="toctext" href="integer.html">Integers</a></li><li><a class="toctext" href="rational.html">Rational field</a></li><li><a class="toctext" href="modn.html">Integers mod n</a></li><li><a class="toctext" href="modp.html">Integers mod p</a></li><li><a class="toctext" href="GF.html">Finite fields</a></li><li><a class="toctext" href="nemo.html">Nemo rings and fields</a></li></ul></li><li><a class="toctext" href="polynomial.html">Multivariate polynomials</a></li><li class="current"><a class="toctext" href="ideal.html">Ideals</a><ul class="internal"><li><a class="toctext" href="#Ideal-functionality-1">Ideal functionality</a></li></ul></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="module.html">Finitely generated modules</a></li><li><a class="toctext" href="vector.html">Free modules and vectors</a></li></ul></li><li><a class="toctext" href="resolution.html">Resolutions</a></li><li><a class="toctext" href="matrix.html">Matrices</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="ideal.html">Ideals</a></li></ul><a class="edit-page" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/ideal.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Ideals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Ideals-1" href="#Ideals-1">Ideals</a></h1><p>Singular.jl allows the creation of ideals over a Singular polynomial ring. These are internally stored as a list of (polynomial) generators. This list of generators can also  have the property of being a Groebner basis.</p><p>The default ideal type in Singular.jl is the Singular <code>sideal</code> type.</p><p>Ideals objects have a parent object which represents the set of ideals they belong to, the data for which is given by the polynomial ring their generators belong to.</p><p>The types of ideals and associated parent objects are given in the following table according to the library provding them.</p><table><tr><th>Library</th><th>Element type</th><th>Parent type</th></tr><tr><td>Singular</td><td><code>sideal{T}</code></td><td><code>Singular.IdealSet{T}</code></td></tr></table><p>These types are parameterised by the type of elements of the polynomial ring over which the ideals are defined.</p><p>All ideal types belong directly to the abstract type <code>Module{T}</code> and all the ideal set parent object types belong to the abstract type <code>Set</code>.</p><h2><a class="nav-anchor" id="Ideal-functionality-1" href="#Ideal-functionality-1">Ideal functionality</a></h2><p>Singular.jl ideals implement standard operations one would expect on modules. These include:</p><ul><li><p>Operations common to all AbstractAlgebra objects, such as <code>parent</code>, <code>base_ring</code>, <code>elem_type</code>, <code>parent_type</code>, <code>parent</code>, <code>deepcopy</code>, etc.</p></li><li><p>Addition</p></li></ul><p>Also implements is the following operations one expects for ideals:</p><ul><li><p>Multiplication</p></li><li><p>Powering</p></li></ul><p>Below, we describe all of the functionality for Singular.jl ideals that is not included in this list of basic operations.</p><h3><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h3><p>Given a Singular polynomial ring <span>$R$</span>, the following constructors are available for creating ideals.</p><pre><code class="language-julia">Ideal(R::PolyRing{T}, ids::spoly{T}...) where T &lt;: Nemo.RingElem
Ideal(R::PolyRing{T}, ids::Array{spoly{T}, 1}) where T &lt;: Nemo.RingElem</code></pre><p>Construct the ideal over the polynomial ring <span>$R$</span> whose (polynomial) generators are given  by the given parameter list or array of polynomials, respectively. The list may be empty, resulting in the zero ideal.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;])

I1 = Ideal(R, x*y + 1, x^2)
I2 = Ideal(R, [x*y + 1, x^2])</code></pre><h3><a class="nav-anchor" id="Basic-manipulation-1" href="#Basic-manipulation-1">Basic manipulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.ngens-Tuple{Singular.sideal}" href="#Singular.ngens-Tuple{Singular.sideal}"><code>Singular.ngens</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ngens(I::sideal)</code></pre><blockquote><p>Return the number of generators in the internal representation of the ideal <span>$I$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L23">source</a></section><p>Singular.jl overloads the <code>setindex!</code> and <code>getindex</code> functions so that one can access the generators of an ideal using array notation.</p><pre><code class="language-julia">I[n::Int]</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.iszero-Tuple{Singular.sideal}" href="#Base.iszero-Tuple{Singular.sideal}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">iszero(I::sideal)</code></pre><blockquote><p>Return <code>true</code> if the given ideal is algebraically the zero ideal.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.iszerodim-Tuple{Singular.sideal}" href="#Singular.iszerodim-Tuple{Singular.sideal}"><code>Singular.iszerodim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">iszerodim(I::sideal)</code></pre><blockquote><p>Return <code>true</code> if the given ideal is zero dimensional, i.e. the Krull dimension of <span>$R/I$</span> is zero, where <span>$R$</span> is the polynomial ring over which <span>$I$</span> is an ideal..</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.isconstant-Tuple{Singular.sideal}" href="#AbstractAlgebra.Generic.isconstant-Tuple{Singular.sideal}"><code>AbstractAlgebra.Generic.isconstant</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isconstant(I::sideal)</code></pre><blockquote><p>Return <code>true</code> if the given ideal is a constant ideal, i.e. generated by constants in the polynomial ring over which it is an ideal.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.isvar_generated-Tuple{Singular.sideal}" href="#Singular.isvar_generated-Tuple{Singular.sideal}"><code>Singular.isvar_generated</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvar_generated(I::sideal)</code></pre><blockquote><p>Return <code>true</code> if each generator in the representation of the ideal <span>$I$</span> is a generator of the polynomial ring, i.e. a variable.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.normalize!-Tuple{Singular.sideal}" href="#Base.LinAlg.normalize!-Tuple{Singular.sideal}"><code>Base.LinAlg.normalize!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">normalize!(I::sideal)</code></pre><blockquote><p>Normalize the polynomial generators of the ideal <span>$I$</span> in-place. This means to reduce their coefficients to lowest terms. In most cases this does nothing, but if the coefficient ring were the rational numbers for example, the coefficients of the polynomials would be reduced to lowest terms.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L86">source</a></section><p><strong>Examples</strong></p><pre><code class="language-none">R, (x, y) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, x^2 + 1, x*y)

n = ngens(I)
p = I[1]
I[1] = 2x + y^2
isconstant(I) == false
isvar_generated(I) == false
iszerodim(I) == false</code></pre><h3><a class="nav-anchor" id="Containment-1" href="#Containment-1">Containment</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.contains-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Base.contains-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Base.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains{T &lt;: AbstractAlgebra.RingElem}(I::sideal{T}, J::sideal{T})</code></pre><blockquote><p>Returns <code>true</code> if the ideal <span>$I$</span> contains the ideal <span>$J$</span>. This will be expensive if <span>$I$</span> is not a Groebner ideal, since its standard basis must be computed.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L172">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, x^2 + 1, x*y)
J = Ideal(R, x^2 + 1)

contains(I, J) == true</code></pre><h3><a class="nav-anchor" id="Comparison-1" href="#Comparison-1">Comparison</a></h3><p>Checking whether two ideals are algebraically equal is very expensive, as it usually requires computing Groebner bases. Therefore we do not overload the <code>==</code> operator for ideals. Instead we have the following two functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isequal-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Base.isequal-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isequal{T &lt;: AbstractAlgebra.RingElem}(I1::sideal{T}, I2::sideal{T})</code></pre><blockquote><p>Return <code>true</code> if the given ideals have the same generators in the same order. Note that two algebraically equal ideals with different generators will return <code>false</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.equal-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.equal-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.equal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">equal(I1::sideal{T}, I2::sideal{T}) where T &lt;: AbstractAlgebra.RingElem</code></pre><blockquote><p>Return <code>true</code> if the two ideals are contained in each other, i.e. are the same ideal mathematically. This function should be called only as a last resort; it is exceptionally expensive to test equality of ideals! Do not define <code>==</code> as an alias for this function!</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L206">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, x^2 + 1, x*y)
J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)

isequal(I, J) == false
equal(I, J) == true</code></pre><h3><a class="nav-anchor" id="Intersection-1" href="#Intersection-1">Intersection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.intersection-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.intersection-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">intersection{T &lt;: Nemo.RingElem}(I::sideal{T}, J::sideal{T})</code></pre><blockquote><p>Returns the intersection of the two given ideals.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L241">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, x^2 + 1, x*y)
J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)

V = intersection(I, J)</code></pre><h3><a class="nav-anchor" id="Quotient-1" href="#Quotient-1">Quotient</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.quotient-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.quotient-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.quotient</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">quotient{T &lt;: Nemo.RingElem}(I::sideal{T}, J::sideal{T})</code></pre><blockquote><p>Returns the quotient of the two given ideals. Recall that the ideal quotient <span>$(I:J)$</span> over a polynomial ring <span>$R$</span> is defined by <span>$\{r \in R \;|\; rJ \subseteq I\}$</span>. </p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L259">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, x^2 + 1, x*y)
J = Ideal(R, x + y)

V = quotient(I, J)</code></pre><h3><a class="nav-anchor" id="Leading-terms-1" href="#Leading-terms-1">Leading terms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.lead-Tuple{Singular.sideal}" href="#AbstractAlgebra.Generic.lead-Tuple{Singular.sideal}"><code>AbstractAlgebra.Generic.lead</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lead(I::sideal)</code></pre><blockquote><p>Return the ideal generated by the leading terms of the polynomials generating <span>$I$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L224">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x , y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, x^2 + 1, x*y)

V = lead(I)</code></pre><h3><a class="nav-anchor" id="Saturation-1" href="#Saturation-1">Saturation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.saturation-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.saturation-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.saturation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">saturation{T &lt;: Nemo.RingElem}(I::sideal{T}, J::sideal{T})</code></pre><blockquote><p>Returns the saturation of the ideal <span>$I$</span> with respect to <span>$J$</span>, i.e. returns the quotient ideal <span>$(I:J^\infty)$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L278">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, (x^2 + x*y + 1)*(2y^2+1)^3, (2y^2 + 3)*(2y^2+1)^2)
J = Ideal(R, 2y^2 + 1)

S = saturation(I, J)</code></pre><h3><a class="nav-anchor" id="Standard-basis-1" href="#Standard-basis-1">Standard basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.std-Tuple{Singular.sideal}" href="#Base.std-Tuple{Singular.sideal}"><code>Base.std</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">std(I::sideal; complete_reduction::Bool=false)</code></pre><blockquote><p>Compute a Groebner basis for the ideal <span>$I$</span>. Note that without <code>complete_reduction</code> set to <code>true</code>, the generators of the Groebner basis only have unique leading terms (up to permutation and multiplication by constants). If <code>complete_reduction</code> is set to <code>true</code> (and the ordering is a global ordering) then the Groebner basis is unique.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.satstd-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.satstd-Union{Tuple{Singular.sideal{T},Singular.sideal{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.satstd</code></a> — <span class="docstring-category">Method</span>.</div><div><p>satstd{T &lt;: AbstractAlgebra.RingElem}(I::sideal{T}, J::sideal{T})</p><blockquote><p>Given an ideal <span>$J$</span> generated by variables, computes a standard basis of <code>saturation(I, J)</code>. This is accomplished by dividing polynomials that occur throughout the std computation by variables occuring in <span>$J$</span>, where possible. Thus the result can be obtained faster than by first computing the saturation and then the standard basis.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L319">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, x^2 + x*y + 1, 2y^2 + 3)
J = Ideal(R, 2*y^2 + 3, x^2 + x*y + 1)

A = std(I)

R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, (x*y + 1)*(2x^2*y^2 + x*y - 2) + 2x*y^2 + x, 2x*y + 1)
J = Ideal(R, x)

B = satstd(I, J)</code></pre><h3><a class="nav-anchor" id="Reduction-1" href="#Reduction-1">Reduction</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reduce-Tuple{Singular.sideal,Singular.sideal}" href="#Base.reduce-Tuple{Singular.sideal,Singular.sideal}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span>.</div><div><p>reduce(I::sideal, G::sideal)</p><blockquote><p>Return an ideal whose generators are the generators of <span>$I$</span> reduced by the ideal <span>$G$</span>. The ideal <span>$G$</span> is required to be a Groebner basis. The returned ideal will have the same number of generators as <span>$I$</span>, even if they are zero.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L344">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reduce-Tuple{Singular.spoly,Singular.sideal}" href="#Base.reduce-Tuple{Singular.spoly,Singular.sideal}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reduce(p::spoly, G::sideal)</code></pre><blockquote><p>Return the polynomial which is <span>$p$</span> reduced by the polynomials generating <span>$G$</span>. It is assumed that <span>$G$</span> is a Groebner basis.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L358">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

f = x^2*y + 2y + 1
g = y^2 + 1

I = Ideal(R, (x^2 + 1)*f + (x + y)*g + x + 1, (2y^2 + x)*f + y)
J = std(Ideal(R, f, g))

V = reduce(I, J)

h1 = (x^2 + 1)*f + (x + y)*g + x + 1

h2 = reduce(h1, J)</code></pre><h3><a class="nav-anchor" id="Elimination-1" href="#Elimination-1">Elimination</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.eliminate-Tuple{Singular.sideal,Vararg{Singular.spoly,N} where N}" href="#Singular.eliminate-Tuple{Singular.sideal,Vararg{Singular.spoly,N} where N}"><code>Singular.eliminate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eliminate(I::sideal, polys::spoly...)</code></pre><blockquote><p>Given a list of polynomials which are variables, construct the ideal corresponding geometrically to the projection of the variety given by the ideal <span>$I$</span> where those variables have been eliminated.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L378">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, t) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;t&quot;])

I = Ideal(R, x - t^2, y - t^3)

J = eliminate(I, t)</code></pre><h3><a class="nav-anchor" id="Syzygies-1" href="#Syzygies-1">Syzygies</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.syz-Tuple{Singular.sideal}" href="#Singular.syz-Tuple{Singular.sideal}"><code>Singular.syz</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">syz(I::sideal)</code></pre><blockquote><p>Compute the module of syzygies of the ideal.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L418">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)

F = syz(I)

M = Singular.Matrix(I)
N = Singular.Matrix(F)

# check they are actually syzygies
iszero(M*N)</code></pre><h3><a class="nav-anchor" id="Free-resolutions-1" href="#Free-resolutions-1">Free resolutions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.fres-Union{Tuple{Singular.sideal{T},Int64,String}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.fres-Union{Tuple{Singular.sideal{T},Int64,String}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.fres</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none"> fres{T &lt;: Nemo.RingElem}(id::sideal{T}, max_length::Int,
  method::String=&quot;complete&quot;)</code></pre><blockquote><p>Compute a free resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The possible methods are &quot;complete&quot;, &quot;frame&quot;, &quot;extended frame&quot; and &quot;single module&quot;. The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal. The <code>max_length</code> can be set to <span>$0$</span> if the full free resolution is required.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L435">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.sres-Union{Tuple{Singular.sideal{T},Int64}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.sres-Union{Tuple{Singular.sideal{T},Int64}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.sres</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none"> sres{T &lt;: Nemo.RingElem}(id::sideal{T}, max_length::Int)</code></pre><blockquote><p>Compute a (free) Schreyer resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal. The <code>max_length</code> can be set to <span>$0$</span> if the full free resolution is required.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/902451577a33d367bbc306fcaf697c35479c5906/src/ideal/ideal.jl#L464">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)

F1 = fres(std(I), 0)
F2 = sres(std(I), 2)</code></pre><footer><hr/><a class="previous" href="polynomial.html"><span class="direction">Previous</span><span class="title">Multivariate polynomials</span></a><a class="next" href="module.html"><span class="direction">Next</span><span class="title">Finitely generated modules</span></a></footer></article></body></html>
