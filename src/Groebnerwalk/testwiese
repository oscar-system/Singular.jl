include("GroebnerWalk.jl")
function test()

    R, (x, y) = Singular.PolynomialRing(
        Singular.QQ,
        ["x", "y"],
        ordering = Singular.ordering_M(ordering_as_matrix(:degrevlex, 2)),
    )

f1=  y^4  -x^2  +x +x^3
f2= x^4
        I = Singular.Ideal(R, [f1, f2])
        I = Singular.std(I, complete_reduction = true)
        println("last", I)

    @time JJ = groebnerwalk(
        I,
        ordering_as_matrix(:degrevlex, 2),
        ordering_as_matrix(:lex, 2),
        :generic,
    )
    println(JJ)

    S, V = Singular.PolynomialRing(Singular.QQ, ["x", "y"], ordering = :lex)
    @time T0 = Singular.std(
        Singular.Ideal(S, [change_ring(x, S) for x in gens(I)]),
        complete_reduction = true,
    )
    T1 = Singular.Ideal(S, [change_ring(x, S) for x in gens(JJ)])
    println(T0)

end

function test2()

        R, (x, y,z) = Singular.PolynomialRing(
            Singular.QQ,
            ["x", "y", "z"],
            ordering = Singular.ordering_M(ordering_as_matrix([29,10,40],:revlex)),
        )

 f1= y*z^2 + z*y
 f2= y^5*z - z*y
 f3= x + y^3*z
 f4= z^3 - y^4*z



        I = Singular.Ideal(R, [ f1,f3,f2])
        println(I)
        I = Singular.std(I, complete_reduction = true)
        println("last", I)
        @time JJ = groebnerwalk(
            I,
            ordering_as_matrix([29,10,40],:revlex),
            ordering_as_matrix(:lex, 3),
            :generic,
            3,
        )
        println(JJ)
    end
    function test1()

            R, (x, y,z) = Singular.PolynomialRing(
                Singular.QQ,
                ["x", "y", "z"],
                ordering = Singular.ordering_M(ordering_as_matrix([2,3,4],:revlex)),
            )
f1= y^2 + x*z
f2=  x*y - x*z
f3= z^3 + x^2
f4=  x*z^2
f5= x^2*z
f6= x^3


            I = Singular.Ideal(R, [f1, f2, f3, f4, f5, f6])
            println(I)
            I = Singular.std(I, complete_reduction = true)
            println("last", I)
            @time JJ = groebnerwalk(
                I,
                ordering_as_matrix([2,3,4],:revlex),
                ordering_as_matrix([3,2,1],:revlex),
                :standard,
            )
#=            @time JJ = groebnerwalk(
                I,
                ordering_as_matrix([1,11,8],:lex),
                ordering_as_matrix([2,1,1],:lex),
                :generic,
                3,
            )
            @time JJ = groebnerwalk(
                I,
                ordering_as_matrix([1,11,8],:lex),
                ordering_as_matrix([2,1,1],:lex),
                :fractal_walk_lookahead,
                3,
            )
            @time JJ = groebnerwalk(
                I,
                ordering_as_matrix([1,4,10],:lex),
                ordering_as_matrix([2,1,1],:lex),
                :fractal_walk_lookahead,
                3,
            )
            @time JJ = groebnerwalk(
                I,
                ordering_as_matrix([1,4,10],:lex),
                ordering_as_matrix([2,1,1],:lex),
                :tran,
                3,
            )

            @time JJ = groebnerwalk(
                I,
                ordering_as_matrix([1,4,10],:lex),
                ordering_as_matrix([2,1,1],:lex),
                :generic,
                3,
            )
=#
            println(JJ)
        end
    function test3()

            R, (x, y) = Singular.PolynomialRing(
                Singular.QQ,
                ["x", "y"],
                ordering = Singular.ordering_M(ordering_as_matrix(:deglex, 2)),
            )
        f1 = x^2 + x*y
        f2= x*y
        f3= 2*y^2 - x
            I = Singular.Ideal(R, [f1,  f2,f3])
            println(I)

            println(std(I))
            I = Singular.std(I, complete_reduction = true)
            println("last", I)
            @time JJ = groebnerwalk(
                I,
                ordering_as_matrix(:degrevlex, 2),
                ordering_as_matrix(:lex, 2),
                :generic,
            )
            println(JJ)
        end
