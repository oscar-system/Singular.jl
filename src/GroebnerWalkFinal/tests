include("GroebnerWalkFinal.jl")
include("Examples")
using Test

@testset "Groebnerwalks" begin
    @testset "Testing Groebnerwalks" begin
        let id = cyclic5()
            R = base_ring(id)
            dim = nvars(R)
            ve=ones(Int64,dim)
            StartOrd = ordering_as_matrix(:degrevlex, dim)
            TarOrd = ordering_as_matrix(:lex, dim)
            S = change_order(R, TarOrd)
            I = Singular.std(id, complete_reduction = true)

            ideals = []
            for i = 2:nvars(S)-1
                push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :pertubed, i))
            end
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :standard))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :generic))
            #push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal_look_ahead))
            #push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal_lex))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal_combined))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :generic))

            s = Singular.std(
                Singular.Ideal(S, [change_ring(x, S) for x in Singular.gens(id)]),
                complete_reduction = true,
            )

            for id in ideals
                @test equalitytest(
                    Singular.Ideal(S, [change_ring(x, S) for x in Singular.gens(id)]),
                    s,
                )
            end
        end

        let id = katsura5()
            R = base_ring(id)
            dim = nvars(R)
            ve=ones(Int64,dim)
            StartOrd = ordering_as_matrix(:degrevlex, dim)
            TarOrd = ordering_as_matrix(:lex, dim)
            S = change_order(R, TarOrd)

            I = Singular.std(id, complete_reduction = true)

            ideals = []
            for i = 1:nvars(S)-1
                push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :pertubed, i))
            end
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :standard))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :generic))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal_look_ahead))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal_lex))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal_combined))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :generic))

            s = Singular.std(
                Singular.Ideal(S, [change_ring(x, S) for x in Singular.gens(id)]),
                complete_reduction = true,
            )

            for id in ideals
                @test equalitytest(
                    Singular.Ideal(S, [change_ring(x, S) for x in Singular.gens(id)]),
                    s,
                )
            end
        end

        let id = cyclic4()
            R = base_ring(id)
            dim = nvars(R)
            ve=ones(Int64,dim)
            StartOrd = ordering_as_matrix(:degrevlex, dim)
            TarOrd = ordering_as_matrix(:lex, dim)
            S = change_order(R, TarOrd)

            I = Singular.std(id, complete_reduction = true)

            ideals = []
            for i = 2:nvars(S)-1
                push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :pertubed, i))
            end
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :standard))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :generic))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal_look_ahead))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal_lex))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :fractal_combined))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :generic))

            s = Singular.std(
                Singular.Ideal(S, [change_ring(x, S) for x in Singular.gens(id)]),
                complete_reduction = true,
            )


            for id in ideals
                @test equalitytest(
                    Singular.Ideal(S, [change_ring(x, S) for x in Singular.gens(id)]),
                    s,
                )
            end
        end

        let id = ex1()
            R = base_ring(id)
            dim = nvars(R)
            ve=ones(Int64,dim)
            StartOrd = ordering_as_matrix(:degrevlex,dim)
            TarOrd = ordering_as_matrix(:lex, dim)
            S = change_order(R, TarOrd)

            I = Singular.std(id, complete_reduction = true)

            ideals = []
            for i = 2:nvars(S)
                push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex, dim), ordering_as_matrix(:lex, dim), :pertubed, i))
            end
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex), ordering_as_matrix(:lex, dim), :standard))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex), ordering_as_matrix(:lex, dim), :generic))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex), ordering_as_matrix(:lex, dim), :fractal))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex), ordering_as_matrix(:lex, dim), :fractal_look_ahead))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex), ordering_as_matrix(:lex, dim), :fractal_lex))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex), ordering_as_matrix(:lex, dim), :fractal_combined))
            push!(ideals, groebnerwalk(I, ordering_as_matrix(:degrevlex), ordering_as_matrix(:lex, dim), :generic))

            s = Singular.std(
                Singular.Ideal(S, [change_ring(x, S) for x in Singular.gens(id)]),
                complete_reduction = true,
            )

            for id in ideals
                @test equalitytest(
                    Singular.Ideal(S, [change_ring(x, S) for x in Singular.gens(id)]),
                    s,
                )
            end
        end
    end
end
