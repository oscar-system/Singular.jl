include(
    "/Users/JordiWelp/github/Singular.jl/src/GroebnerWalkFinal/GroebnerWalkUtilitysFinal.jl",
)
include(
    "/Users/JordiWelp/github/Singular.jl/src/GroebnerWalkFinal/FractalWalkUtilitysFinal.jl",
)
include(
    "/Users/JordiWelp/github/Singular.jl/src/GroebnerWalkFinal/GenericWalkUtilitysFinal.jl",
)
include(
    "/Users/JordiWelp/github/Singular.jl/src/GroebnerWalkFinal/StandardWalkUtilitysFinal.jl",
)
include(
    "/Users/JordiWelp/github/Singular.jl/src/GroebnerWalkFinal/TranWalkUtilitysFinal.jl",
)
using BenchmarkTools
BenchmarkTools.DEFAULT_PARAMETERS.samples = 1
BenchmarkTools.DEFAULT_PARAMETERS.evals = 1
a = "-"
b = "-"
z = "-"
c = "-"
d = "-"
e = "-"
f = "-"
g = "-"
h = "-"
i = "-"
j = "-"
k = "-"
l = "-"

a2 = "-"
b2 = "-"
z2 = "-"
c2 = "-"
d2 = "-"
e2 = "-"
f2 = "-"
g2 = "-"
h2 = "-"
i2 = "-"
j2 = "-"
k2 = "-"
l2 = "-"

function cleardf()
    global a = "-"
    global b = "-"
    global c = "-"
    global d = "-"
    global e = "-"
    global f = "-"
    global g = "-"
    global h = "-"
    global i = "-"
    global j = "-"
    global k = "-"
    global l = "-"
    global z = "-"
    global a2 = "-"
    global b2 = "-"
    global c2 = "-"
    global d2 = "-"
    global e2 = "-"
    global f2 = "-"
    global g2 = "-"
    global h2 = "-"
    global i2 = "-"
    global j2 = "-"
    global k2 = "-"
    global l2 = "-"
    global z2 = "-"
end




###############################################################
#Implementation of the gröbner walk.
###############################################################

#for counting the steps of the groebnerwalk.
counter = 0
function getCounter()
    global counter
    temp = counter
    counter = 0
    return temp
end
#=
@doc Markdown.doc"""
function groebnerwalk(
    G::Singular.sideal,
    S::Matrix{Int64},
    T::Matrix{Int64},
    grwalktype::Symbol = :standard,
    p::Int64 = 0,
)
Given an Ideal G generated by a reduced Groebner Basis w.r.t. the monomial ordering S this function
returns a reduced Groebner Basis w.r.t. the monomial ordering T by converting it using the Groebner Walk.
The Groebner Walk is proposed by Collart et al. (1993)
One can choose a strategy of:
Standard Walk (:standard) computes the Walk like it´s presented in Cox et al. (2005).
Generic Walk (:generic) computes the Walk like it´s presented in Fukuda et al. (2006).
Pertubed Walk (:pertubed, with p = Pertubation degree) computes the Walk like it´s presented in Amrhein et al. (1997).
Tran´s Walk (:tran) computes the Walk like it´s presented in Tran (2000).
Fractal Walk (:fractal) computes the Walk like it´s presented in Amrhein & Gloor (1998). Pertubes only the target vector.
Fractal Walk (:fractal_start_order) computes the Walk like it´s presented in Amrhein & Gloor (1998). Pertubes oth, the start und the target vector.
Fractal Walk (:fractal_lex) computes the Walk like it´s presented in Amrhein & Gloor (1998) in the special case that T represents the lex ordering. Pertubes only the target vector.
Fractal Walk (:factal_look_ahead) computes the Walk like it´spresented in Amrhein & Gloor (1998). This Version uses the buchberger algorithm under certain circumstances before reaching the maximal pertubation depth.
"""=#
function groebnerwalk(
    G::Singular.sideal,
    S::Matrix{Int64},
    T::Matrix{Int64},
    grwalktype::Symbol = :standard,
    p::Int64 = 0,
)
    if grwalktype == :standard
        walk = (x, y, z) -> standard_walk(x, y, z)
    elseif grwalktype == :generic
        walk = (x, y, z) -> generic_walk(x, y, z)
    elseif grwalktype == :pertubed
        walk = (x, y, z) -> pertubed_walk(x, y, z, p)
    elseif grwalktype == :fractal
        walk =
            (x, y, z) -> fractal_walk(
                x,
                MonomialOrder(S, S[1, :], [0]),
                MonomialOrder(T, T[1, :], T[1, :]),
            )
    elseif grwalktype == :fractal_start_order
        walk =
            (x, y, z) -> fractal_walk_start_order(
                x,
                MonomialOrder(S, S[1, :], [0]),
                MonomialOrder(T, T[1, :], T[1, :]),
            )
    elseif grwalktype == :fractal_lex
        walk =
            (x, y, z) -> fractal_walk_lex(
                x,
                MonomialOrder(S, S[1, :], [0]),
                MonomialOrder(T, T[1, :], T[1, :]),
            )
    elseif grwalktype == :fractal_look_ahead
        walk =
            (x, y, z) -> fractal_walk_look_ahead(
                x,
                MonomialOrder(S, S[1, :], [0]),
                MonomialOrder(T, T[1, :], T[1, :]),
            )
    elseif grwalktype == :tran
        walk = (x, y, z) -> tran_walk(x, y, z)
    elseif grwalktype == :fractal_combined
        walk =
            (x, y, z) -> fractal_walk_combined(
                x,
                MonomialOrder(S, S[1, :], [0]),
                MonomialOrder(T, T[1, :], T[1, :]),
            )
    end

    ######TODO:Check the parameter#####
    R = base_ring(G)
    I = Singular.Ideal(R, [R(x) for x in gens(G)])

    Gb = walk(I, S, T)
    println("Cones crossed: ", getCounter())

    S = change_order(Gb.base_ring, T)
    return Singular.Ideal(S, [change_ring(gen, S) for gen in gens(Gb)])
end


function standard_walk(G::Singular.sideal, S::Matrix{Int64}, T::Matrix{Int64})
    println("standard_walk results")
    println("Crossed Cones in: ")
    standard_walk(G, S, T, S[1, :], T[1, :])
end

function standard_walk(
    G::Singular.sideal,
    S::Matrix{Int64},
    T::Matrix{Int64},
    cweight::Vector{Int64},
    tweight::Vector{Int64},
)
    R = base_ring(G)
    Rn = change_order(R, cweight, T)
    terminate = false
    while !terminate
        global counter = getCounter() + 1
        println(cweight)
        global b = cweight
        global b2 = cweight
        G = standard_step(G, R, cweight, Rn)
        if cweight == tweight
            terminate = true
        else
            global a =
                @belapsed next_weight($G, $cweight, $tweight) evals = 1 samples =
                    1
            global a2 =
                @ballocated next_weight($G, $cweight, $tweight) evals = 1 samples =
                    1

            cweight = next_weight(G, cweight, tweight)
            R = Rn
            Rn = change_order(Rn, cweight, T)
        end
    end
    return G
end

function standard_step(
    G::Singular.sideal,
    R::Singular.PolyRing,
    cw::Vector{Int64},
    Rn::Singular.PolyRing,
)
    global z = length(Singular.gens(G))
    global z2 = length(Singular.gens(G))


    global c = @belapsed initials($Rn, gens($G), $cw) evals = 1 samples = 1
    global c2 = @ballocated initials($Rn, gens($G), $cw) evals = 1 samples = 1

    Gw = initials(Rn, gens(G), cw)
    global d = @belapsed Singular.std(
        Singular.Ideal($Rn, $Gw),
        complete_reduction = true,
    ) evals = 1 samples = 1

    global d2 = @ballocated Singular.std(
        Singular.Ideal($Rn, $Gw),
        complete_reduction = true,
    ) evals = 1 samples = 1

    H = Singular.std(Singular.Ideal(Rn, Gw), complete_reduction = true)


    global e = @belapsed liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1
    global e2 = @ballocated liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1

    global f = @belapsed lift($G, $R, $H, $Rn) evals = 1 samples = 1
    global f2 = @ballocated lift($G, $R, $H, $Rn) evals = 1 samples = 1

    #H = liftGW2(G, R, Gw, H, Rn)
    H = lift(G, R, H, Rn)
    global g =
        @belapsed Singular.std($H, complete_reduction = true) evals = 1 samples =
            1
    global g2 =
        @ballocated Singular.std($H, complete_reduction = true) evals = 1 samples =
            1

    df = DataFrame(
        a = [a],
        b = [b],
        z = [z],
        c = [c],
        d = [d],
        e = [e],
        f = [f],
        g = [g],
        h = [counter],
    )
    df2 = DataFrame(
        a2 = [a2],
        b2 = [b2],
        z2 = [z2],
        c2 = [c2],
        d2 = [d2],
        e2 = [e2],
        f2 = [f2],
        g2 = [g2],
        h2 = [counter],
    )

    savea(df, "standardWalk")
    savea(df2, "allocsStandardWalk")
    cleardf()
    return Singular.std(H, complete_reduction = true)
end
##############################
#just for benchmark######
#############################
function standard_walk2(G::Singular.sideal, S::Matrix{Int64}, T::Matrix{Int64})
    println("standard_walk results")
    println("Crossed Cones in: ")
    standard_walk2(G, S, T, S[1, :], T[1, :])
end

function standard_walk2(
    G::Singular.sideal,
    S::Matrix{Int64},
    T::Matrix{Int64},
    cweight::Vector{Int64},
    tweight::Vector{Int64},
    k::Int64,
)
    R = base_ring(G)
    Rn = change_order(R, cweight, T)
    terminate = false
    while !terminate
        global counter = getCounter() + 1
        println(cweight)
        global b = cweight
        global b2 = cweight

        G = standard_step2(G, R, cweight, Rn)
        df = DataFrame(
            a = [a],
            b = [b],
            z = [z],
            c = [c],
            d = [d],
            e = [e],
            f = [f],
            g = [g],
            h = [h],
            i = [i],
            j = [j],
            k = [k],
            l = [l],
        )
        df2 = DataFrame(
            a2 = [a2],
            b2 = [b2],
            z2 = [z2],
            c2 = [c2],
            d2 = [d2],
            e2 = [e2],
            f2 = [f2],
            g2 = [g2],
            h2 = [h2],
            i2 = [i2],
            j2 = [j2],
            k2 = [k2],
            l2 = [l2],
        )
        cleardf()
        savea(df, "pertubedWalk", k)
        savea(df2, "allocsPertubedWalk", k)

        if cweight == tweight
            terminate = true
        else
            global a2 =
                @ballocated next_weight($G, $cweight, $tweight) evals = 1 samples =
                    1
            global a =
                @belapsed next_weight($G, $cweight, $tweight) evals = 1 samples =
                    1
            cweight = next_weight(G, cweight, tweight)
            R = Rn
            Rn = change_order(Rn, cweight, T)
        end
    end
    return G
end

function standard_step2(
    G::Singular.sideal,
    R::Singular.PolyRing,
    cw::Vector{Int64},
    Rn::Singular.PolyRing,
)
    global z = length(Singular.gens(G))
    global z2 = length(Singular.gens(G))


    global c = @belapsed initials($Rn, gens($G), $cw) evals = 1 samples = 1
    global c2 = @ballocated initials($Rn, gens($G), $cw) evals = 1 samples = 1

    Gw = initials(Rn, gens(G), cw)

    global d = @belapsed Singular.std(
        Singular.Ideal($Rn, $Gw),
        complete_reduction = true,
    ) evals = 1 samples = 1

    global d2 = @ballocated Singular.std(
        Singular.Ideal($Rn, $Gw),
        complete_reduction = true,
    ) evals = 1 samples = 1

    H = Singular.std(Singular.Ideal(Rn, Gw), complete_reduction = true)

    global e2 = @ballocated liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1

    global e = @belapsed liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1

    global f2 = @ballocated lift($G, $R, $H, $Rn) evals = 1 samples = 1
    global f = @belapsed lift($G, $R, $H, $Rn) evals = 1 samples = 1
    #H = liftGW2(G, R, Gw, H, Rn)
    H = lift(G, R, H, Rn)
    global g =
        @belapsed Singular.std($H, complete_reduction = true) evals = 1 samples =
            1
    global g2 =
        @ballocated Singular.std($H, complete_reduction = true) evals = 1 samples =
            1

    return Singular.std(H, complete_reduction = true)
end
###############################################################
#Generic-version of the groebner walk by Fukuda et al. (2007)
###############################################################

function generic_walk(G::Singular.sideal, S::Matrix{Int64}, T::Matrix{Int64})
    R = base_ring(G)
    Rn = change_order(G.base_ring, T)
    global a = @belapsed next_gamma($G, $[0], $S, $T) evals = 1 samples = 1
    global a2 = @ballocated next_gamma($G, $[0], $S, $T) evals = 1 samples = 1

    v = next_gamma(G, [0], S, T)
    Lm = [change_ring(Singular.leading_term(g), Rn) for g in gens(G)]
    G = Singular.Ideal(Rn, [change_ring(x, Rn) for x in gens(G)])

    println("generic_walk results")
    println("Crossed Cones with facetNormal: ")
    while !isempty(v)
        global counter = getCounter() + 1
        global b = v
        global b2 = v

        println(v)
        G, Lm = generic_step(G, Lm, v, T, R)
        df = DataFrame(
            a = [a],
            b = [b],
            z = [z],
            c = [c],
            d = [d],
            e = [e],
            f = [f],
            g = [g],
        )
        df2 = DataFrame(
            a2 = [a2],
            b2 = [b2],
            z2 = [z2],
            c2 = [c2],
            d2 = [d2],
            e2 = [e2],
            f2 = [f2],
            g2 = [g2],
        )
        savea(df2, "allocsGenericWalk")
        savea(df, "genericWalk")
        cleardf()
        global a2 =
            @ballocated next_gamma($G, $Lm, $v, $S, $T) evals = 1 samples = 1

        global a =
            @belapsed next_gamma($G, $Lm, $v, $S, $T) evals = 1 samples = 1
        v = next_gamma(G, Lm, v, S, T)
    end
    return Singular.interreduce(G)
end

function generic_step(
    G::Singular.sideal,
    Lm::Vector{Singular.spoly{L}},
    v::Vector{Int64},
    T::Matrix{Int64},
    R::Singular.PolyRing,
) where {L<:Nemo.RingElem}
    global z = length(Singular.gens(G))


    Rn = Singular.base_ring(G)
    global c = @belapsed facet_initials($G, $Lm, $v) evals = 1 samples = 1
    global c2 = @ballocated facet_initials($G, $Lm, $v) evals = 1 samples = 1

    facet_Generators = facet_initials(G, Lm, v)
    global d = @belapsed Singular.std(
        Singular.Ideal($Rn, $facet_Generators),
        complete_reduction = true,
    ) evals = 1 samples = 1

    global d2 = @ballocated Singular.std(
        Singular.Ideal($Rn, $facet_Generators),
        complete_reduction = true,
    ) evals = 1 samples = 1
    H = Singular.std(
        Singular.Ideal(Rn, facet_Generators),
        complete_reduction = true,
    )
    global e2 = @ballocated lift_generic($G, $Lm, $H) evals = 1 samples = 1

    global e = @belapsed lift_generic($G, $Lm, $H) evals = 1 samples = 1
    H, Lm = lift_generic(G, Lm, H)
    global f = @belapsed interreduce($H, $Lm) evals = 1 samples = 1
    global f2 = @ballocated interreduce($H, $Lm) evals = 1 samples = 1

    G = interreduce(H, Lm)
    G = Singular.Ideal(Rn, G)
    G.isGB = true
    return G, Lm
end


###############################################################
#Pertubed-version of the groebner walk Amrhein et al.
###############################################################
function pertubed_walk(
    G::Singular.sideal,
    S::Matrix{Int64},
    T::Matrix{Int64},
    p::Int64,
)
    k = p
    k2 = p
    df = DataFrame(
        a = ["-"],
        b = ["-"],
        z = ["-"],
        c = ["-"],
        d = ["-"],
        e = ["-"],
        f = ["-"],
        g = ["-"],
        h = ["-"],
        i = ["-"],
        j = ["-"],
        k = [(p, p)],
        l = ["-"],
    )
    df2 = DataFrame(
        a2 = ["-"],
        b2 = ["-"],
        z2 = ["-"],
        c2 = ["-"],
        d2 = ["-"],
        e2 = ["-"],
        f2 = ["-"],
        g2 = ["-"],
        h2 = ["-"],
        i2 = ["-"],
        j2 = ["-"],
        k2 = [(p, p)],
        l2 = ["-"],
    )
    savea(df2, "allocsPertubedWalk", k)
    savea(df, "pertubedWalk", k)
    #cweight = pertubed_vector(G, S, p)
    cweight = S[1, :]
    terminate = false
    println("pertubed_walk results")
    println("Crossed Cones in: ")

    while !terminate
        global h = @belapsed pertubed_vector($G, $T, $p) evals = 1 samples = 1
        global h2 =
            @ballocated pertubed_vector($G, $T, $p) evals = 1 samples = 1

        tweight = pertubed_vector(G, T, p)
        G = standard_walk2(G, S, T, cweight, tweight, k)

        if inCone(G, T, tweight)
            global i = @belapsed inCone($G, $T, $tweight) evals = 1 samples = 1
            global i2 =
                @ballocated inCone($G, $T, $tweight) evals = 1 samples = 1

            terminate = true
        else
            if p == 1
                R = change_order(G.base_ring, T)
                G = Singular.Ideal(R, [change_ring(x, R) for x in gens(G)])
                global j =
                    @belapsed Singular.std($G, complete_reduction = true) evals =
                        1 samples = 1
                global j2 =
                    @ballocated Singular.std($G, complete_reduction = true) evals =
                        1 samples = 1

                G = Singular.std(G, complete_reduction = true)
                terminate = true
            end
            p = p - 1
            cweight = tweight
        end
        df = DataFrame(
            a = [a],
            b = [b],
            z = [z],
            c = [c],
            d = [d],
            e = [e],
            f = [f],
            g = [g],
            h = [h],
            i = [i],
            j = [j],
            k = [k],
            l = [l],
        )
        df2 = DataFrame(
            a2 = [a2],
            b2 = [b2],
            z2 = [z2],
            c2 = [c2],
            d2 = [d2],
            e2 = [e2],
            f2 = [f2],
            g2 = [g2],
            h2 = [h2],
            i2 = [i2],
            j2 = [j2],
            k2 = [k2],
            l2 = [l2],
        )
        savea(df, "pertubedWalk", k)
        savea(df2, "allocsPertubedWalk", k)
        cleardf()

    end
    return G
end

###############################################################
#fractal-walk by Amrhein et al.
#Inlcuding:
#fractal_walk -> standard-version
#fractal_walk2 -> checks if the starting weight is in the inner of a cone.
#fractal_walk3 -> fractal walk expecially for conversion to the lexikographic orderig.
#                 checks if the starting weight is in the inner of a cone.
###############################################################

########################################
#Counter for the steps in the fractal_walk
########################################
counterFr = 0
function deleteCounterFr()
    global counterFr
    temp = counterFr
    counterFr = 0
    return temp
end
function getCounterFr()
    global counterFr
    return counterFr
end
function raiseCounterFr()
    global counterFr = getCounterFr() + 1
end
PertVecs = []
sigma = []

function fractal_walk(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
)
    global PertVecs = [pertubed_vector(G, T, i) for i = 1:nvars(base_ring(G))]
    println(PertVecs)
    println("FractalWalk_standard results")
    println("Crossed Cones in: ")
    Gb = fractal_recursiv(G, S, T, PertVecs, 1)
    println("Cones crossed: ", deleteCounterFr())
    return Gb
end

function fractal_recursiv(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
    PertVecs::Vector{Vector{Int64}},
    p::Int64,
)
    R = base_ring(G)
    terminate = false
    G.isGB = true
    w = S.w
    h = "-"
    i = "-"
    h2 = "-"
    i2 = "-"
    while !terminate
        a = @belapsed nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1
        a2 = @ballocated nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1

        t = nextT(G, w, PertVecs[p])
        if (t == [0])
            if inCone(G, T, PertVecs[p])
                h = @belapsed inCone($G, $T, PertVecs[$p]) evals = 1 samples = 1
                h2 =
                    @ballocated inCone($G, $T, PertVecs[$p]) evals = 1 samples =
                        1

                return G
            else
                i2 =
                    @ballocated [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1

                i =
                    @belapsed [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1
                global PertVecs = [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                println(PertVecs)
                continue
            end
        end
        w = w + t * (PertVecs[p] - w)
        w = convert_bounding_vector(w)
        b = w
        b2 = w
        T.w = w
        Rn = change_order(R, T)
         z = length(Singular.gens(G))
         z2 = length(Singular.gens(G))

        c2 = @ballocated initials($R, Singular.gens($G), $w) evals = 1 samples =
            1

        c = @belapsed initials($R, Singular.gens($G), $w) evals = 1 samples = 1
        Gw = initials(R, Singular.gens(G), w)
        if p == nvars(R)
            d = @belapsed Singular.std(
                Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                complete_reduction = true,
            ) evals = 1 samples = 1
            d2 = @ballocated Singular.std(
                Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                complete_reduction = true,
            ) evals = 1 samples = 1
            H = Singular.std(
                Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                complete_reduction = true,
            )
            println(w, " in depth", p)
            raiseCounterFr()
        else
            println("up in: ", p, " with: ", w)
            d = "rec"
            d2 = "rec"

            H = fractal_recursiv(
                Singular.Ideal(R, [x for x in Gw]),
                S,
                T,
                PertVecs,
                p + 1,
            )
        end
        e2 = @ballocated liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1
        e = @belapsed liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1
        f = @belapsed lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1
        f2 = @ballocated lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1

        #H = liftGW2(G, R, Gw, H, Rn)
        H = lift_fractal_walk(G, R, H, Rn)
        g2 =
            @ballocated Singular.std($H, complete_reduction = true) evals = 1 samples =
                1

        g =
            @belapsed Singular.std($H, complete_reduction = true) evals = 1 samples =
                1
        G = Singular.std(H, complete_reduction = true)
        R = Rn
        j = p
        j2 = p
        df2 = DataFrame(
            a2 = [a2],
            b2 = [b2],
            z2 = [z2],
            c2 = [c2],
            d2 = [d2],
            e2 = [e2],
            f2 = [f2],
            g2 = [g2],
            h2 = [h2],
            i2 = [i2],
            j2 = [j2],
            k2 = [k2],
        )

        df = DataFrame(
            a = [a],
            b = [b],
            z = [z],
            c = [c],
            d = [d],
            e = [e],
            f = [f],
            g = [g],
            h = [h],
            i = [i],
            j = [j],
            k = [k],
        )
        savea(df, "fractalWalk")
        savea(df2, "allocsFractalWalk")
        cleardf()
    end
    return G
end

cwPert = []
firstStepMode = false
function cwpert(p::Int64)
    cwPert[p]
end

function fractal_walk_start_order(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
)
    global PertVecs =
        [pertubed_vector(G, T, i) for i = 1:nvars(Singular.base_ring(G))]
    global sigma = S.w
    println("fractal_walk_withStartorder results")
    println("Crossed Cones in: ")
    Gb = fractal_walk_recursiv_startorder(G, S, T, PertVecs, 1)
    println("Cones crossed: ", deleteCounterFr())
    return Gb
end

function fractal_walk_recursiv_startorder(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
    PertVecs::Vector{Vector{Int64}},
    p::Int64,
)
    R = Singular.base_ring(G)
    terminate = false
    G.isGB = true
    if (p == 1)
        if !isMonomial(initials(R, Singular.gens(G), S.w))
            global cwPert = [pertubed_vector(G, S, S.w, i) for i = 1:nvars(R)]
            global firstStepMode = true
        end
    end
    if firstStepMode
        w = cwPert[p]
    else
        w = S.w
    end
    h = "-"
    i = "-"
    h2 = "-"
    i2 = "-"
    while !terminate
        a = @belapsed nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1
        a2 = @ballocated nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1

        t = nextT(G, w, PertVecs[p])
        if t == [0]
            if inCone(G, T, PertVecs[p])
                h = @belapsed inCone($G, $T, PertVecs[$p]) evals = 1 samples = 1
                h2 =
                    @ballocated inCone($G, $T, PertVecs[$p]) evals = 1 samples =
                        1

                return G
            else
                i2 =
                    @ballocated [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1

                i =
                    @belapsed [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1
                global PertVecs = [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                println(PertVecs)

                continue
            end
        end
        w = w + t * (PertVecs[p] - w)
        w = convert_bounding_vector(w)
        T.w = w
        b = w
        b2 = w

        Rn = change_order(R, T)
         z = length(Singular.gens(G))
         z2 = length(Singular.gens(G))

        c2 = @ballocated initials($R, Singular.gens($G), $w) evals = 1 samples =
            1

        c = @belapsed initials($R, Singular.gens($G), $w) evals = 1 samples = 1
        Gw = initials(R, gens(G), w)
        if p == Singular.nvars(R)
            d = @belapsed Singular.std(
                Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                complete_reduction = true,
            ) evals = 1 samples = 1
            d2 = @ballocated Singular.std(
                Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                complete_reduction = true,
            ) evals = 1 samples = 1
            H = Singular.std(
                Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                complete_reduction = true,
            )
            println(w, " in depth", p)
            raiseCounterFr()
        else
            println("up in: ", p, " with: ", w)
            d = "rec"
            d2 = "rec"


            H = fractal_walk_recursiv_startorder(
                Singular.Ideal(R, [x for x in Gw]),
                S,
                T,
                PertVecs,
                p + 1,
            )
            global firstStepMode = false
        end
        e2 = @ballocated liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1

        e = @belapsed liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1
        f = @belapsed lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1
        f2 = @ballocated lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1

        H = liftGW2(G, R, Gw, H, Rn)
        #H = lift_fractal_walk(G, R, H, Rn)
        g2 =
            @ballocated Singular.std($H, complete_reduction = true) evals = 1 samples =
                1

        g =
            @belapsed Singular.std($H, complete_reduction = true) evals = 1 samples =
                1
        j = p
        j2 = p

        G = Singular.std(H, complete_reduction = true)
        df = DataFrame(
            a = [a],
            b = [b],
            z = [z],
            c = [c],
            d = [d],
            e = [e],
            f = [f],
            g = [g],
            h = [h],
            i = [i],
            j = [j],
            k = [k],
        )
        df2 = DataFrame(
            a2 = [a2],
            b2 = [b2],
            z2 = [z2],
            c2 = [c2],
            d2 = [d2],
            e2 = [e2],
            f2 = [f2],
            g2 = [g2],
            h2 = [h2],
            i2 = [i2],
            j2 = [j2],
            k2 = [k2],
        )
        savea(df2, "allocsFractalWalkstartorder")
        savea(df, "fractalWalkstartorder")
        cleardf()

        R = Rn
    end
    return G
end
function fractal_walk_lex(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
)
    global PertVecs = [pertubed_vector(G, T, i) for i = 1:nvars(base_ring(G))]
    println("fractal_walk_lex results")
    println("Crossed Cones in: ")
    Gb = fractal_walk_recursive_lex(G, S, T, PertVecs, 1)
    println("Cones crossed: ", deleteCounterFr())
    return Gb
end

function fractal_walk_recursive_lex(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
    PertVecs::Vector{Vector{Int64}},
    p::Int64,
)
    R = Singular.base_ring(G)
    terminate = false
    G.isGB = true
    w = S.w
    h = "-"
    i = "-"
    h2 = "-"
    i2 = "-"
    while !terminate
        a = @belapsed nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1
        a2 = @ballocated nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1

        t = nextT(G, w, PertVecs[p])
        if t == [0]
            if inCone(G, T, PertVecs[p])
                h = @belapsed inCone($G, $T, PertVecs[$p]) evals = 1 samples = 1
                h2 =
                    @ballocated inCone($G, $T, PertVecs[$p]) evals = 1 samples =
                        1

                return G
            else
                i =
                    @belapsed [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1
                i2 =
                    @ballocated [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1
                global PertVecs =
                    [pertubed_vector(G, T, i) for i = 1:Singular.nvars(R)]
                println(PertVecs)
                continue
            end
        end
        if t == 1 && p == 1
            println("up in: ", p, " with: ", w)
            return fractal_walk_recursive_lex(G, S, T, PertVecs, p + 1)
        else
            w = w + t * (PertVecs[p] - w)
            w = convert_bounding_vector(w)
            T.w = w
            b = w
            b2 = w

            Rn = change_order(R, T)
            z = length(Singular.gens(G))
            z2 = length(Singular.gens(G))

            c2 =
                @ballocated initials($R, Singular.gens($G), $w) evals = 1 samples =
                    1

            c =
                @belapsed initials($R, Singular.gens($G), $w) evals = 1 samples =
                    1
            Gw = initials(R, Singular.gens(G), w)
            if p == Singular.nvars(R)
                d = @belapsed Singular.std(
                    Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                    complete_reduction = true,
                ) evals = 1 samples = 1
                d2 = @ballocated Singular.std(
                    Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                    complete_reduction = true,
                ) evals = 1 samples = 1

                H = Singular.std(
                    Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                    complete_reduction = true,
                )
                println(w, " in depth", p)
                raiseCounterFr()
            else
                println("up in: ", p, " with: ", w)
                d = "rec"
                d2 = "rec"


                H = fractal_walk_recursive_lex(
                    Singular.Ideal(R, [x for x in Gw]),
                    S,
                    T,
                    PertVecs,
                    p + 1,
                )
                global firstStepMode = false
            end
        end
        e2 = @ballocated liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1
        e = @belapsed liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1
        f = @belapsed lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1
        f2 = @ballocated lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1

        H = liftGW2(G, R, Gw, H, Rn)
        #H = lift_fractal_walk(G, R, H, Rn)
        g =
            @belapsed Singular.std($H, complete_reduction = true) evals = 1 samples =
                1
        g2 =
            @ballocated Singular.std($H, complete_reduction = true) evals = 1 samples =
                1

        j = p
        j2 = p

        G = Singular.std(H, complete_reduction = true)
        df2 = DataFrame(
            a2 = [a2],
            b2 = [b2],
            z2 = [z2],
            c2 = [c2],
            d2 = [d2],
            e2 = [e2],
            f2 = [f2],
            g2 = [g2],
            h2 = [h2],
            i2 = [i2],
            j2 = [j2],
            k2 = [k2],
        )
        df = DataFrame(
            a = [a],
            b = [b],
            z = [z],
            c = [c],
            d = [d],
            e = [e],
            f = [f],
            g = [g],
            h = [h],
            i = [i],
            j = [j],
            k = [k],
        )
        savea(df, "fractalWalklex")
        savea(df2, "allocsFractalWalklex")
        cleardf()
        R = Rn
    end
    return G
end
function fractal_walk_look_ahead(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
)
    println("fractal_walk_look_ahead results")
    println("Crossed Cones in: ")
    global PertVecs = [pertubed_vector(G, T, i) for i = 1:nvars(base_ring(G))]
    Gb = fractal_walk_look_ahead_recursiv(G, S, T, PertVecs, 1)
    println("Cones crossed: ", deleteCounterFr())
    return Gb
end

function fractal_walk_look_ahead_recursiv(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
    PertVecs::Vector{Vector{Int64}},
    p::Int64,
)
    R = Singular.base_ring(G)
    terminate = false
    G.isGB = true
    w = S.w
    h = "-"
    i = "-"
    h2 = "-"
    i2 = "-"
    while !terminate
        a = @belapsed nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1
        a2 = @ballocated nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1

        t = nextT(G, w, PertVecs[p])
        if t == [0]
            if inCone(G, T, PertVecs[p])
                h = @belapsed inCone($G, $T, PertVecs[$p]) evals = 1 samples = 1
                h2 =
                    @ballocated inCone($G, $T, PertVecs[$p]) evals = 1 samples =
                        1

                return G
            else
                i =
                    @belapsed [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1
                i2 =
                    @ballocated [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1

                global PertVecs = [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                continue
            end
        end
        w = w + t * (PertVecs[p] - w)
        w = convert_bounding_vector(w)
        T.w = w
         b = w
         b2 = w

        Rn = change_order(R, T)
        z = length(Singular.gens(G))
        z2 = length(Singular.gens(G))
        c2 = @ballocated initials($R, Singular.gens($G), $w) evals = 1 samples =
            1

        c = @belapsed initials($R, Singular.gens($G), $w) evals = 1 samples = 1
        Gw = initials(R, Singular.gens(G), w)
        if (p == Singular.nvars(R) || isbinomial(Gw))
            d = @belapsed Singular.std(
                Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                complete_reduction = true,
            ) evals = 1 samples = 1
            d2 = @ballocated Singular.std(
                Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                complete_reduction = true,
            ) evals = 1 samples = 1
            H = Singular.std(
                Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                complete_reduction = true,
            )
            println(w, " in depth", p)
            raiseCounterFr()
        else
            println("up in: ", p, " with: ", w)
            d = "rec"
            d2 = "rec"

            H = fractal_walk_look_ahead_recursiv(
                Singular.Ideal(R, Gw),
                S,
                T,
                PertVecs,
                p + 1,
            )
        end
        e2 = @ballocated liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1

        e = @belapsed liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1
        f = @belapsed lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1
        f2 = @ballocated lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1

        H = liftGW2(G, R, Gw, H, Rn)
        #H = lift_fractal_walk(G, R H, Rn)
        g =
            @belapsed Singular.std($H, complete_reduction = true) evals = 1 samples =
                1
        g2 =
            @ballocated Singular.std($H, complete_reduction = true) evals = 1 samples =
                1

        j = p
        j2 = p

        G = Singular.std(H, complete_reduction = true)
        df2 = DataFrame(
            a2 = [a2],
            b2 = [b2],
            z2 = [z2],
            c2 = [c2],
            d2 = [d2],
            e2 = [e2],
            f2 = [f2],
            g2 = [g2],
            h2 = [h2],
            i2 = [i2],
            j2 = [j2],
            k2 = [k2],
        )
        df = DataFrame(
            a = [a],
            b = [b],
            z = [z],
            c = [c],
            d = [d],
            e = [e],
            f = [f],
            g = [g],
            h = [h],
            i = [i],
            j = [j],
            k = [k],
        )
        savea(df, "fractalWalklookahead")
        savea(df2, "allocsFractalWalklookahead")
        cleardf()

        R = Rn
    end
    return G
end




function fractal_walk_combined(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
)
    global PertVecs =
        [pertubed_vector(G, T, i) for i = 1:nvars(Singular.base_ring(G))]
    println("fractal_walk_combined results")
    println("Crossed Cones in: ")
    Gb = fractal_walk_combined(G, S, T, PertVecs, 1)
    println("Cones crossed: ", deleteCounterFr())
    return Gb
end

function fractal_walk_combined(
    G::Singular.sideal,
    S::MonomialOrder{Matrix{Int64},Vector{Int64}},
    T::MonomialOrder{Matrix{Int64},Vector{Int64}},
    PertVecs::Vector{Vector{Int64}},
    p::Int64,
)
    R = Singular.base_ring(G)
    terminate = false
    G.isGB = true
    if (p == 1)
        if !isMonomial(initials(R, Singular.gens(G), S.w))
            global cwPert = [pertubed_vector(G, S, S.w, i) for i = 1:nvars(R)]
            global firstStepMode = true
        end
    end
    if firstStepMode
        w = cwPert[p]
    else
        w = S.w
    end
    h = "-"
    i = "-"
    h2 = "-"
    i2 = "-"
    while !terminate
        a = @belapsed nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1
        a2 = @ballocated nextT($G, $w, PertVecs[$p]) evals = 1 samples = 1

        t = nextT(G, w, PertVecs[p])
        if t == [0]
            if inCone(G, T, PertVecs[p])
                h = @belapsed inCone($G, $T, PertVecs[$p]) evals = 1 samples = 1
                h2 =
                    @ballocated inCone($G, $T, PertVecs[$p]) evals = 1 samples =
                        1
                println(PertVecs[p], " in depth", p)
                return G
            else
                i2 =
                    @ballocated [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1

                i =
                    @belapsed [pertubed_vector($G, $T, i) for i = 1:nvars($R)] evals = 1 samples = 1
                global PertVecs = [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                continue
            end
        end
        if t == 1 && p == 1
            return fractal_walk_combined(G, S, T, PertVecs, p + 1)
        else
            w = w + t * (PertVecs[p] - w)
            w = convert_bounding_vector(w)
            T.w = w
            b = w
            b2 = w

            Rn = change_order(R, T)
             z = length(Singular.gens(G))
             z2 = length(Singular.gens(G))

            c2 =
                @ballocated initials($R, Singular.gens($G), $w) evals = 1 samples =
                    1

            c =
                @belapsed initials($R, Singular.gens($G), $w) evals = 1 samples =
                    1
            Gw = initials(R, gens(G), w)
            if (p == Singular.nvars(R) || isbinomial(Gw))
                d = @belapsed Singular.std(
                    Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                    complete_reduction = true,
                ) evals = 1 samples = 1
                d2 = @ballocated Singular.std(
                    Singular.Ideal($Rn, [change_ring(x, $Rn) for x in $Gw]),
                    complete_reduction = true,
                ) evals = 1 samples = 1
                H = Singular.std(
                    Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                    complete_reduction = true,
                )
                println(w, " in depth", p)
                raiseCounterFr()
            else
                println("up in: ", p, " with: ", w)
                d = "rec"
                d2 = "rec"


                H = fractal_walk_combined(
                    Singular.Ideal(R, [x for x in Gw]),
                    S,
                    T,
                    PertVecs,
                    p + 1,
                )
                global firstStepMode = false
            end
        end
        e = @belapsed liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1
        e2 = @ballocated liftGW2($G, $R, $Gw, $H, $Rn) evals = 1 samples = 1
        f2 = @ballocated lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1
        f = @belapsed lift_fractal_walk($G, $R, $H, $Rn) evals = 1 samples = 1
        H = liftGW2(G, R, Gw, H, Rn)
        #H = lift_fractal_walk(G, R, H, Rn)
        g2 =
            @ballocated Singular.std($H, complete_reduction = true) evals = 1 samples =
                1
        g =
            @belapsed Singular.std($H, complete_reduction = true) evals = 1 samples =
                1
        j = p
        j2 = p

        G = Singular.std(H, complete_reduction = true)
        df = DataFrame(
            a = [a],
            b = [b],
            z = [z],
            c = [c],
            d = [d],
            e = [e],
            f = [f],
            g = [g],
            h = [h],
            i = [i],
            j = [j],
            k = [k],
        )
        df2 = DataFrame(
            a2 = [a2],
            b2 = [b2],
            z2 = [z2],
            c2 = [c2],
            d2 = [d2],
            e2 = [e2],
            f2 = [f2],
            g2 = [g2],
            h2 = [h2],
            i2 = [i2],
            j2 = [j2],
            k2 = [k2],
        )
        savea(df, "fractalWalkcombined")
        savea(df2, "allocsFractalWalkcombined")
        cleardf()

        R = Rn
    end
    return G
end

###############################################################
#Tran-version of the groebner walk by Tran (2002)
###############################################################

function tran_walk(G::Singular.sideal, S::Matrix{Int64}, T::Matrix{Int64})
    cweight = S[1, :]
    tweight = T[1, :]
    println("tran_walk results")
    println("Crossed Cones in: ")
    R = base_ring(G)
    if !isMonomial(initials(R, Singular.gens(G), cweight))
        cweight = pertubed_vector(G, S, nvars(R))
    end

    terminate = false
    while !terminate
        global a2 =
            @ballocated next_weight($G, $cweight, $tweight) evals = 1 samples =
                1

        global a =
            @belapsed next_weight($G, $cweight, $tweight) evals = 1 samples = 1
        w = next_weight(G, cweight, tweight)
        if tryparse(Int32, string(w)) == nothing
            println("w bigger than int32")
            return G
        end
        Rn = change_order(R, w, T)
        if w == tweight
            if inCone(G, T, cweight)
                global i2 =
                    @ballocated inCone($G, $T, $cweight) evals = 1 samples = 1

                global i =
                    @belapsed inCone($G, $T, $cweight) evals = 1 samples = 1
                return G
            else
                if inSeveralCones(initials(base_ring(G), gens(G), w))
                    global j = @belapsed inSeveralCones(
                        initials(base_ring($G), gens($G), $w),
                    ) evals = 1 samples = 1
                    global j2 = @ballocated inSeveralCones(
                        initials(base_ring($G), gens($G), $w),
                    ) evals = 1 samples = 1
                    global h2 =
                        @ballocated representation_vector($G, $T) evals = 1 samples =
                            1
                    global h =
                        @belapsed representation_vector($G, $T) evals = 1 samples =
                            1
                    tweight = representation_vector(G, T)
                    continue
                end
            end
        end
        G = standard_step2(G, R, w, Rn)
        global counter = getCounter() + 1
        println(w)
        global b = w
        global b2 = w

        R = Rn
        cweight = w
        df = DataFrame(
            a = [a],
            b = [b],
            z = [z],
            c = [c],
            d = [d],
            e = [e],
            f = [f],
            g = [g],
            h = [h],
            i = [i],
            j = [j],
            k = [k],
        )
        df2 = DataFrame(
            a2 = [a2],
            b2 = [b2],
            z2 = [z2],
            c2 = [c2],
            d2 = [d2],
            e2 = [e2],
            f2 = [f2],
            g2 = [g2],
            h2 = [h2],
            i2 = [i2],
            j2 = [j2],
            k2 = [k2],
        )
        savea(df, "tranWalk")
        savea(df2, "allocsTranWalk")
        cleardf()
    end
end
