include("Helper.jl")
include("GroebnerWalkUtilitys.jl")
include("FractalWalkUtilitys.jl")
include("GenericWalkUtilitys.jl")
include("TranWalkUtilitys.jl")


export groebnerwalk

###############################################################
#Implementation of the gröbner walk.
###############################################################

#For Counting Steps in the GroebnerWalk
counter = 0
function getCounter()
    global counter
    temp = counter
    counter = 0
    return temp
end
#=
@doc Markdown.doc"""
function groebnerwalk(
G::Singular.sideal,
startOrder::Symbol = :degrevlex,
targetOrder::Symbol = :lex,
walktype::Symbol = :standard,
pertubationDegree::Int = 2,
)
Given an Ideal $G$ generated by a reduced Groebner Basis w.r.t. the monomial ordering startOrder this function
returns a reduced Groebner Basis w.r.t. the monomial ordering targetOrder by converting it using the Groebner Walk.
The Groebner Walk is proposed by Collart et al. (1993)
One can choose a strategy of:
Standard Walk (:standard) computes the Walk like it´s presented in Cox et al. (2005).
Generic Walk (:generic) computes the Walk like it´s presented in Fukuda et al. (2006).
Pertubed Walk (:pertubed, with $p$ = Pertubation degree) computes the Walk like it´s presented in Amrhein et al. (1997).
Tran´s Walk (:tran) computes the Walk like it´s presented in Tran (2000).
Fractal Walk (Combined) computes the Walk like it´s presented in Amrhein & Gloor (1998) with all of the following extensions. This Version uses the Buchberger Algorithm to skip weightvectors with entrys bigger than Int32.
Fractal Walk (:fractal) computes the Walk like it´s presented in Amrhein & Gloor (1998). Pertubes only the target vector.
Fractal Walk (:fractal_start_order) computes the Walk like it´s presented in Amrhein & Gloor (1998). Pertubes both, the start und the target vector.
Fractal Walk (:fractal_lex) computes the Walk like it´s presented in Amrhein & Gloor (1998) in the special case that the $targetOrder$ represents the lex ordering. Pertubes only the target vector.
Fractal Walk (:factal_look_ahead) computes the Walk like it´spresented in Amrhein & Gloor (1998). This Version uses the buchberger algorithm under certain circumstances before reaching the maximal pertubation depth.

#Arguments
*`I::Singular.sideal`: Gröbnerbasis to compute the Gröbnerbasis w.r.t. the traget-ordering.
*`startOrder::Symbol`: The ordering w.r.t. the Gröbnerbasis I. Default is :degrevlex
*`targetOrder::Symbol`: The ordering we want to compute a Gröbnerbasis for. Default is :lex.
*`walktype::Symbol`: Strategy of the Gröbnerwalk to be used. There are the strategies:
    - `standard`: Standard Walk (default),
    - `pertubed`: Pertubed Walk,
    - `tran`: Tran´s Walk,
    - `generic`: Generic Walk,
    - `fractal`: Standard-Version of the Fractal Walk,
    - `fractalcombined`: Combined Fractal Walk with handling of a weight vector w.r.t. the start ordering and look-ahead computation for lexicographic target-ordering,
    - `fractal_look_ahead`:Fractal Walk with look-ahead computation.
*`pertubationDegree::Int`: Pertubationdegree for the pertubed Walk. Default is 2.
"""=#
function groebnerwalk(
    G::Singular.sideal,
    startOrder::Symbol = :degrevlex,
    targetOrder::Symbol = :lex,
    walktype::Symbol = :standard,
    pertubationDegree::Int = 2,
)
    R = change_order(
        base_ring(G),
        ordering_as_matrix(startOrder, nvars(base_ring(G))),
    )
    Gb = std(
        Singular.Ideal(R, [change_ring(x, R) for x in gens(G)]),
        complete_reduction = true,
    )

    return groebnerwalk(
        Gb,
        ordering_as_matrix(startOrder, nvars(R)),
        ordering_as_matrix(targetOrder, nvars(R)),
        walktype,
        pertubationDegree,
    )
end

#=
@doc Markdown.doc"""
function groebnerwalk(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    grwalktype::Symbol = :standard,
    p::Int = 0,
)
Given an Ideal $G$ generated by a reduced Groebner Basis w.r.t. the monomial ordering $S$ this function
returns a reduced Groebner Basis w.r.t. the monomial ordering $T$ by converting it using the Groebner Walk.
The Groebner Walk is proposed by Collart et al. (1993)
One can choose a strategy of:
Standard Walk (:standard) computes the Walk like it´s presented in Cox et al. (2005).
Generic Walk (:generic) computes the Walk like it´s presented in Fukuda et al. (2006).
Pertubed Walk (:pertubed, with $p$ = Pertubation degree) computes the Walk like it´s presented in Amrhein et al. (1997).
Tran´s Walk (:tran) computes the Walk like it´s presented in Tran (2000).
Fractal Walk (:fractal) computes the Walk like it´s presented in Amrhein & Gloor (1998). Pertubes only the target vector.
Fractal Walk (:fractal_start_order) computes the Walk like it´s presented in Amrhein & Gloor (1998). Pertubes both, the start und the target vector.
Fractal Walk (:fractal_lex) computes the Walk like it´s presented in Amrhein & Gloor (1998) in the special case that $T$ represents the lex ordering. Pertubes only the target vector.
Fractal Walk (:factal_look_ahead) computes the Walk like it´spresented in Amrhein & Gloor (1998). This Version uses the buchberger algorithm under certain circumstances before reaching the maximal pertubation depth.

#Arguments
*`I::Singular.sideal`: Gröbnerbasis to compute the Gröbnerbasis w.r.t. the traget-ordering.
*`S::Matrix{Int}`: The start ordering w.r.t. the Gröbnerbasis $I$. Note that $S$ has to be a nxn-matrix with rank(S)=n.
*`T::Matrix{Int}`: The target ordering we want to compute a Gröbnerbasis for. Note that $T$ has to be a nxn-matrix with rank(T)=n.
*`grwalktype::Symbol`: Strategy of the Gröbnerwalk to be used. There are the strategies:
    - `standard`: Standard Walk (default),
    - `pertubed`: Pertubed Walk,
    - `tran`: Tran´s Walk,
    - `generic`: Generic Walk,
    - `fractal`: Standard-Version of the Fractal Walk,
    - `fractalcombined`: Combined Fractal Walk with handling of start-ordering and look-ahead computation for lexicographic target-ordering,
    - `fractal_look_ahead`:Fractal Walk with look-ahead computation.
*`p::Int`: Pertubationdegree for the pertubed Walk. Default is 2.
"""=#
function groebnerwalk(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    walktype::Symbol = :standard,
    p::Int = 2,
)
    if walktype == :standard
        walk = (x, y, z) -> standard_walk(x, y, z)
    elseif walktype == :generic
        walk = (x, y, z) -> generic_walk(x, y, z)
        #    elseif grwalktype == :pgeneric
        #        walk = (x,y,z) -> pgeneric_walk(x,y,z,p)
    elseif walktype == :pertubed
        walk = (x, y, z) -> pertubed_walk(x, y, z, p)
    elseif walktype == :fractal
        walk = (x, y, z) -> fractal_walk(x, y, z)
    elseif walktype == :fractal_start_order
        walk = (x, y, z) -> fractal_walk_start_order(x, y, z)
    elseif walktype == :fractal_lex
        walk = (x, y, z) -> fractal_walk_lex(x, y, z)
    elseif walktype == :fractal_look_ahead
        walk = (x, y, z) -> fractal_walk_look_ahead(x, y, z)
    elseif walktype == :tran
        walk = (x, y, z) -> tran_walk(x, y, z)
    elseif walktype == :fractal_combined
        walk = (x, y, z) -> fractal_walk_combined(x, y, z)
    end
    !check_ordering_M(S, T, G) && throw(
        error(
            "The matrices representing the Ordering have to be nxn-matrices with full rank.",
        ),
    )

    R = base_ring(G)
    I = Singular.Ideal(R, [R(x) for x in gens(G)])

    Gb = walk(I, S, T)

    S = change_order(R, T)
    return Singular.Ideal(S, [change_ring(gen, S) for gen in gens(Gb)])
end


###############################################################
#Implementation of the standard walk.
###############################################################

function standard_walk(G::Singular.sideal, S::Matrix{Int}, T::Matrix{Int})
    println("standard_walk results")
    println("Crossed Cones in: ")
    Gb = standard_walk(G, S, T, S[1, :], T[1, :])
    println("Cones crossed: ", getCounter())
    return Gb
end

function standard_walk(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    currweight::Vector{Int},
    tarweight::Vector{Int},
)
    terminate = false
    while !terminate
        G = standard_step(G, currweight, T)
        println(currweight)
        global counter = getCounter() + 1
        if currweight == tarweight
            terminate = true
        else
            currweight = next_weight(G, currweight, tarweight)
        end
    end
    return G
end

function standard_step(G::Singular.sideal, w::Vector{Int}, T::Matrix{Int})
    R = base_ring(G)
    Rn = 0
    Gw = 0

    #check if no entry of w is bigger than In32. If it´s bigger multiply it by 0.1 and round.
    if !checkInt32(w)
        Gw = initials(R, gens(G), w)
        w, b = truncw(G, w, Gw)
        if !b
            throw(error("Some entrys of the intermediate weight-vector $w are bigger than int32"))
        end
        Rn = change_order(R, w, T)
        Gw = [change_ring(x, Rn) for x in Gw]
    else
        Rn = change_order(R, w, T)
        Gw = initials(Rn, gens(G), w)
    end
    H = Singular.std(Singular.Ideal(Rn, Gw), complete_reduction = true)
    #H = liftGW2(G, R, Gw, H, Rn)
    H = lift(G, R, H, Rn)
    return interreduce_walk(H)
end

###############################################################
#Generic-version of the groebner walk by Fukuda et al. (2007)
###############################################################

function generic_walk(G::Singular.sideal, S::Matrix{Int}, T::Matrix{Int})
    R = base_ring(G)
    Rn = change_order(G.base_ring, T)
    Lm = [change_ring(Singular.leading_term(g), Rn) for g in gens(G)]
    G = [change_ring(x, Rn) for x in gens(G)]
    v = next_gamma(G, Lm, [0], S, T)

    println("generic_walk results")
    println("Crossed Cones with facetNormal: ")
    while !isempty(v)
        global counter = getCounter() + 1
        println(v)
        G, Lm = generic_step(G, Lm, v, Rn)
        v = next_gamma(G, Lm, v, S, T)
    end
    G = Singular.Ideal(Rn, G)
    G.isGB = true
    println("Cones crossed: ", getCounter())
    return Singular.interreduce(G)
end

function generic_step(
    G::Vector{Singular.spoly{L}},
    Lm::Vector{Singular.spoly{L}},
    v::Vector{Int},
    Rn::Singular.PolyRing,
) where {L<:Nemo.RingElem}

    facet_Generators = facet_initials(G, Lm, v)
    H = Singular.std(
        Singular.Ideal(Rn, facet_Generators),
        complete_reduction = true,
    )
    H, Lm = lift_generic(G, Lm, H)
    G = interreduce(H, Lm)
    return G, Lm
end


###############################################################
#Pertubed-version of the groebner walk by Amrhein et al. (1997)
###############################################################
function pertubed_walk(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    p::Int,
)
    currweight = pertubed_vector(G, S, p)
    terminate = false
    println("pertubed_walk results")
    println("Crossed Cones in: ")
    while !terminate
        tarweight = pertubed_vector(G, T, p)
        Tn = add_weight_vector(tarweight, T)
        G = standard_walk(G, S, Tn, currweight, tarweight)
        if same_cone(G, T)
            terminate = true
        else
            p = p - 1
            currweight = tarweight
            S = Tn
        end
    end
    println("Cones crossed: ", getCounter())

    return G
end

###############################################################
#fractal walk
###############################################################

##########################################
#Counter for the steps in the fractal_walk
##########################################
counterFr = 0
function deleteCounterFr()
    global counterFr
    temp = counterFr
    counterFr = 0
    return temp
end
function getCounterFr()
    global counterFr
    return counterFr
end
function raiseCounterFr()
    global counterFr = getCounterFr() + 1
end

##########################################
#global weightvectors
##########################################
pTargetWeights = []
pStartWeights = []
firstStepMode = false

function fractal_walk(G::Singular.sideal, S::Matrix{Int}, T::Matrix{Int})
    global pTargetWeights =
        [pertubed_vector(G, T, i) for i = 1:nvars(base_ring(G))]
    println(pTargetWeights)
    println("FractalWalk_standard results")
    println("Crossed Cones in: ")
    Gb = fractal_recursiv(G, S, T, S[1, :], pTargetWeights, 1)
    println("Cones crossed: ", deleteCounterFr())
    return Gb
end

function fractal_recursiv(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    currweight::Vector{Int},
    pTargetWeights::Vector{Vector{Int}},
    p::Int,
)
    R = base_ring(G)
    terminate = false
    G.isGB = true
    w = currweight

    while !terminate
        t = next_weightfr(G, w, pTargetWeights[p])

        # Handling the final step in the current depth.
        if t == 1 && p != 1
            if same_cone(G, T)
                println(currweight, " in Cone", p)
                if !inCone(G, T,pTargetWeights, p)
                    global pTargetWeights =
                        [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                    println("not in Cone ", pTargetWeights)
                end
                return G
            end
        elseif t == [0]
            if p == 1 || inCone(G, T,pTargetWeights, p)
                println(pTargetWeights[p], " in Cone", p)
                return G
            end
            global pTargetWeights =
                [pertubed_vector(G, T, i) for i = 1:nvars(R)]
            println("not in Cone ", pTargetWeights)
            continue
        end

        # Handling the current weight with regards to Int32-entrys.
        w = w + t * (pTargetWeights[p] - w)
        w = convert_bounding_vector(w)
        Gw = initials(R, Singular.gens(G), w)
        if !checkInt32(w)
            w, b = truncw(G, w, Gw)
            if !b
                return G
            end
        end

        # Converting the Groebnerbasis
        Rn = change_order(R, w, T)
        if p == nvars(R)
            H = Singular.std(
                Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                complete_reduction = true,
            )
            println(w, " in depth", p)
            raiseCounterFr()
        else
            println("up in: ", p, " with: ", w)
            H = fractal_recursiv(
                Singular.Ideal(R, Gw),
                S,
                T,
                deepcopy(currweight),
                pTargetWeights,
                p + 1,
            )
        end
        # Lifting
        #H = liftGW2(G, R, Gw, H, Rn)
        H = lift_fractal_walk(G, H, Rn)
        G = interreduce_walk(H)
        R = Rn
        currweight = w
    end
    return G
end




function fractal_walk_start_order(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
)
    global pTargetWeights =
        [pertubed_vector(G, T, i) for i = 1:nvars(Singular.base_ring(G))]
    println("fractal_walk_withStartorder results")
    println("Crossed Cones in: ")
    Gb = fractal_walk_recursiv_startorder(G, S, T, S[1, :], pTargetWeights, 1)
    println("Cones crossed: ", deleteCounterFr())
    return Gb
end

function fractal_walk_recursiv_startorder(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    currweight::Vector{Int},
    pTargetWeights::Vector{Vector{Int}},
    p::Int,
)
    R = Singular.base_ring(G)
    terminate = false
    G.isGB = true

    # Handling the starting weight.
    if (p == 1)
        if !ismonomial(initials(R, Singular.gens(G), currweight))
            global pStartWeights = [pertubed_vector(G, S, i) for i = 1:nvars(R)]
            global firstStepMode = true
        end
    end
    if firstStepMode
        w = pStartWeights[p]
    else
        w = currweight
    end

    while !terminate
        t = next_weightfr(G, w, pTargetWeights[p])

        # Handling the final step in the current depth.
        if t == 1 && p != 1
            if same_cone(G, T)
                println(currweight, " in Cone", p)
                if !inCone(G, T,pTargetWeights, p)
                    global pTargetWeights =
                        [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                    println("not in Cone ", pTargetWeights)
                end
                return G
            end
        elseif t == [0]
            if p == 1 || inCone(G, T,pTargetWeights, p)
                println(pTargetWeights[p], " in Cone", p)
                return G
            end
            global pTargetWeights =
                [pertubed_vector(G, T, i) for i = 1:nvars(R)]
            println("not in Cone ", pTargetWeights)
            continue
        end

        # Handling the current weight with regards to Int32-entrys.
        w = w + t * (pTargetWeights[p] - w)
        w = convert_bounding_vector(w)
        Gw = initials(R, gens(G), w)
        if !checkInt32(w)
            w, b = truncw(G, w, Gw)
            if !b
                throw(Exception)
            end
        end
        Rn = change_order(R, w, T)

        # Converting the Groebnerbasis
        if p == Singular.nvars(R)
            H = Singular.std(
                Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                complete_reduction = true,
            )
            println(w, " in depth", p)
            raiseCounterFr()
        else
            println("up in: ", p, " with: ", w)
            H = fractal_walk_recursiv_startorder(
                Singular.Ideal(R, Gw),
                S,
                T,
                deepcopy(currweight),
                pTargetWeights,
                p + 1,
            )
            global firstStepMode = false
        end
        #H = liftGW2(G, R, Gw, H, Rn)
        H = lift_fractal_walk(G, H, Rn)
        G = interreduce_walk(H)
        R = Rn
        currweight = w
    end
    return G
end
function fractal_walk_lex(G::Singular.sideal, S::Matrix{Int}, T::Matrix{Int})
    global pTargetWeights =
        [pertubed_vector(G, T, i) for i = 1:nvars(base_ring(G))]
    println("fractal_walk_lex results")
    println("Crossed Cones in: ")
    Gb = fractal_walk_recursive_lex(G, S, T, S[1, :], pTargetWeights, 1)
    println("Cones crossed: ", deleteCounterFr())
    return Gb
end

function fractal_walk_recursive_lex(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    currweight::Vector{Int},
    pTargetWeights::Vector{Vector{Int}},
    p::Int,
)
    R = Singular.base_ring(G)
    terminate = false
    G.isGB = true
    w = currweight
    while !terminate
        t = next_weightfr(G, w, pTargetWeights[p])

        # Handling the final step in the current depth.
        if t == 1 && p != 1
            if same_cone(G, T)
                println(currweight, " in Cone", p)
                if !inCone(G, T,pTargetWeights, p)
                    global pTargetWeights =
                        [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                    println("not in Cone ", pTargetWeights)
                end
                return G
            end
        elseif t == [0]
            if p == 1 || inCone(G, T,pTargetWeights, p)
                println(pTargetWeights[p], " in Cone", p)
                return G
            end
            global pTargetWeights =
                [pertubed_vector(G, T, i) for i = 1:nvars(R)]
            println("not in Cone ", pTargetWeights)
            continue
        end
        if t == 1 && p == 1
            return fractal_walk_recursive_lex(G, S, T, w, pTargetWeights, p + 1)
        else

            w = w + t * (pTargetWeights[p] - w)
            w = convert_bounding_vector(w)
            Gw = initials(R, Singular.gens(G), w)

            # Handling the current weight with regards to Int32-entrys.
            if !checkInt32(w)
                w, b = truncw(G, w, Gw)
                if !b
                    throw(Exception)
                end
            end
            Rn = change_order(R, w, T)

            # Converting the Groebnerbasis
            if p == Singular.nvars(R)
                H = Singular.std(
                    Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                    complete_reduction = true,
                )
                println(w, " in depth", p)
                raiseCounterFr()
            else
                println("up in: ", p, " with: ", w)
                H = fractal_walk_recursive_lex(
                    Singular.Ideal(R, Gw),
                    S,
                    T,
                    deepcopy(currweight),
                    pTargetWeights,
                    p + 1,
                )
                global firstStepMode = false
            end
        end
        #H = liftGW2(G, R, Gw, H, Rn)
        H = lift_fractal_walk(G, H, Rn)
        G = interreduce_walk(H)
        R = Rn
        currweight = w
    end
    return G
end
function fractal_walk_look_ahead(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
)
    println("fractal_walk_look_ahead results")
    println("Crossed Cones in: ")
    global pTargetWeights =
        [pertubed_vector(G, T, i) for i = 1:nvars(base_ring(G))]
    Gb = fractal_walk_look_ahead_recursiv(G, S, T, S[1, :], pTargetWeights, 1)
    println("Cones crossed: ", deleteCounterFr())
    return Gb
end

function fractal_walk_look_ahead_recursiv(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    currweight::Vector{Int},
    pTargetWeights::Vector{Vector{Int}},
    p::Int,
)
    R = Singular.base_ring(G)
    terminate = false
    G.isGB = true
    w = currweight

    while !terminate
        t = next_weightfr(G, w, pTargetWeights[p])

        # Handling the final step in the current depth.
        if t == 1 && p != 1
            if same_cone(G, T)
                println(currweight, " in Cone", p)
                if !inCone(G, T,pTargetWeights, p)
                    global pTargetWeights =
                        [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                    println("not in Cone ", pTargetWeights)
                end
                return G
            end
        elseif t == [0]
            if p == 1 || inCone(G, T,pTargetWeights, p)
                println(pTargetWeights[p], " in Cone", p)
                return G
            end
            global pTargetWeights =
                [pertubed_vector(G, T, i) for i = 1:nvars(R)]
            println("not in Cone ", pTargetWeights)
            continue
        end
        w = w + t * (pTargetWeights[p] - w)
        w = convert_bounding_vector(w)
        Gw = initials(R, Singular.gens(G), w)

        # Handling the current weight with regards to Int32-entrys.
        if !checkInt32(w)
            w, b = truncw(G, w, Gw)
            if !b
                throw(Exception)
            end
        end
        Rn = change_order(R, w, T)

        # Converting the Groebnerbasis
        if (p == Singular.nvars(R) || isbinomial(Gw))
            H = Singular.std(
                Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                complete_reduction = true,
            )
            println(w, " in depth", p)
            raiseCounterFr()
        else
            println("up in: ", p, " with: ", w)
            H = fractal_walk_look_ahead_recursiv(
                Singular.Ideal(R, Gw),
                S,
                T,
                deepcopy(currweight),
                pTargetWeights,
                p + 1,
            )
        end
        #H = liftGW2(G, R, Gw, H, Rn)
        H = lift_fractal_walk(G, H, Rn)
        G = interreduce_walk(H)
        R = Rn
        currweight = w
    end
    return G
end
global time = 0

function fractal_walk_combined(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
)
    global pTargetWeights =
        [pertubed_vector(G, T, i) for i = 1:nvars(Singular.base_ring(G))]
    println("fractal_walk_combined results")
    println("Crossed Cones in: ")
    Gb = fractal_walk_combined(G, S, T, S[1, :], pTargetWeights, 1)
    println("Cones crossed: ", deleteCounterFr())
    println(time)
    return Gb
end

function fractal_walk_combined(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    currweight::Vector{Int},
    pTargetWeights::Vector{Vector{Int}},
    p::Int,
)
    R = Singular.base_ring(G)
    terminate = false
    G.isGB = true

    # Handling the weight of the start ordering.
    if (p == 1)
        if !ismonomial(initials(R, Singular.gens(G), currweight))
            global pStartWeights = [pertubed_vector(G, S, i) for i = 1:nvars(R)]
            println(pStartWeights)
            global firstStepMode = true
        end
    end
    if firstStepMode
        w = pStartWeights[p]
    else
        w = currweight
    end

    while !terminate
         t =  next_weightfr(G, w, pTargetWeights[p])

        # Handling the final step in the current depth.
        if t == 1 && p != 1
            if same_cone(G, T)
                println(currweight, " in Cone", p)
                if !inCone(G, T,pTargetWeights, p)
                    global pTargetWeights =
                        [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                    println("not in Cone ", pTargetWeights)
                end
                return G
            end
        elseif t == [0]
            if inCone(G, T,pTargetWeights, p)
                println(pTargetWeights[p], " in Cone", p)
                return G
            end
            global pTargetWeights =
                [pertubed_vector(G, T, i) for i = 1:nvars(R)]
            println("not in Cone ", pTargetWeights)
            continue
        end
        if t == 1 && p == 1
            println("up in: ", p, " with: t = 1")
            return fractal_walk_combined(G, S, T, w, pTargetWeights, p + 1)
        else
            w = w + t * (pTargetWeights[p] - w)
            w = convert_bounding_vector(w)
            Gw = initials(R, gens(G), w)

            # Handling the current weight with regards to Int32-entrys. Addtionally use Buchberger´s Algorithm to skip a weight>Int32
            if !checkInt32(w)
                w, b = truncw(G, w, Gw)
                if !b
                    Rn = change_order(R, T)
                    w = T[1, :]
                    G = Singular.std(
                        Singular.Ideal(
                            Rn,
                            [change_ring(x, Rn) for x in gens(G)],
                        ),
                        complete_reduction = true,
                    )
                    if !inCone(G, T,pTargetWeights, p)
                        global pTargetWeights =
                            [pertubed_vector(G, T, i) for i = 1:nvars(R)]
                        println("not in Cone ", pTargetWeights)
                    end
                    return G
                else
                    Rn = change_order(R, w, T)
                end
            end
            Rn = change_order(R, w, T)

            # Converting the Groebnerbasis
            if (p == Singular.nvars(R) || isbinomial(Gw))
                H = Singular.std(
                    Singular.Ideal(Rn, [change_ring(x, Rn) for x in Gw]),
                    complete_reduction = true,
                )
                println(w, " in depth", p)
                raiseCounterFr()
            else
                println(
                    "from $(currweight) to $(pTargetWeights[p])",
                    "up in: ",
                    p,
                    " with: ",
                    w,
                )
                H = fractal_walk_combined(
                    Singular.Ideal(R, Gw),
                    S,
                    T,
                    deepcopy(currweight),
                    pTargetWeights,
                    p + 1,
                )
                global firstStepMode = false
            end
        end
        #H = liftGW2(G, R, Gw, H, Rn)
        H = lift_fractal_walk(G, H, Rn)
        G = interreduce_walk(H)
        R = Rn
        currweight = w
    end
    return G
end

###############################################################
#Tran´s version of the groebner walk by Tran (2002).
###############################################################

function tran_walk(G::Singular.sideal, S::Matrix{Int}, T::Matrix{Int})
    currweight = S[1, :]
    tarweight = T[1, :]
    println("tran_walk results")
    println("Crossed Cones in: ")
    R = base_ring(G)
    if !ismonomial(initials(R, Singular.gens(G), currweight))
        currweight = pertubed_vector(G, S, nvars(R))
    end

    terminate = false
    while !terminate
        w = next_weight(G, currweight, tarweight)
        println(w)
        if !checkInt32(w)
            w, b = truncw(G, w, initials(R, gens(G), w))
            if !b
                return G
            end
        end
        Rn = change_order(R, w, T)
        if w == tarweight
            if same_cone(G, T)
                #this checks if in_{<_{cw}}(g)= in_<(in_cw(g)) = in_<<(g) f.a. g in G
                return G
            elseif inSeveralCones(initials(base_ring(G), gens(G), tarweight))
                tarweight = representation_vector(G, T)
                continue
            end
        end
        G = standard_step_without_int32_check(G, w, T)
        global counter = getCounter() + 1
        R = Rn
        currweight = w
    end
    println("Cones crossed: ", getCounter())
    return G
end

###############################################################
# Standard_step without the checking of the weight $w$ w.r.t. Int32
###############################################################

function standard_step_without_int32_check(
    G::Singular.sideal,
    w::Vector{Int},
    T::Matrix{Int},
)
    R = base_ring(G)
    Rn = change_order(R, w, T)

    Gw = initials(Rn, gens(G), w)
    H = Singular.std(Singular.Ideal(Rn, Gw), complete_reduction = true)
    #H = liftGW2(G, R, Gw, H, Rn)
    H = lift(G, R, H, Rn)
    return interreduce_walk(H)
end

function pgeneric_walk(
    G::Singular.sideal,
    S::Matrix{Int},
    T::Matrix{Int},
    p::Int,
)
    R = base_ring(G)
    Rn = change_order(G.base_ring, T)
    v = next_gamma(G, [0], S, T, p)
    Lm = [change_ring(Singular.leading_term(g), Rn) for g in gens(G)]
    G = Singular.Ideal(Rn, [change_ring(x, Rn) for x in gens(G)])

    println("generic_walk results")
    println("Crossed Cones with facetNormal: ")
    while !isempty(v)
        global counter = getCounter() + 1
        println(v)
        G, Lm = generic_step(G, Lm, v, T, R)
        v = next_gamma(G, Lm, v, S, T, p)
    end
    return Singular.interreduce(G)
end

function generic_step(
    G::Singular.sideal,
    Lm::Vector{Singular.spoly{L}},
    v::Vector{Int},
    T::Matrix{Int},
    R::Singular.PolyRing,
) where {L<:Nemo.RingElem}

    Rn = Singular.base_ring(G)

    facet_Generators = facet_initials(G, Lm, v)
    H = Singular.std(
        Singular.Ideal(Rn, facet_Generators),
        complete_reduction = true,
    )
    H, Lm = lift_generic(G, Lm, H)
    G = interreduce(H, Lm)
    G = Singular.Ideal(Rn, G)
    G.isGB = true
    return G, Lm
end
