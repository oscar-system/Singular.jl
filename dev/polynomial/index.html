<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multivariate polynomials · Singular.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Singular.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><span class="tocitem">Coefficient rings</span><ul><li><a class="tocitem" href="../integer/">Integers</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../modn/">Integers mod n</a></li><li><a class="tocitem" href="../modp/">Integers mod p</a></li><li><a class="tocitem" href="../transExt/">Function fields</a></li><li><a class="tocitem" href="../GF/">Finite fields</a></li><li><a class="tocitem" href="../nemo/">Nemo rings and fields</a></li></ul></li><li class="is-active"><a class="tocitem" href>Multivariate polynomials</a><ul class="internal"><li><a class="tocitem" href="#Multivariate-polynomial-functionality"><span>Multivariate polynomial functionality</span></a></li></ul></li><li><a class="tocitem" href="../noncommutative/">Noncommutative algebras</a></li><li><a class="tocitem" href="../ideal/">Ideals</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module/">Finitely generated modules</a></li><li><a class="tocitem" href="../vector/">Free modules and vectors</a></li></ul></li><li><a class="tocitem" href="../alghom/">Algebra Homomorphisms</a></li><li><a class="tocitem" href="../resolution/">Resolutions</a></li><li><a class="tocitem" href="../matrix/">Matrices</a></li><li><a class="tocitem" href="../caller/">Interpreter Functionality</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Multivariate polynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multivariate polynomials</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/polynomial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Multivariate-polynomials"><a class="docs-heading-anchor" href="#Multivariate-polynomials">Multivariate polynomials</a><a id="Multivariate-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-polynomials" title="Permalink"></a></h1><p>Singular.jl allows the creation of multivariate polynomials over any of the coefficient rings described above.</p><p>The default multivariate polynomial type in Singular.jl is the Singular <code>spoly</code> type.</p><p>The associated polynomial ring is represented by a parent object which can be constructed by a call to the <code>PolynomialRing</code> constructor.</p><p>The types of the polynomial ring parent objects and elements thereof are given in the following table according to the library providing them.</p><table><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Singular</td><td style="text-align: right"><code>spoly{T}</code></td><td style="text-align: right"><code>Singular.PolyRing{T}</code></td></tr></table><p>These types are parameterised by the type of elements in the coefficient ring of the polynomials.</p><p>All polynomial types belong directly to the abstract type <code>MPolyElem</code> and all the polynomial ring parent object types belong to the abstract type <code>MPolyRing</code>.</p><h2 id="Multivariate-polynomial-functionality"><a class="docs-heading-anchor" href="#Multivariate-polynomial-functionality">Multivariate polynomial functionality</a><a id="Multivariate-polynomial-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-polynomial-functionality" title="Permalink"></a></h2><p>Singular.jl polynomials provides all the Multivariate Polynomial Ring functionality described by AbstractAlgebra.jl.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial">https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial</a></p><p>In particular, Singular polynomials are sparse distributed, but do not have random access. Instead, they implement iterator access to terms. This is due to their storage in a linked list, for efficient implementation of Groebner basis algorithms.</p><p>Some polynomial rings may also implement part of the Euclidean Ring interface, where this is appropriate.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface">https://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface</a></p><p>Below, we describe the functionality that is specific to the Singular multivariate polynomials that is not documented in the general multivariate interface.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><pre><code class="language-julia">PolynomialRing(R::Union{Ring, Field}, s::Vector{String};
   cached::Bool = true, ordering = :degrevlex,
      ordering2::Symbol = :comp1min, degree_bound::Int = 0)</code></pre><p>Returns a tuple, <span>$S, x$</span> consisting of a multivariate polynomial ring <span>$S$</span> and an array <span>$x$</span> of variables (from which polynomials can be constructed). The ring <span>$R$</span> must be a valid Singular coefficient ring, or any Nemo/AbstractAlgebra coefficient ring. The array <span>$s$</span> must be a list of strings corresponding to how the variables will be printed. By default, there will only be one Singular polynomial ring in the system for each combination of coefficient ring, list of variable names, ordering and degree bound. This is accomplished by making use of a global cache. If this is not the desired behaviour, <code>false</code> can be passed to the optional argument <code>cached</code>.</p><p>If the first ordering <code>ordering</code> is specified as a symbol, then two orderings can be specified, one for term ordering of the polynomials, and another for ordering of module components. They can occur in either order, the first taking precedence over the other, when the polynomials are used to represent module generators. If either is not specified, the indicated default is used. The options for polynomial term ordering are, <code>:lex</code>, <code>:deglex</code>, <code>:degrevlex</code>, <code>:neglex</code>, <code>:negdeglex</code> and <code>:negdegrevlex</code>, and the options for module component ordering are <code>comp1min</code> and <code>comp1max</code>.</p><p>If the first ordering <code>ordering</code> is specifed as a non-symbol, the second ordering <code>ordering2</code> will be ignored. For specifying non-symbolic term orderings, please see the Term orderings section below.</p><p>If one has an a priori bound on the degree in each variable of a polynomial (including for all intermediate computations in this ring), one can specify it using the <code>degree_bound</code> optional parameter. Singular may then be able to use a more efficient representation internally, which will use less memory and allow for faster arithmetic. By default, Singular uses a bound of 16 bits internally for the exponent of each variable, however this is a signed value, so that the default is for nonnegative exponents that fit in 15 bits.</p><p>Note that internally, Singular may use a higher bound than specified, if it will not increase the amount of storage required.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, z) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])

S, vars = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;]; ordering=:deglex)

T, x = PolynomialRing(ZZ, [&quot;x$i&quot; for i in 1:5];
       ordering=:comp1max, ordering2=:degrevlex, degree_bound=5)</code></pre><p>See also the convenience macros below for simple use cases.</p><p>The following function allows creating a Singular polynomial ring from a given polynomial ring of type AbstractAlgebra.Generic.MPolyRing:</p><pre><code class="language-julia">PolynomialRing(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true, ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min, degree_bound::Int = 0)  where {T &lt;: RingElement}</code></pre><p>Polynomials can be constructed using arithmetic operations on the generators, but this can be extremely inefficient. For this purpose, Singular polynomials support construction using a build context, as described in the AbstractAlgebra documentation:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial">https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial</a></p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;])
C = MPolyBuildCtx(R)

push_term!(C, ZZ(1), [1, 2])
push_term!(C, ZZ(3), [1, 1])
push_term!(C, -ZZ(1), [0, 1])
f = finish(C)</code></pre><h3 id="Term-orderings"><a class="docs-heading-anchor" href="#Term-orderings">Term orderings</a><a id="Term-orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Term-orderings" title="Permalink"></a></h3><p>A general term ordering can be constructed as a product of one or more of the following block orderings.</p><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_lp" href="#Singular.ordering_lp"><code>Singular.ordering_lp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ordering_lp(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the lexicographical ordering (:lex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_rp" href="#Singular.ordering_rp"><code>Singular.ordering_rp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ordering_rp(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the reverse lexicographical ordering (:revlex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_dp" href="#Singular.ordering_dp"><code>Singular.ordering_dp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ordering_dp(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the degree reverse lexicographical ordering (:degrevlex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_Dp" href="#Singular.ordering_Dp"><code>Singular.ordering_Dp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ordering_Dp(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the degree lexicographical ordering (:deglex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_wp-Tuple{Vector{Int64}}" href="#Singular.ordering_wp-Tuple{Vector{Int64}}"><code>Singular.ordering_wp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordering_wp(w::Vector{Int})</code></pre><p>Represents a block of variables with the weighted reverse lexicographical ordering. The weight vector <code>w</code> is expected to consist of positive integers only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_Wp-Tuple{Vector{Int64}}" href="#Singular.ordering_Wp-Tuple{Vector{Int64}}"><code>Singular.ordering_Wp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordering_Wp(w::Vector{Int})</code></pre><p>Represents a block of variables with the weighted lexicographical ordering. The weight vector is expected to consist of positive integers only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_ls" href="#Singular.ordering_ls"><code>Singular.ordering_ls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ordering_ls(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the negative lexicographical ordering (:neglex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_rs" href="#Singular.ordering_rs"><code>Singular.ordering_rs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ordering_rs(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the negative reverse lexicographical ordering (:negrevlex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_ds" href="#Singular.ordering_ds"><code>Singular.ordering_ds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ordering_ds(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the negative degree reverse lexicographical ordering (:negdegrevlex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_Ds" href="#Singular.ordering_Ds"><code>Singular.ordering_Ds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ordering_Ds(nvars::Int = 1)</code></pre><p>Represents a block of at least <code>nvars</code> variables with the negative degree reverse lexicographical ordering (:negdeglex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_ws-Tuple{Vector{Int64}}" href="#Singular.ordering_ws-Tuple{Vector{Int64}}"><code>Singular.ordering_ws</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordering_ws(w::Vector{Int})</code></pre><p>Represents a block of variables with the general weighted reverse lexicographical ordering. The weight vector <code>w</code> is expected to have a nonzero first entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_Ws-Tuple{Vector{Int64}}" href="#Singular.ordering_Ws-Tuple{Vector{Int64}}"><code>Singular.ordering_Ws</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordering_Ws(w::Vector{Int})</code></pre><p>Represents a block of variables with the general weighted lexicographical ordering. The weight vector <code>w</code> is expected to have a nonzero first entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_a-Tuple{Vector{Int64}}" href="#Singular.ordering_a-Tuple{Vector{Int64}}"><code>Singular.ordering_a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordering_a(w::Vector{Int})</code></pre><p>Represents an extra weight vector that may precede any monomial ordering. An extra weight vector does not define a monomial ordering by itself: it can only be used in combination with other orderings to insert an extra line of weights into the ordering matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_M-Tuple{Matrix{Int64}}" href="#Singular.ordering_M-Tuple{Matrix{Int64}}"><code>Singular.ordering_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordering_M(m::Matrix{Int}; checked::Bool = true)</code></pre><p>Represents a block of variables with a general matrix ordering. The matrix <code>m</code> is expected to be invertible, and this is checked by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_C-Tuple{}" href="#Singular.ordering_C-Tuple{}"><code>Singular.ordering_C</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordering_C()</code></pre><p>Represents an ascending ordering on vector components <code>gen(1) &lt; gen(2) &lt; ...</code>. All monomial block orderings preceding the component ordering have higher precedence, and all succeeding monomial block orderings have lower precedence. It is not necessary to specify this ordering explicitly since it appended automatically to an ordering lacking a component specification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.ordering_c-Tuple{}" href="#Singular.ordering_c-Tuple{}"><code>Singular.ordering_c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordering_c()</code></pre><p>Represents a decending ordering on vector components <code>gen(1) &gt; gen(2) &gt; ...</code>. All monomial block orderings preceding the component ordering have higher precedence, and all succeeding monomial block orderings have lower precedence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/orderings.jl#L234">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">PolynomialRing(QQ, &quot;x&quot;.*string.(1:8), ordering = ordering_M([1 2; 3 5])*ordering_lp(3)*ordering_wp([1, 2, 3]))

PolynomialRing(QQ, &quot;x&quot;.*string.(1:5), ordering = ordering_dp(3)*ordering_dp())</code></pre><h3 id="Polynomial-ring-macros"><a class="docs-heading-anchor" href="#Polynomial-ring-macros">Polynomial ring macros</a><a id="Polynomial-ring-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-ring-macros" title="Permalink"></a></h3><p>For convenience, we provide some macros for constructing polynomial rings and injecting the variables into scope. These are easier to use, but have some limitations. In particular, they can only be used at the top level by the user, and cannot be used programmatically or in library code (it is not possible to inject an arbitrary number of variables into scope inside a function).</p><p>The macros are designed for simple use cases, and do not offer the full power of the most general constructor above.</p><pre><code class="language-julia">@PolynomialRing(R, s, n, o)</code></pre><p>Given a coefficient ring <span>$R$</span>, a root variable name, e.g. <code>&quot;x&quot;</code>, a number of variable <span>$n$</span> and a polynomial term ordering <code>o</code>, create the variables <code>x1, x2, ..., xn</code> and inject them into scope, and return the corresponding polynomial ring <code>S</code>.</p><pre><code class="language-julia">@PolynomialRing(R, s, n)</code></pre><p>As per the previous macro, with a default of <code>:degrevlex</code> for the polynomial term ordering.</p><p><strong>Examples</strong></p><pre><code class="language-julia">S = @PolynomialRing(ZZ, &quot;x&quot;, 5, :deglex)

T = @PolynomialRing(QQ, &quot;y&quot;, 10)</code></pre><h3 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Singular.has_global_ordering-Tuple{PolyRing}" href="#Singular.has_global_ordering-Tuple{PolyRing}"><code>Singular.has_global_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_global_ordering(R::PolyRingUnion)</code></pre><p>Return <code>true</code> if the given ring has a global ordering, i.e. if <span>$1 &lt; x$</span> for each variable <span>$x$</span> in the ring. This include <code>:lex</code>, <code>:deglex</code> and <code>:degrevlex</code> orderings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.has_mixed_ordering-Tuple{PolyRing}" href="#Singular.has_mixed_ordering-Tuple{PolyRing}"><code>Singular.has_mixed_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_mixed_ordering(R::PolyRingUnion)</code></pre><p>Return <code>true</code> if the given ring has a mixed ordering, i.e. if <span>$1 &lt; x_i$</span> for a variable <span>$x_i$</span> and <span>$1&gt;x_j$</span> for another variable <span>$x_j$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.has_local_ordering-Tuple{PolyRing}" href="#Singular.has_local_ordering-Tuple{PolyRing}"><code>Singular.has_local_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_local_ordering(R::PolyRingUnion)</code></pre><p>Return <code>true</code> if the given ring has a local ordering, i.e. if <span>$1 &gt; x$</span> for all variables <span>$x$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.degree_bound-Tuple{PolyRing}" href="#Singular.degree_bound-Tuple{PolyRing}"><code>Singular.degree_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degree_bound(R::PolyRing)</code></pre><p>Return the internal degree bound in each variable, enforced by Singular. This is the largest positive value any degree can have before an overflow will occur. This internal bound may be higher than the bound requested by the user via the <code>degree_bound</code> parameter of the <code>PolynomialRing</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L121">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>leading_exponent_vector(p::spoly)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.total_degree-Tuple{spoly}" href="#AbstractAlgebra.Generic.total_degree-Tuple{spoly}"><code>AbstractAlgebra.Generic.total_degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">total_degree(p::spoly)</code></pre><p>Return the total degree (largest sum of exponents of any monomial) of <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GroupsCore.order-Tuple{spoly}" href="#GroupsCore.order-Tuple{spoly}"><code>GroupsCore.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order(p::spoly)</code></pre><p>Returns the order of <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L219">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-none">R = @PolynomialRing(ZZ, &quot;x&quot;, 3)

n = ngens(R)
has_global_ordering(R) == true
c = characteristic(R)
L = degree_bound(R)
exps = leading_exponent_vector(x1*x2 + 3x1*x2^2 + x3 + 2)
deg = total_degree(x1*x2 + 3x1*x2^2 + x3 + 2)
ord = order(x1*x2 + 3x1*x2^2 + x3 + 2)</code></pre><h3 id="Differential-functions"><a class="docs-heading-anchor" href="#Differential-functions">Differential functions</a><a id="Differential-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-functions" title="Permalink"></a></h3><p>Working over any coefficient ring, basic functionality involving differential operations is available.</p><article class="docstring"><header><a class="docstring-binding" id="Singular.jet-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.jet-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.jet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jet(x::spoly{T}, n::Int) where T &lt;: Nemo.RingElem</code></pre><p>Return the truncation of <span>$x$</span> up to degree <span>$n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L1237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem" href="#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem"><code>AbstractAlgebra.derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative(x::spoly{T}, n::Int) where T &lt;: Nemo.RingElem</code></pre><p>Return the derivative of <span>$x$</span> with respect to the variable of index <span>$n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L1247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T&lt;:AbstractAlgebra.RingElem" href="#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>AbstractAlgebra.derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative(x::spoly{T}, v::spoly{T}) where T &lt;: Nemo.RingElem</code></pre><p>Return the derivative of <span>$x$</span> with respect to the variable <span>$v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L1258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.jacobian_ideal-Union{Tuple{spoly{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.jacobian_ideal-Union{Tuple{spoly{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.jacobian_ideal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian_ideal(p::spoly{T}) where T &lt;: Nemo.RingElem</code></pre><p>Returns the ideal generated by all partial derivatives of <span>$x$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L1269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.jacobian_matrix-Union{Tuple{spoly{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.jacobian_matrix-Union{Tuple{spoly{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.jacobian_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian_matrix(p::spoly{T}) where T &lt;: Nemo.RingElem</code></pre><p>Returns the column matrix <span>$\{\frac{\partial p}{\partial x_i}\}_i$</span> of partial derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L1280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.jacobian_matrix-Union{Tuple{Array{spoly{T}, 1}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.jacobian_matrix-Union{Tuple{Array{spoly{T}, 1}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.jacobian_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian_matrix(a::Vector{spoly{T}}) where T &lt;: Nemo.RingElem</code></pre><p>Returns the matrix <span>$\{\frac{\partial a_i}{\partial x_j}\}_{ij}$</span> of partial derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L1295">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])

f = x^2*y*z + z^2*x + x*y*z

g = jet(f, 3)

derivative(f, 1)

derivative(f, y)

J = jacobian_ideal(f)

Jf1 = jacobian_matrix(f)

Jf2 = jacobian_matrix([f, g])</code></pre><h3 id="Content-and-primitive-part"><a class="docs-heading-anchor" href="#Content-and-primitive-part">Content and primitive part</a><a id="Content-and-primitive-part-1"></a><a class="docs-heading-anchor-permalink" href="#Content-and-primitive-part" title="Permalink"></a></h3><p>When coefficient rings have a meaningful GCD function, the following functions are available.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.primpart-Tuple{spoly}" href="#AbstractAlgebra.primpart-Tuple{spoly}"><code>AbstractAlgebra.primpart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primpart(x::SPolyUnion)</code></pre><p>Return the primitive part of the polynomial, i.e. the polynomial divided by the GCD of its coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.content-Tuple{spoly}" href="#AbstractAlgebra.content-Tuple{spoly}"><code>AbstractAlgebra.content</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">content(x::SPolyUnion)</code></pre><p>Return the content of the polynomial, i.e. the GCD of its coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L946">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R = @PolynomialRing(ZZ, &quot;x&quot;, 2)

f = 3x1^2 + 3x1*x2 + 6x2^2

p = primpart(f)
c = content(f)</code></pre><h3 id="Multivariate-Factorisation"><a class="docs-heading-anchor" href="#Multivariate-Factorisation">Multivariate Factorisation</a><a id="Multivariate-Factorisation-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Factorisation" title="Permalink"></a></h3><p>For the Singular base fields <code>QQ</code> and <code>Fp</code> a function to compute a squarefree factorization is available.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R = @PolynomialRing(QQ, &quot;x&quot;, 4)

f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2

Fac = factor(f)</code></pre><p>For the Singular base rings <code>QQ</code>, <code>ZZ</code> and <code>Fp</code> a function to compute the multivariate factorization is available.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R = @PolynomialRing(ZZ, &quot;x&quot;, 4)

f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2

Fac = factor(f)</code></pre><h3 id="Change-of-coefficient-rings"><a class="docs-heading-anchor" href="#Change-of-coefficient-rings">Change of coefficient rings</a><a id="Change-of-coefficient-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Change-of-coefficient-rings" title="Permalink"></a></h3><p>It is possible to change the coefficient ring of a given polynomial <span>$p$</span> via the function &#39;change<em>base</em>ring&#39;.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;])

p = x^5 + y^3+1

change_base_ring(QQ, p)</code></pre><p>It also possible to work with Nemo rings by casting to a suitable Singular type via <code>CoefficientRing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;])

p = x^5 + y^3+1

change_base_ring(CoefficientRing(Nemo.QQ), p)</code></pre><h3 id="Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials"><a class="docs-heading-anchor" href="#Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials">Conversion between Singular.jl polynomials and MPoly polynomials</a><a id="Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials" title="Permalink"></a></h3><p>There are conversion functions between the polynomial ring implementation from Singular.jl and the generic MPoly implementation from AbstractAlgebra.jl.</p><article class="docstring"><header><a class="docstring-binding" id="Singular.AsEquivalentSingularPolynomialRing-Union{Tuple{AbstractAlgebra.Generic.MPolyRing{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.AsEquivalentSingularPolynomialRing-Union{Tuple{AbstractAlgebra.Generic.MPolyRing{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.AsEquivalentSingularPolynomialRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AsEquivalentSingularPolynomialRing(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true,
  ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min,
  degree_bound::Int = 0)  where {T &lt;: RingElem}</code></pre><p>Return a Singular (multivariate) polynomial ring over the base ring of <span>$R$</span> in variables having the same names as those of R.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L1142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.AsEquivalentAbstractAlgebraPolynomialRing-Union{Tuple{PolyRing{T}}, Tuple{T}} where T&lt;:(Union{Singular.n_FieldElem{T}, Singular.n_RingElem{T}} where T)" href="#Singular.AsEquivalentAbstractAlgebraPolynomialRing-Union{Tuple{PolyRing{T}}, Tuple{T}} where T&lt;:(Union{Singular.n_FieldElem{T}, Singular.n_RingElem{T}} where T)"><code>Singular.AsEquivalentAbstractAlgebraPolynomialRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AsEquivalentAbstractAlgebraPolynomialRing(R::Singular.PolyRing{T}; ordering::Symbol = :degrevlex) where T &lt;: Singular.n_unknown</code></pre><p>Return an AbstractAlgebra (multivariate) polynomial ring over the base ring of <span>$R$</span> in variables having the same names as those of R.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/a1249030127c4c5da45a887777d9141eeebfbdbe/src/poly/poly.jl#L1154">source</a></section></article><p><strong>Examples</strong></p><p>Conversion of generic AbstractAlgebra polynomials to Singular.jl polynomials:</p><pre><code class="language-julia">K = Nemo.ZZ
R, (x, y) = AbstractAlgebra.Generic.PolynomialRing(K, [&quot;x&quot;, &quot;y&quot;]);
Rsing, vars_Rsing = Singular.AsEquivalentSingularPolynomialRing(R);
Rsing(x + y) == Rsing(x) + Rsing(y)</code></pre><p>Conversion of Singular.jl polynomials to generic AbstractAlgebra polynomials:</p><pre><code class="language-julia">K = Nemo.ZZ
S, (u, v) = Singular.PolynomialRing(K, [&quot;u&quot;, &quot;v&quot;])
Saa, (uu, vv) = Singular.AsEquivalentAbstractAlgebraPolynomialRing(S)
Saa(u) + Saa(v) == Saa(u) + Saa(v)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nemo/">« Nemo rings and fields</a><a class="docs-footer-nextpage" href="../noncommutative/">Noncommutative algebras »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 18 March 2022 17:00">Friday 18 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
