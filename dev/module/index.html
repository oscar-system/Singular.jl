<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finitely generated modules · Singular.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Singular.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><span class="tocitem">Coefficient rings</span><ul><li><a class="tocitem" href="../integer/">Integers</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../modn/">Integers mod n</a></li><li><a class="tocitem" href="../modp/">Integers mod p</a></li><li><a class="tocitem" href="../transExt/">Function fields</a></li><li><a class="tocitem" href="../GF/">Finite fields</a></li><li><a class="tocitem" href="../nemo/">Nemo rings and fields</a></li></ul></li><li><a class="tocitem" href="../polynomial/">Multivariate polynomials</a></li><li><a class="tocitem" href="../ideal/">Ideals</a></li><li><span class="tocitem">Modules</span><ul><li class="is-active"><a class="tocitem" href>Finitely generated modules</a><ul class="internal"><li><a class="tocitem" href="#Module-functionality"><span>Module functionality</span></a></li></ul></li><li><a class="tocitem" href="../vector/">Free modules and vectors</a></li></ul></li><li><a class="tocitem" href="../alghom/">Algebra Homomorphisms</a></li><li><a class="tocitem" href="../resolution/">Resolutions</a></li><li><a class="tocitem" href="../matrix/">Matrices</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Finitely generated modules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finitely generated modules</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/module.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Finitely-generated-modules"><a class="docs-heading-anchor" href="#Finitely-generated-modules">Finitely generated modules</a><a id="Finitely-generated-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Finitely-generated-modules" title="Permalink"></a></h1><p>Singular.jl allows the creation of submodules of a free module over a Singular polynomial ring, given by a finite generating set. These are internally stored as a list of elements of a free module over a polynomial ring <span>$R$</span>. This list of generators can also have the property of being a Groebner basis.</p><p>The default finitely generated module type in Singular.jl is the Singular <code>smodule</code> type.</p><p>Module objects have a parent object which represents the class of <span>$R$</span>-modules they belong to, the data for which is given by the polynomial ring <span>$R$</span> over which the modules are defined.</p><p>The types of modules and associated parent objects are given in the following table according to the library providing them.</p><table><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Singular</td><td style="text-align: right"><code>smodule{T}</code></td><td style="text-align: right"><code>Singular.ModuleClass{T}</code></td></tr></table><p>These types are parameterised by the type of elements in the polynomial ring <span>$R$</span>.</p><p>All module types belong directly to the abstract type <code>Module{T}</code> and all the module class parent object types belong to the abstract type <code>Set</code>.</p><h2 id="Module-functionality"><a class="docs-heading-anchor" href="#Module-functionality">Module functionality</a><a id="Module-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Module-functionality" title="Permalink"></a></h2><p>Singular.jl modules implement standard operations one would expect on modules. These include:</p><ul><li>Operations common to all AbstractAlgebra objects, such as <code>parent</code>, <code>base_ring</code>, <code>elem_type</code>, <code>parent_type</code>, <code>parent</code>, <code>deepcopy</code>, etc.</li></ul><p>Below, we describe all of the functionality for Singular.jl modules that is not included in this list of basic operations.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>Given a Singular polynomial ring <span>$R$</span>, the following constructors are available for creating modules.</p><pre><code class="language-julia">Module{T &lt;: Nemo.RingElem}(R::PolyRing{T}, vecs::svector{spoly{T}}...)</code></pre><p>Construct the module over the polynomial ring <span>$R$</span> whose generators are given by the given parameter list of vectors (of length <span>$n$</span>), each component of which is a polynomial. These vectors represent elements of the free module <span>$R^n$</span>.</p><p>Note that <code>Module</code> must be prepended with the package name <code>Singular</code> to disambiguate from <code>Base.Module</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^2 + 1, 2x + 3y, x)

M = Singular.Module(R, v1, v2)</code></pre><h3 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.ngens-Tuple{smodule}" href="#AbstractAlgebra.Generic.ngens-Tuple{smodule}"><code>AbstractAlgebra.Generic.ngens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ngens(I::smodule)</code></pre><p>Return the number of generators in the current representation of the module (as a list of vectors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.rank-Tuple{smodule}" href="#LinearAlgebra.rank-Tuple{smodule}"><code>LinearAlgebra.rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rank(I::smodule)</code></pre><p>Return the rank <span>$n$</span> of the ambient space <span>$R^n$</span> of which this module is a submodule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L30">source</a></section></article><p>Singular.jl overloads the <code>setindex!</code> and <code>getindex</code> functions so that one can access the generators of a module using array notation. Each entry is a vector in <span>$R^n$</span>.</p><pre><code class="language-julia">M[n::Int]</code></pre><article class="docstring"><header><a class="docstring-binding" id="Base.iszero-Tuple{smodule}" href="#Base.iszero-Tuple{smodule}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iszero(p::smodule)</code></pre><p>Return <code>true</code> if this is algebraically the zero module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L50">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-none">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^2 + 1, 2x + 3y, x)

M = Singular.Module(R, v1, v2)

iszero(M) == false
M[1] == v1
n = rank(M)
d = ngens(M)</code></pre><h3 id="Standard-basis"><a class="docs-heading-anchor" href="#Standard-basis">Standard basis</a><a id="Standard-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-basis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Statistics.std-Tuple{smodule}" href="#Statistics.std-Tuple{smodule}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">std(I::smodule; complete_reduction::Bool=false)</code></pre><p>Compute the Groebner basis of the module <span>$I$</span>. If <code>complete_reduction</code> is set to <code>true</code>, the result is unique, up to permutation of the generators and multiplication by constants. If not, only the leading terms are unique (up to permutation of the generators and multiplication by constants, of course). Presently the polynomial ring used must be over a field or over the Singular integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.lift_std-Tuple{smodule}" href="#Singular.lift_std-Tuple{smodule}"><code>Singular.lift_std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lift_std(M::smodule)</code></pre><p>computes the Groebner base G of M and the transformation matrix T such that (Matrix(G) = Matrix(M) * T)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Singular.lift_std_syz-Tuple{smodule}" href="#Singular.lift_std_syz-Tuple{smodule}"><code>Singular.lift_std_syz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lift_std_syz(M::smodule)</code></pre><p>computes the Groebner base G of M, the transformation matrix T and the syzygies of M. Returns G,T,S (Matrix(G) = Matrix(M) * T, 0=Matrix(M)*Matrix(S))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L313">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^2 + 1, 2x + 3y, x)
v3 = x*v1 + y*v2 + vector(R, x, y + 1, y^2)

M = Singular.Module(R, v1, v2, v3)

G = std(M; complete_reduction=true)</code></pre><h3 id="Reduction"><a class="docs-heading-anchor" href="#Reduction">Reduction</a><a id="Reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.reduce-Tuple{smodule, smodule}" href="#Base.reduce-Tuple{smodule, smodule}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>reduce(M::smodule, G::smodule) Return a submodule whose generators are the generators of <span>$M$</span> reduced by the submodule <span>$G$</span>. The submodule <span>$G$</span> is required to be given by a Groebner basis. The returned submodule will have the same number of generators as <span>$M$</span>, even if they are zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L149">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])

julia&gt; v1 = vector(R, R(0), z, -y)
-y*gen(3)+z*gen(2)

julia&gt; v2 = vector(R, -z, R(0), x)
x*gen(3)-z*gen(1)

julia&gt; v3 = vector(R, y, x, R(0))
x*gen(2)+y*gen(1)

julia&gt; v = y*v1+x*v2+z*v3
x^2*gen(3)-y^2*gen(3)+x*z*gen(2)-x*z*gen(1)+y*z*gen(2)+y*z*gen(1)

julia&gt; M = Singular.Module(R, v1, v2, v3)
Singular Module over Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), with Generators:
-y*gen(3)+z*gen(2)
x*gen(3)-z*gen(1)
x*gen(2)+y*gen(1)

julia&gt; B = std(M; complete_reduction=true)
Singular Module over Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), with Generators:
y*gen(3)-z*gen(2)
x*gen(2)+y*gen(1)
x*gen(3)-z*gen(1)
y*z*gen(1)

julia&gt; V = Singular.Module(R, v)
Singular Module over Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), with Generators:
x^2*gen(3)-y^2*gen(3)+x*z*gen(2)-x*z*gen(1)+y*z*gen(2)+y*z*gen(1)

julia&gt; reduce(V,B)
Singular Module over Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), with Generators:
0
</code></pre><h3 id="Syzygies"><a class="docs-heading-anchor" href="#Syzygies">Syzygies</a><a id="Syzygies-1"></a><a class="docs-heading-anchor-permalink" href="#Syzygies" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Singular.syz-Tuple{smodule}" href="#Singular.syz-Tuple{smodule}"><code>Singular.syz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">syz(M::smodule)</code></pre><p>Compute the module of syzygies of the given module. This will be given as a set of generators in an ambient space <span>$R^n$</span>, where <span>$n$</span> is the number of generators in <span>$M$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L169">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, (x + 1)*y, (x*y + 1)*y, y)
v2 = vector(R, (x + 1)*x, (x*y + 1)*x, x)

M = Singular.Module(R, v1, v2)

Z = syz(M)</code></pre><h3 id="Free-resolutions"><a class="docs-heading-anchor" href="#Free-resolutions">Free resolutions</a><a id="Free-resolutions-1"></a><a class="docs-heading-anchor-permalink" href="#Free-resolutions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Singular.sres-Union{Tuple{T}, Tuple{smodule{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.sres-Union{Tuple{T}, Tuple{smodule{T}, Int64}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.sres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sres{T &lt;: Nemo.RingElem}(I::smodule{T}, max_length::Int)</code></pre><p>Compute a free resolution of the given module <span>$I$</span> of length up to the given maximum length. If <code>max_length</code> is set to zero, a full length free resolution is computed. Each element of the resolution is itself a module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L189">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^2 + 1, 2x + 3y, x)

M = std(Singular.Module(R, v1, v2))

F = sres(M, 0)

M1 = Singular.Matrix(M)
M2 = Singular.Matrix(F[2])

# test we have a complex
iszero(M1*M2)</code></pre><h3 id="Jet-of-module"><a class="docs-heading-anchor" href="#Jet-of-module">Jet of module</a><a id="Jet-of-module-1"></a><a class="docs-heading-anchor-permalink" href="#Jet-of-module" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Singular.jet-Tuple{smodule, Int64}" href="#Singular.jet-Tuple{smodule, Int64}"><code>Singular.jet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>jet(M::smodule, n::Int) Given a module <span>$M$</span> this function truncates the generators of <span>$M$</span> up to degree <span>$n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L229">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^5 + 1, 2x^3 + 3y^2, x^2)

M = Singular.Module(R, v1, v2)
N = jet(M,3)</code></pre><h3 id="Operations-over-local-rings"><a class="docs-heading-anchor" href="#Operations-over-local-rings">Operations over local rings</a><a id="Operations-over-local-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-over-local-rings" title="Permalink"></a></h3><p>If the base ring <code>R</code> is a local ring, a minimal generating set can be computed using the following function</p><article class="docstring"><header><a class="docstring-binding" id="Singular.minimal_generating_set-Tuple{smodule}" href="#Singular.minimal_generating_set-Tuple{smodule}"><code>Singular.minimal_generating_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>minimal<em>generating</em>set(M::smodule) Given a module <span>$M$</span> in ring <span>$R$</span> with local ordering, this returns an array containing the minimal generators of <span>$M$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/0c729e05becd2b424d04a3dfcdaac36c281497dc/src/module/module.jl#L247">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;]; ordering=:negdegrevlex)

has_local_ordering(R) == true

v1 = vector(R, x, y^2)
v2 = vector(R, y - x, y - y^2)
v3 = v1 + v2

M = Singular.Module(R, v1, v2, v3)

min = minimal_generating_set(M)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ideal/">« Ideals</a><a class="docs-footer-nextpage" href="../vector/">Free modules and vectors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 19 May 2021 13:02">Wednesday 19 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
