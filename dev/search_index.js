var documenterSearchIndex = {"docs":
[{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"polynomial/#Multivariate-polynomials","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.jl allows the creation of multivariate polynomials over any of the coefficient rings described above.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The default multivariate polynomial type in Singular.jl is the Singular spoly type.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The associated polynomial ring is represented by a parent object which can be constructed by a call to the polynomial_ring constructor.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The types of the polynomial ring parent objects and elements thereof are given in the following table according to the library providing them.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Library Element type Parent type\nSingular spoly{T} Singular.PolyRing{T}","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"These types are parameterised by the type of elements in the coefficient ring of the polynomials.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"All polynomial types belong directly to the abstract type MPolyRingElem and all the polynomial ring parent object types belong to the abstract type MPolyRing.","category":"page"},{"location":"polynomial/#Multivariate-polynomial-functionality","page":"Multivariate polynomials","title":"Multivariate polynomial functionality","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.jl polynomials provides all the Multivariate Polynomial Ring functionality described by AbstractAlgebra.jl.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"In particular, Singular polynomials are sparse distributed, but do not have random access. Instead, they implement iterator access to terms. This is due to their storage in a linked list, for efficient implementation of Groebner basis algorithms.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Some polynomial rings may also implement part of the Euclidean Ring interface, where this is appropriate.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Below, we describe the functionality that is specific to the Singular multivariate polynomials that is not documented in the general multivariate interface.","category":"page"},{"location":"polynomial/#Constructors","page":"Multivariate polynomials","title":"Constructors","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"polynomial_ring(R::Union{Ring, Field}, s::AbstractVector{<:VarName};\n               cached::Bool = true, ordering = :degrevlex,\n               ordering2::Symbol = :comp1min, degree_bound::Int = 0)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Returns a tuple, S x consisting of a multivariate polynomial ring S and an array x of variables (from which polynomials can be constructed). The ring R must be a valid Singular coefficient ring, or any Nemo/AbstractAlgebra coefficient ring. The array s must be a list of strings corresponding to how the variables will be printed. By default, there will only be one Singular polynomial ring in the system for each combination of coefficient ring, list of variable names, ordering and degree bound. This is accomplished by making use of a global cache. If this is not the desired behaviour, false can be passed to the optional argument cached.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"If the first ordering ordering is specified as a symbol, then two orderings can be specified, one for term ordering of the polynomials, and another for ordering of module components. They can occur in either order, the first taking precedence over the other, when the polynomials are used to represent module generators. If either is not specified, the indicated default is used. The options for polynomial term ordering are, :lex, :deglex, :degrevlex, :neglex, :negdeglex and :negdegrevlex, and the options for module component ordering are comp1min and comp1max.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"If the first ordering ordering is specified as a non-symbol, the second ordering ordering2 will be ignored. For specifying non-symbolic term orderings, please see the Term orderings section below.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"If one has an a priori bound on the degree in each variable of a polynomial (including for all intermediate computations in this ring), one can specify it using the degree_bound optional parameter. Singular may then be able to use a more efficient representation internally, which will use less memory and allow for faster arithmetic. By default, Singular uses a bound of 16 bits internally for the exponent of each variable, however this is a signed value, so that the default is for nonnegative exponents that fit in 15 bits.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Note that internally, Singular may use a higher bound than specified, if it will not increase the amount of storage required.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"julia> R, (x, y, z) = polynomial_ring(ZZ, [\"x\", \"y\", \"z\"])\n(Singular polynomial ring (ZZ),(x,y,z),(dp(3),C), spoly{n_Z}[x, y, z])\n\njulia> S, vars = polynomial_ring(QQ, [\"x\", \"y\"]; ordering=:deglex)\n(Singular polynomial ring (QQ),(x,y),(Dp(2),C), spoly{n_Q}[x, y])\n\njulia> T, x = polynomial_ring(ZZ, [\"x$i\" for i in 1:5];\n              ordering=:comp1max, ordering2=:degrevlex, degree_bound=5)\n(Singular polynomial ring (ZZ),(x1,x2,x3,x4,x5),(c,dp(5),L(5)), spoly{n_Z}[x1, x2, x3, x4, x5])","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"See also the convenience macros below for simple use cases.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The following function allows creating a Singular polynomial ring from a given polynomial ring of type AbstractAlgebra.Generic.MPolyRing:","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"polynomial_ring(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true, ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min, degree_bound::Int = 0)  where {T <: RingElement}","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Polynomials can be constructed using arithmetic operations on the generators, but this can be extremely inefficient. For this purpose, Singular polynomials support construction using a build context, as described in the AbstractAlgebra documentation:","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])\n\njulia> C = MPolyBuildCtx(R)\nBuilder for an element of Singular polynomial ring (ZZ),(x,y),(dp(2),C)\n\njulia> push_term!(C, ZZ(1), [1, 2])\nx*y^2\n\njulia> push_term!(C, ZZ(3), [1, 1])\nx*y^2 + 3*x*y\n\njulia> push_term!(C, -ZZ(1), [0, 1])\nx*y^2 + 3*x*y - y\n\njulia> f = finish(C)\nx*y^2 + 3*x*y - y","category":"page"},{"location":"polynomial/#Term-orderings","page":"Multivariate polynomials","title":"Term orderings","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"A general term ordering can be constructed as a product of one or more of the following block orderings.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_lp(nvars::Int = 1)","category":"page"},{"location":"polynomial/#Singular.ordering_lp","page":"Multivariate polynomials","title":"Singular.ordering_lp","text":"ordering_lp(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the lexicographical ordering (:lex).\n\n\n\n\n\n","category":"function"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_rp(nvars::Int = 1)","category":"page"},{"location":"polynomial/#Singular.ordering_rp","page":"Multivariate polynomials","title":"Singular.ordering_rp","text":"ordering_rp(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the reverse lexicographical ordering (:revlex).\n\n\n\n\n\n","category":"function"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_dp(nvars::Int = 1)","category":"page"},{"location":"polynomial/#Singular.ordering_dp","page":"Multivariate polynomials","title":"Singular.ordering_dp","text":"ordering_dp(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the degree reverse lexicographical ordering (:degrevlex).\n\n\n\n\n\n","category":"function"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_Dp(nvars::Int = 1)","category":"page"},{"location":"polynomial/#Singular.ordering_Dp","page":"Multivariate polynomials","title":"Singular.ordering_Dp","text":"ordering_Dp(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the degree lexicographical ordering (:deglex).\n\n\n\n\n\n","category":"function"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_wp(w::Vector{Int})","category":"page"},{"location":"polynomial/#Singular.ordering_wp-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_wp","text":"ordering_wp(w::Vector{Int})\n\nRepresents a block of variables with the weighted reverse lexicographical ordering. The weight vector w is expected to consist of positive integers only.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_Wp(w::Vector{Int})","category":"page"},{"location":"polynomial/#Singular.ordering_Wp-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_Wp","text":"ordering_Wp(w::Vector{Int})\n\nRepresents a block of variables with the weighted lexicographical ordering. The weight vector is expected to consist of positive integers only.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_ls(nvars::Int = 1)","category":"page"},{"location":"polynomial/#Singular.ordering_ls","page":"Multivariate polynomials","title":"Singular.ordering_ls","text":"ordering_ls(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the negative lexicographical ordering (:neglex).\n\n\n\n\n\n","category":"function"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_rs(nvars::Int = 1)","category":"page"},{"location":"polynomial/#Singular.ordering_rs","page":"Multivariate polynomials","title":"Singular.ordering_rs","text":"ordering_rs(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the negative reverse lexicographical ordering (:negrevlex).\n\n\n\n\n\n","category":"function"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_ds(nvars::Int = 1)","category":"page"},{"location":"polynomial/#Singular.ordering_ds","page":"Multivariate polynomials","title":"Singular.ordering_ds","text":"ordering_ds(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the negative degree reverse lexicographical ordering (:negdegrevlex).\n\n\n\n\n\n","category":"function"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_Ds(nvars::Int = 1)","category":"page"},{"location":"polynomial/#Singular.ordering_Ds","page":"Multivariate polynomials","title":"Singular.ordering_Ds","text":"ordering_Ds(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the negative degree reverse lexicographical ordering (:negdeglex).\n\n\n\n\n\n","category":"function"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_ws(w::Vector{Int})","category":"page"},{"location":"polynomial/#Singular.ordering_ws-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_ws","text":"ordering_ws(w::Vector{Int})\n\nRepresents a block of variables with the general weighted reverse lexicographical ordering. The weight vector w is expected to have a nonzero first entry.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_Ws(w::Vector{Int})","category":"page"},{"location":"polynomial/#Singular.ordering_Ws-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_Ws","text":"ordering_Ws(w::Vector{Int})\n\nRepresents a block of variables with the general weighted lexicographical ordering. The weight vector w is expected to have a nonzero first entry.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_a(w::Vector{Int})","category":"page"},{"location":"polynomial/#Singular.ordering_a-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_a","text":"ordering_a(w::Vector{Int})\n\nRepresents an extra weight vector that may precede any monomial ordering. An extra weight vector does not define a monomial ordering by itself: it can only be used in combination with other orderings to insert an extra line of weights into the ordering matrix.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_M(m::Matrix{Int}; checked::Bool = true)","category":"page"},{"location":"polynomial/#Singular.ordering_M-Tuple{Matrix{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_M","text":"ordering_M(m::Matrix{Int}; checked::Bool = true)\n\nRepresents a block of variables with a general matrix ordering. The matrix m is expected to be invertible, and this is checked by default.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_C()","category":"page"},{"location":"polynomial/#Singular.ordering_C-Tuple{}","page":"Multivariate polynomials","title":"Singular.ordering_C","text":"ordering_C()\n\nRepresents an ascending ordering on vector components gen(1) < gen(2) < .... All monomial block orderings preceding the component ordering have higher precedence, and all succeeding monomial block orderings have lower precedence. It is not necessary to specify this ordering explicitly since it appended automatically to an ordering lacking a component specification.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"ordering_c()","category":"page"},{"location":"polynomial/#Singular.ordering_c-Tuple{}","page":"Multivariate polynomials","title":"Singular.ordering_c","text":"ordering_c()\n\nRepresents a descending ordering on vector components gen(1) > gen(2) > .... All monomial block orderings preceding the component ordering have higher precedence, and all succeeding monomial block orderings have lower precedence.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"polynomial_ring(QQ, \"x\".*string.(1:8), ordering = ordering_M([1 2; 3 5])*ordering_lp(3)*ordering_wp([1, 2, 3]))\n\npolynomial_ring(QQ, \"x\".*string.(1:5), ordering = ordering_dp(3)*ordering_dp())","category":"page"},{"location":"polynomial/#Polynomial-ring-macros","page":"Multivariate polynomials","title":"Polynomial ring macros","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"For convenience, we provide some macros for constructing polynomial rings and injecting the variables into scope. These are easier to use, but have some limitations. In particular, they can only be used at the top level by the user, and cannot be used programmatically or in library code (it is not possible to inject an arbitrary number of variables into scope inside a function).","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The macros are designed for simple use cases, and do not offer the full power of the most general constructor above.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"@polynomial_ring(R, s, n, o)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Given a coefficient ring R, a root variable name, e.g. \"x\", a number of variable n and a polynomial term ordering o, create the variables x1, x2, ..., xn and inject them into scope, and return the corresponding polynomial ring S.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"@polynomial_ring(R, s, n)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"As per the previous macro, with a default of :degrevlex for the polynomial term ordering.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"julia> S = @polynomial_ring(ZZ, \"x\", 5, :deglex)\nSingular polynomial ring (ZZ),(x1,x2,x3,x4,x5),(Dp(5),C)\n\njulia> T = @polynomial_ring(QQ, \"y\", 10)\nSingular polynomial ring (QQ),(y1,y2,y3,y4,y5,y6,y7,y8,y9,y10),(dp(10),C)","category":"page"},{"location":"polynomial/#Basic-manipulation","page":"Multivariate polynomials","title":"Basic manipulation","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"has_global_ordering(R::PolyRing)","category":"page"},{"location":"polynomial/#Singular.has_global_ordering-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.has_global_ordering","text":"has_global_ordering(R::PolyRingUnion)\n\nReturn true if the given ring has a global ordering, i.e. if 1  x for each variable x in the ring. This include :lex, :deglex and :degrevlex orderings.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"has_mixed_ordering(R::PolyRing)","category":"page"},{"location":"polynomial/#Singular.has_mixed_ordering-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.has_mixed_ordering","text":"has_mixed_ordering(R::PolyRingUnion)\n\nReturn true if the given ring has a mixed ordering, i.e. if 1  x_i for a variable x_i and 1x_j for another variable x_j.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"has_local_ordering(R::PolyRing)","category":"page"},{"location":"polynomial/#Singular.has_local_ordering-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.has_local_ordering","text":"has_local_ordering(R::PolyRingUnion)\n\nReturn true if the given ring has a local ordering, i.e. if 1  x for all variables x.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"degree_bound(R::PolyRing)","category":"page"},{"location":"polynomial/#Singular.degree_bound-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.degree_bound","text":"degree_bound(R::PolyRing)\n\nReturn the internal degree bound in each variable, enforced by Singular. This is the largest positive value any degree can have before an overflow will occur. This internal bound may be higher than the bound requested by the user via the degree_bound parameter of the polynomial_ring constructor.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"total_degree(p::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.total_degree-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.total_degree","text":"total_degree(p::spoly)\n\nReturn the total degree (largest sum of exponents of any monomial) of p.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"order(p::spoly)","category":"page"},{"location":"polynomial/#GroupsCore.order-Tuple{spoly}","page":"Multivariate polynomials","title":"GroupsCore.order","text":"order(p::spoly)\n\nReturn the order of p.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"julia> R = @polynomial_ring(ZZ, \"x\", 3)\nSingular polynomial ring (ZZ),(x1,x2,x3),(dp(3),C)\n\njulia> n = nvars(R)\n3\n\njulia> has_global_ordering(R) == true\ntrue\n\njulia> c = characteristic(R)\n0\n\njulia> L = degree_bound(R)\n1048575\n\njulia> exps = leading_exponent_vector(x1*x2 + 3x1*x2^2 + x3 + 2)\n3-element Vector{Int64}:\n 1\n 2\n 0\n\njulia> deg = total_degree(x1*x2 + 3x1*x2^2 + x3 + 2)\n3\n\njulia> ord = order(x1*x2 + 3x1*x2^2 + x3 + 2)\n0","category":"page"},{"location":"polynomial/#Differential-functions","page":"Multivariate polynomials","title":"Differential functions","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Working over any coefficient ring, basic functionality involving differential operations is available.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"jet(::spoly{T}, ::Int) where T <: Nemo.RingElem","category":"page"},{"location":"polynomial/#Singular.jet-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.jet","text":"jet(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the truncation of x up to degree n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"derivative(::spoly{T}, ::Int) where T <: Nemo.RingElem","category":"page"},{"location":"polynomial/#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"AbstractAlgebra.derivative","text":"derivative(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable of index n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"derivative(::spoly{T}, ::spoly{T}) where T <: Nemo.RingElem","category":"page"},{"location":"polynomial/#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"AbstractAlgebra.derivative","text":"derivative(x::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable v.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"jacobian_ideal(::spoly{T}) where T <: Nemo.RingElem","category":"page"},{"location":"polynomial/#Singular.jacobian_ideal-Union{Tuple{spoly{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.jacobian_ideal","text":"jacobian_ideal(p::spoly{T}) where T <: Nemo.RingElem\n\nReturn the ideal generated by all partial derivatives of x.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"jacobian_matrix(p::spoly{T}) where T <: Nemo.RingElem","category":"page"},{"location":"polynomial/#Singular.jacobian_matrix-Union{Tuple{spoly{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.jacobian_matrix","text":"jacobian_matrix(p::spoly{T}) where T <: Nemo.RingElem\n\nReturn the column matrix fracpartial ppartial x_i_i of partial derivatives.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"jacobian_matrix(A::Vector{spoly{T}}) where T <: Nemo.RingElem","category":"page"},{"location":"polynomial/#Singular.jacobian_matrix-Union{Tuple{Array{spoly{T}, 1}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.jacobian_matrix","text":"jacobian_matrix(a::Vector{spoly{T}}) where T <: Nemo.RingElem\n\nReturn the matrix fracpartial a_ipartial x_j_ij of partial derivatives.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])\n\njulia> f = x^2*y*z + z^2*x + x*y*z\nx^2*y*z + x*y*z + x*z^2\n\njulia> g = jet(f, 3)\nx*y*z + x*z^2\n\njulia> derivative(f, 1)\n2*x*y*z + y*z + z^2\n\njulia> derivative(f, y)\nx^2*z + x*z\n\njulia> J = jacobian_ideal(f)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(dp(3),C) with generators (2*x*y*z + y*z + z^2, x^2*z + x*z, x^2*y + x*y + 2*x*z)\n\njulia> Jf1 = jacobian_matrix(f)\n[2*x*y*z + y*z + z^2\nx^2*z + x*z\nx^2*y + x*y + 2*x*z]\n\njulia> Jf2 = jacobian_matrix([f, g])\n[2*x*y*z + y*z + z^2, x^2*z + x*z, x^2*y + x*y + 2*x*z\ny*z + z^2, x*z, x*y + 2*x*z]","category":"page"},{"location":"polynomial/#Content-and-primitive-part","page":"Multivariate polynomials","title":"Content and primitive part","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"When coefficient rings have a meaningful GCD function, the following functions are available.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.primpart(x::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.primpart-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.primpart","text":"primpart(x::SPolyUnion)\n\nReturn the primitive part of the polynomial, i.e. the polynomial divided by the GCD of its coefficients.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.content(x::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.content-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.content","text":"content(x::SPolyUnion)\n\nReturn the content of the polynomial, i.e. the GCD of its coefficients.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"julia> R = @polynomial_ring(ZZ, \"x\", 2)\nSingular polynomial ring (ZZ),(x1,x2),(dp(2),C)\n\njulia> f = 3x1^2 + 3x1*x2 + 6x2^2\n3*x1^2 + 3*x1*x2 + 6*x2^2\n\njulia> p = primpart(f)\nx1^2 + x1*x2 + 2*x2^2\n\njulia> c = content(f)\n3","category":"page"},{"location":"polynomial/#Homogeneous-polynomials","page":"Multivariate polynomials","title":"Homogeneous polynomials","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"homogenize(p::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem","category":"page"},{"location":"polynomial/#Singular.homogenize-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.homogenize","text":"homogenize(p::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nMultiply each monomial in p by a suitable power of the variable v and return the corresponding homogeneous polynomial. The variable v must have weight 1.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Multivariate-Factorisation","page":"Multivariate polynomials","title":"Multivariate Factorisation","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"For the Singular base fields QQ and Fp a function to compute a squarefree factorization is available.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"julia> R = @polynomial_ring(QQ, \"x\", 4)\nSingular Polynomial Ring (QQ),(x1,x2,x3,x4),(dp(4),C)\n\njulia> f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2;\n\njulia> Fac = factor(f)\n123 * (x4^5 + 57*x2^3)^3 * (x1^2 + x1 + 1)^2 * (x2*x3 + x1)^2","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"For the Singular base rings QQ, ZZ and Fp a function to compute the multivariate factorization is available.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"julia> R = @polynomial_ring(ZZ, \"x\", 4)\nSingular Polynomial Ring (ZZ),(x1,x2,x3,x4),(dp(4),C)\n\njulia> f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2;\n\njulia> Fac = factor(f)\n123 * (x2*x3 + x1)^2 * (x4^5 + 57*x2^3)^3 * (x1^2 + x1 + 1)^2","category":"page"},{"location":"polynomial/#Change-of-coefficient-rings","page":"Multivariate polynomials","title":"Change of coefficient rings","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"It is possible to change the coefficient ring of a given polynomial p via the function 'changebasering'.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"julia> R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])\n\njulia> p = x^5 + y^3+1\nx^5 + y^3 + 1\n\njulia> p2 = change_base_ring(QQ, p)\nx^5 + y^3 + 1\n\njulia> parent(p2)\nSingular polynomial ring (QQ),(x,y),(dp(2),C)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"It also possible to work with Nemo rings by casting to a suitable Singular type via CoefficientRing.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n\np = x^5 + y^3+1\n\np2 change_base_ring(CoefficientRing(Nemo.QQ), p)","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"modn/#Integers-mod-n","page":"Integers mod n","title":"Integers mod n","text":"","category":"section"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Integers mod n are implemented via the Singular n_Zn type for any positive modulus that can fit in a Julia Int.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"The associated ring of integers mod n is represented by a parent object which can be constructed by a call to the residue_ring constructor.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"The types of the parent objects and elements of the associated rings of integers modulo n are given in the following table according to the library providing them.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Library Element type Parent type\nSingular n_Zn Singular.N_ZnRing","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"All integer mod n element types belong directly to the abstract type RingElem and all the parent object types belong to the abstract type Ring.","category":"page"},{"location":"modn/#Integer-mod-n-functionality","page":"Integers mod n","title":"Integer mod n functionality","text":"","category":"section"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Singular.jl integers modulo n provide all the AbstractAlgebra ring and residue ring functionality.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/ring","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/residue","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Parts of the Euclidean Ring interface may also be implemented, though Singular will report an error if division is meaningless (even after cancelling zero divisors).","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Below, we describe the functionality that is specific to the Singular integers mod n ring and not already listed at the given links.","category":"page"},{"location":"modn/#Constructors","page":"Integers mod n","title":"Constructors","text":"","category":"section"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Given a ring R of integers modulo n, we also have the following coercions in addition to the standard ones expected.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"R(n::n_Z)\nR(n::ZZRingElem)","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Coerce a Singular or Flint integer value into the ring.","category":"page"},{"location":"modn/#Basic-manipulation","page":"Integers mod n","title":"Basic manipulation","text":"","category":"section"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Examples","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"julia> R = residue_ring(ZZ, 26)\nResidue Ring of Integer Ring modulo 26\n\njulia> a = R(5)\n5\n\njulia> is_unit(a)\ntrue\n\njulia> c = characteristic(R)\n26","category":"page"},{"location":"qring/","page":"Quotient Rings","title":"Quotient Rings","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"qring/#Quotient-Rings","page":"Quotient Rings","title":"Quotient Rings","text":"","category":"section"},{"location":"qring/","page":"Quotient Rings","title":"Quotient Rings","text":"Quotient rings Q = RI in Singular.jl are constructed with the constructor QuotientRing(R, I). The input ideal I to the constructor must be a Groebner basis. The R-ideal I may be recovered as quotient_ideal(Q).","category":"page"},{"location":"qring/","page":"Quotient Rings","title":"Quotient Rings","text":"is_quotient_ring(R::PolyRingUnion)\nquotient_ideal(Q::PolyRing{T}) where T <: Nemo.RingElem","category":"page"},{"location":"qring/#Singular.is_quotient_ring-Tuple{Union{LPRing{T}, PluralRing{T}, PolyRing{T}} where T<:AbstractAlgebra.RingElem}","page":"Quotient Rings","title":"Singular.is_quotient_ring","text":"is_quotient_ring(R::PolyRingUnion)\n\nReturn true if the given ring is the quotient of a polynomial ring with a non - zero ideal.\n\n\n\n\n\n","category":"method"},{"location":"qring/#Singular.quotient_ideal-Union{Tuple{PolyRing{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Quotient Rings","title":"Singular.quotient_ideal","text":"quotient_ideal(Q::PolyRing{T}) where T <: Nemo.RingElem\n\nReturn I for a given quotient ring Q = R/I.\n\n\n\n\n\n","category":"method"},{"location":"qring/","page":"Quotient Rings","title":"Quotient Rings","text":"Examples","category":"page"},{"location":"qring/","page":"Quotient Rings","title":"Quotient Rings","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]);\n\njulia> is_quotient_ring(R)\nfalse\n\njulia> Q1, (x, y) = QuotientRing(R, Ideal(R, x^2+y^2));\n\njulia> is_quotient_ring(Q1)\ntrue\n\njulia> quotient_ideal(Q1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + y^2)\n\njulia> Q2, (x, y) = QuotientRing(Q1, std(Ideal(Q1, x*y)));\n\njulia> quotient_ideal(Q2)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x*y, y^3, x^2 + y^2)\n\njulia> base_ring(quotient_ideal(Q1)) == base_ring(quotient_ideal(Q2))\ntrue","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"rational/#Rational-field","page":"Rational field","title":"Rational field","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Singular.jl provides rational numbers via Singular's n_Q type.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"There is a constant parent object representing the field of rationals, called QQ in Singular.jl. It is defined by QQ = Rationals(), which calls the constructor for the unique field of rationals in Singular.","category":"page"},{"location":"rational/#Rational-functionality","page":"Rational field","title":"Rational functionality","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"The rationals in Singular.jl provide all functionality for fields and fraction fields described by AbstractAlgebra.jl.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/fraction","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"We describe here only the extra functionality provided by Singular that is not already described in those interfaces.","category":"page"},{"location":"rational/#Constructors","page":"Rational field","title":"Constructors","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"In addition to the standard constructors required for the interfaces listed above, Singular.jl provides the following constructors.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"QQ(n::n_Z)\nQQ(n::ZZRingElem)","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Construct a Singular rational from the given integer n.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"julia> f = QQ(-12, 7)\n-12//7\n\njulia> h = numerator(f)\n-12\n\njulia> k = denominator(f)\n7\n\njulia> m = abs(f)\n12//7\n\njulia> a = QQ(12, 7)\n12//7\n\njulia> b = QQ(-3, 5)\n-3//5\n\njulia> a > b\ntrue\n\njulia> a != b\ntrue\n\njulia> a > 1\ntrue\n\njulia> 5 >= b\ntrue","category":"page"},{"location":"rational/#Rational-reconstruction","page":"Rational field","title":"Rational reconstruction","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"reconstruct(::n_Z, ::n_Z)","category":"page"},{"location":"rational/#Nemo.reconstruct-Tuple{n_Z, n_Z}","page":"Rational field","title":"Nemo.reconstruct","text":"reconstruct(x::n_Z, y::n_Z)\n\nGiven x modulo y, find rs such that x equiv rs pmody for values r and s satisfying the bound y  2(r + 1)(s + 1).\n\n\n\n\n\n","category":"method"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"The following ad hoc versions of the same function also exist.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"reconstruct(::n_Z, ::Integer)\nreconstruct(::Integer, ::n_Z)","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"julia> q1 = reconstruct(ZZ(7), ZZ(3))\n1\n\njulia> q2 = reconstruct(ZZ(7), 5)\n-1//2","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"matrix/#Matrices","page":"Matrices","title":"Matrices","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Singular internally allows for matrices over polynomial rings to be created extremely efficiently from ideals and modules (often without copying data). This allows for introspection of modules and operations that can be expressed in terms of matrices (e.g. composition of R-module homomorphisms) to be computed, at a low level.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"The default matrix type in Singular.jl is the smatrix type.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Matrix objects have a parent object which represents the space of matrices they belong to, the data for which is given by the polynomial ring R over which the matrices are defined, and the number of rows and columns of the matrices in the space.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"The types of matrices and associated parent objects are given in the following table according to the library providing them.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Library Element type Parent type\nSingular smatrix{T} Singular.matrix_space{T}","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"These types are parameterised by the type of elements in the polynomial ring R over which the matrices are defined.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"All matrix types belong directly to the abstract type SetElem and all the matrix space parent object types belong to the abstract type Set.","category":"page"},{"location":"matrix/#Matrix-functionality","page":"Matrices","title":"Matrix functionality","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Singular.jl matrices implement standard operations one would expect. These include:","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"The following parts of the Matrix interface from AbstractAlgebra are also implemented:","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"construction: identity_matrix, identity_matrix\narithmetic operations: +, -, *\ncomparison: ==\nmanipulation: nrows, ncols, getindex, setindex!, transpose, iszero","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"julia> R, (x, y, u, v, w) = Singular.polynomial_ring(Singular.QQ, [\"x\", \"y\", \"u\", \"v\", \"w\"])\n(Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C), spoly{n_Q}[x, y, u, v, w])\n\njulia> identity_matrix(R, 4)\n[1, 0, 0, 0\n0, 1, 0, 0\n0, 0, 1, 0\n0, 0, 0, 1]\n\njulia> zero_matrix(R, 3, 8)\n[0, 0, 0, 0, 0, 0, 0, 0\n0, 0, 0, 0, 0, 0, 0, 0\n0, 0, 0, 0, 0, 0, 0, 0]\n\njulia> M = identity_matrix(R, 4)\n[1, 0, 0, 0\n0, 1, 0, 0\n0, 0, 1, 0\n0, 0, 0, 1]\n\njulia> nrows(M)\n4\n\njulia> ncols(M)\n4\n\njulia> iszero(M)\nfalse\n\njulia> M[3, 4] = x*y + 5*u*w\nx*y + 5*u*w\n\njulia> N = transpose(M)\n[1, 0, 0, 0\n0, 1, 0, 0\n0, 0, 1, 0\n0, 0, x*y + 5*u*w, 1]\n\njulia> N[4, 3]\nx*y + 5*u*w","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"nemo/#Nemo-rings-and-fields","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"","category":"section"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Any type that satisfies AbstractAlgebra.jl Ring or Field interface, such as all Nemo ring and field types, can be used as coefficient rings in Singular.jl. These are implemented via the Singular n_RingElem{T} and n_FieldElem{T} types, parameterised by the given Nemo/AbstractAlgebra element type.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"The associated parent object of type N_Ring{T} or N_Field{T} can be constructed by a call to the CoefficientRing constructor. In practice, however, this constructor is only used internally, and Nemo rings and fields work directly as Singular coefficient rings, and all the coercions and ad hoc functions that one would expect to be present are implemented.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"The Singular.jl n_RingElem (resp. n_FieldElem) types belong directly to the abstract type RingElem (resp. FieldElem) and their parent object types belong to the abstract type Ring (resp. Field). We also have the following type definitions for compatibility with previous version of Singular.jl.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"const N_unknown{T} = Union{N_Ring{T}, N_Field{T}}\nconst n_unknown{T} = Union{n_RingElem{T}, n_FieldElem{T}}","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"All of the Singular polynomial arithmetic should work for any Nemo ring and everything, including ideals, modules, standard basis, syzygies, resolutions, etc., should work with any Nemo field.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Specialised efficient wrappers exist for certain Nemo coefficient ring types.","category":"page"},{"location":"nemo/#Nemo-ring-functionality","page":"Nemo rings and fields","title":"Nemo ring functionality","text":"","category":"section"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Singular.jl foreign ring types provide all of the AbstractAlgebra defined ring and some field functionality.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/ring","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Parts of the Euclidean Ring interface may also be implemented, though Singular will report an error if division is meaningless (even after cancelling zero divisors).","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Below, we describe the functionality that is specific to the Singular foreign ring interface that is not already listed at the given links.","category":"page"},{"location":"nemo/#Constructors","page":"Nemo rings and fields","title":"Constructors","text":"","category":"section"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Given an AbstractAlgebra compatible ring R, e.g. a Nemo ring, we have the following constructor, which returns the associated Singular.jl coefficient ring.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"CoefficientRing(R::Ring)","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"If there are generators to be coerced from Nemo/AbstractAlgebra into corresponding elements, the Singular.jl coefficient ring can be used to coerce them to a Singular n_RingElem or n_FieldElem element.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Examples","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"R, x = Nemo.polynomial_ring(ZZ, \"x\")\nS = CoefficientRing(R)\nt = S(x)","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Note that it is unlikely that a user directly needs to construct the Singular coefficient ring from a Nemo ring, since the Singular.jl constructors are designed to accept Nemo coefficient rings directly. Singular.jl automatically constructs the required Singular coefficient ring and makes use of it.","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"caller/#Interpreter-Functionality","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"","category":"section"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"Singular.jl provides limited access to the functionality of the Singular interpreter and its associated standard library procedures. The following features of the Singular language are not supported:","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"The singular language allows arbitrary attributes to be attached to each object. These are not supported because Singular.jl works with the raw kernel types ring, poly, ideal, etc. that do not have attributes.\nMaps between polynomial rings cannot be effectively communicated between the Singular language and Singular.jl because the Singular language tracks the preimage ring by name only and the rings in Singular.jl do not have names.\nVery few library procedures work with Nemo rings and fields.","category":"page"},{"location":"caller/#Calling-a-Library-Procedure","page":"Interpreter Functionality","title":"Calling a Library Procedure","text":"","category":"section"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"In general, if we have a procedure sort in general.lib, then the corresponding function in Singular.jl is called Singular.LibGeneral.sort. The full list of libraries included can be viewed by typing Singular.Lib at the REPL and double pressing the tab key.","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"One issue that comes up in calling library procedures is the implicit argument basering that all procedures receive in the Singular language. Singular.jl tries to infer the base ring from the arguments provided to the function. When this fails or is simply not possible, the user can always provide a base ring by passing it in as the first argument to the Singular.jl function. Note that if the first argument to the Singular.jl version of a library procedure is a polynomial or non-commutative ring, then this is automatically assumed to be the base ring. Hence, if a procedure in the Singular language takes a ring as a first argument, you will have to pass that ring as the second argument after specifying the base ring in the first argument.","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"Examples","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"This example illustrates passing Singular lists and providing the base ring.","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"julia> r0, (x, y, z, t) = polynomial_ring(QQ, [\"x\", \"y\", \"z\", \"t\"], ordering=ordering_lp());\n\njulia> Singular.LibGeneral.sort([x, y])\nERROR: `intvec` may be passed in as Vector{Int}. All other vectors (`list` in Singular) must be passed in as Vector{Any} along with an explicit base ring in the first argument\n\njulia> Singular.LibGeneral.sort(r0, Any[x, y])\n2-element Vector{Vector}:\n spoly{n_Q}[y, x]\n [2, 1]","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"This example illustrates the base ring inference:","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"julia> AA, (x, y, z, t) = polynomial_ring(QQ, [\"x\", \"y\", \"z\", \"t\"]);\n\njulia> D = zero_matrix(AA, 4, 4);\n\njulia> D[1,2] = -z; D[1,3] = 2*x; D[2,3] = -2*y;\n\njulia> A, (x, y, z, t) = GAlgebra(AA, 1, D);\n\njulia> Singular.LibNctools.isCentral(x)   # base ring A is inferred from x\n0\n\njulia> Singular.LibCentral.center(A, 3)   # base ring cannot be inferred from the plain Int 3\nSingular ideal over Singular G-Algebra (QQ),(x,y,z,t),(dp(4),C) with generators (t, 4*x*y + z^2 - 2*z)","category":"page"},{"location":"caller/#Global-Interpreter-Variables","page":"Interpreter Functionality","title":"Global Interpreter Variables","text":"","category":"section"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"The function Singular.call_interpreter can be used to execute arbitrary strings inside the Singular interpreter, and the function Singular.lookup_library_symbol fetches results from the interpreter.","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"Singular.lookup_library_symbol(package::String, name::String)","category":"page"},{"location":"caller/#Singular.lookup_library_symbol-Tuple{String, String}","page":"Interpreter Functionality","title":"Singular.lookup_library_symbol","text":"lookup_library_symbol(package::String, name::String)\n\nAttempt to look up a symbol in a particular Singular interpreter package and return its value as a usable Singular.jl object. The package at the top level is called \"Top\", and ring dependent objects are contained in their basering, which is returned as a dictionary.\n\nExamples\n\njulia> Singular.call_interpreter(\"bigint a = 42;\");\n\njulia> a = Singular.lookup_library_symbol(\"Top\", \"a\"); (a, typeof(a))\n(42, BigInt)\n\njulia> Singular.call_interpreter(\"ring r=0,(x,y,z),dp; poly f = (x+y)^2;\");\n\njulia> Singular.lookup_library_symbol(\"Top\", \"r\")\n2-element Vector{Any}:\n Singular polynomial ring (QQ),(x,y,z),(dp(3),C)\n Dict{Symbol, spoly{n_Q}}(:f => x^2 + 2*x*y + y^2)\n\n\n\n\n\n","category":"method"},{"location":"caller/#Global-Kernel-Variables","page":"Interpreter Functionality","title":"Global Kernel Variables","text":"","category":"section"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"The global variables degBound and multBound can be used in a local fashion. As with any global variable, their usage should be accompanied with caution.","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"with_degBound(f, degb::Integer)","category":"page"},{"location":"caller/#Singular.with_degBound-Tuple{Any, Integer}","page":"Interpreter Functionality","title":"Singular.with_degBound","text":"with_degBound(f, degb::Integer)\n\nEvaluate and return f() with the Singular global setting degBound = degb. The value of degBound is automatically restored upon return; the effect is only a local one on f(). The value degBound = 0 corresponds to no degree bound in Singular and this is the starting value.\n\n\n\n\n\n","category":"method"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"with_multBound(f, degb::Integer)","category":"page"},{"location":"caller/#Singular.with_multBound-Tuple{Any, Integer}","page":"Interpreter Functionality","title":"Singular.with_multBound","text":"with_multBound(f, mu::Integer)\n\nEvaluate and return f() with the Singular global setting multBound = mu. The value of multBound is automatically restored upon return; the effect is only a local one on f(). The value multBound = 0 corresponds to no multiplicity bound in Singular and this is the starting value.\n\n\n\n\n\n","category":"method"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"The following options are available. The usage of, say, the option infRefTail would be as with_infRefTail(f, flag::Bool) where the same do-block syntax can be used as with the degree bounds.","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"fastHC, infRedTail, lazy, length, notBuckets, prot, qringNF, redTail, redThrough","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"Examples","category":"page"},{"location":"caller/","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"julia> r, (x,y,z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"], ordering=ordering_ds());\n\njulia> i = Ideal(r, [x^7+y^7+z^6,x^6+y^8+z^7,x^7+y^5+z^8,x^2*y^3+y^2*z^3+x^3*z^2,x^3*y^2+y^3*z^2+x^2*z^3]);\n\njulia> degree(std(i))   # default behaviour of no multiplicity bound\n(0, 86)\n\njulia> with_multBound(100) do\n           # run with a multiplicity bound of 100\n           return degree(std(i))\n       end\n(0, 98)\n\njulia> degree(std(i))   # back to default behaviour\n(0, 86)\n\njulia> gens(std(i))\n11-element Vector{spoly{n_Q}}:\n x^3*y^2 + y^3*z^2 + x^2*z^3\n x^2*y^3 + x^3*z^2 + y^2*z^3\n y^5 + x^7 + z^8\n x^6 + z^7 + y^8\n x^4*z^2 - y^4*z^2 - x^2*y*z^3 + x*y^2*z^3\n z^6 + x^7 + y^7\n y^4*z^3 - y^3*z^4 - x^2*z^5 - x^9\n x^3*y*z^4 - x^2*y^2*z^4 + x*y^3*z^4 - y^4*z^4 + x^3*z^5 - x^2*y*z^5\n x^3*z^5\n x^2*y*z^5 + y^3*z^5 + x^2*z^6\n x*y^3*z^5\n\njulia> gens(with_degBound(5) do; return std(i); end)\n5-element Vector{spoly{n_Q}}:\n x^3*y^2 + y^3*z^2 + x^2*z^3\n x^2*y^3 + x^3*z^2 + y^2*z^3\n y^5 + x^7 + z^8\n x^6 + z^7 + y^8\n z^6 + x^7 + y^7\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> with_prot(true) do; return std(Ideal(R, x^5 - y*x + 1, y^6*x + x^2 + y^3)); end\n[4294967295:2]5s7s11s1214-s15\nproduct criterion:1 chain criterion:1\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^5 - x*y + 1, x*y^6 + y^3 + x^2, x^4*y^3 - y^6 - y^4 - x, y^9 + y^7 + x^3*y^3 + x*y^3 + x*y - 1)","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"alghom/#Algebra-Homomorphisms","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Singular.jl allows the creation of algebra homomorphisms of Singular polynomial rings over Nemo/Singular coefficient rings.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"The default algebra homomorphism type in Singular.jl is the Singular SAlgHom type.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Additionally, a special type for the identity homomorphism has been implemented. The type in Singular.jl for the latter is SIdAlgHom.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"All algebra homomorphism types belong directly to the abstract type AbstractAlgebraHomomorphism{T}.","category":"page"},{"location":"alghom/#Algebra-Homomorphism-functionality","page":"Algebra Homomorphisms","title":"Algebra Homomorphism functionality","text":"","category":"section"},{"location":"alghom/#Constructors","page":"Algebra Homomorphisms","title":"Constructors","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Given two Singular polynomial rings R and S over the same base ring, the following constructors are available for creating algebra homomorphisms.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"AlgebraHomomorphism(D::PolyRing, C::PolyRing, V::Vector)","category":"page"},{"location":"alghom/#Singular.AlgebraHomomorphism-Tuple{PolyRing, PolyRing, Vector}","page":"Algebra Homomorphisms","title":"Singular.AlgebraHomomorphism","text":"AlgebraHomomorphism(D::PolyRing, C::PolyRing, V::Vector)\n\nConstructs an algebra homomorphism f D to C, where the i-th variable of D is mapped to the i-th entry of V. D and C must be polynomial rings over the same base ring.\n\n\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"IdentityAlgebraHomomorphism(D::PolyRing)","category":"page"},{"location":"alghom/#Singular.IdentityAlgebraHomomorphism-Tuple{PolyRing}","page":"Algebra Homomorphisms","title":"Singular.IdentityAlgebraHomomorphism","text":"IdentityAlgebraHomomorphism(R::PolyRing)\n\nConstructs the canonical identity algebra homomorphism id D to D, where the i-th variable of D is mapped to itself.\n\n\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Examples","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"julia> L = FiniteField(3, 2, \"a\")\n(Finite Field of Characteristic 3 and degree 2, a)\n\njulia> R, (x, y, z, w) = polynomial_ring(L[1], [\"x\", \"y\", \"z\", \"w\"];\n                                    ordering=:negdegrevlex)\n(Singular polynomial ring (9,a),(x,y,z,w),(ds(4),C), spoly{n_GF}[x, y, z, w])\n\njulia> S, (a, b, c) = polynomial_ring(L[1], [\"a\", \"b\", \"c\"];\n                                    ordering=:degrevlex)\n(Singular polynomial ring (9,a),(a@1,b,c),(dp(3),C), spoly{n_GF}[a, b, c])\n\njulia> V = [a, a + b^2, b - c, c + b]\n4-element Vector{spoly{n_GF}}:\n a\n b^2 + a\n b + a^4*c\n b + c\n\njulia> f = AlgebraHomomorphism(R, S, V)\nAlgebra homomorphism\n  from Singular polynomial ring (9,a),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (9,a),(a@1,b,c),(dp(3),C)\nDefining equations: spoly{n_GF}[a, b^2 + a, b + a^4*c, b + c]","category":"page"},{"location":"alghom/#Operating-on-objects","page":"Algebra Homomorphisms","title":"Operating on objects","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"It is possible to act on polynomials and ideals via algebra homomorphisms.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Examples","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"R, (x, y, z, w) = polynomial_ring(Nemo.ZZ, [\"x\", \"y\", \"z\", \"w\"];\n                             ordering=:negdegrevlex)\n\nS, (a, b, c) = polynomial_ring(Nemo.ZZ, [\"a\", \"b\", \"c\"];\n                             ordering=:degrevlex)\n\nV = [a, a + b^2, b - c, c + b]\n\nf = AlgebraHomomorphism(R, S, V)\n\nid  = IdentityAlgebraHomomorphism(S)\n\n\nJ = Ideal(R, [x, y^3])\n\np = x + y^3 + z*w\n\nK = f(J)\n\nq = f(p)","category":"page"},{"location":"alghom/#Composition","page":"Algebra Homomorphisms","title":"Composition","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"compose(f::SAlgHom, g::SAlgHom)","category":"page"},{"location":"alghom/#AbstractAlgebra.compose-Tuple{Singular.SAlgHom, Singular.SAlgHom}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.compose","text":"compose(f::AbstractAlgebra.Map(Singular.SAlgHom),\n                     g::AbstractAlgebra.Map(Singular.SAlgHom))\n\nReturn an algebra homomorphism h domain(f) to codomain(g), where h = g(f).\n\n\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"A short command for the composition of f and g is f*g, which is the same as compose(f, g).","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Examples","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"julia> R, (x, y, z, w) = polynomial_ring(QQ, [\"x\", \"y\", \"z\", \"w\"];\n                                    ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C), spoly{n_Q}[x, y, z, w])\n\njulia> S, (a, b, c) = polynomial_ring(QQ, [\"a\", \"b\", \"c\"];\n                                    ordering=:degrevlex)\n(Singular polynomial ring (QQ),(a,b,c),(dp(3),C), spoly{n_Q}[a, b, c])\n\njulia> V = [a, a + b^2, b - c, c + b]\n4-element Vector{spoly{n_Q}}:\n a\n b^2 + a\n b - c\n b + c\n\njulia> W = [x^2, x + y + z, z*y]\n3-element Vector{spoly{n_Q}}:\n x^2\n x + y + z\n y*z\n\njulia> f = AlgebraHomomorphism(R, S, V)\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Q}[a, b^2 + a, b - c, b + c]\n\njulia> g = AlgebraHomomorphism(S, R, W)\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly{n_Q}[x^2, x + y + z, y*z]\n\njulia> idR  = IdentityAlgebraHomomorphism(R)\nIdentity algebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly{n_Q}[x, y, z, w]\n\njulia> h1 = f*g\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly[x^2, 2*x^2 + 2*x*y + y^2 + 2*x*z + 2*y*z + z^2, x + y + z - y*z, x + y + z + y*z]\n\njulia> h2 = idR*f\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Q}[a, b^2 + a, b - c, b + c]\n\njulia> h3 = g*idR\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly{n_Q}[x^2, x + y + z, y*z]\n\njulia> h4 = idR*idR\nIdentity algebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly{n_Q}[x, y, z, w]","category":"page"},{"location":"alghom/#Preimages","page":"Algebra Homomorphisms","title":"Preimages","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"preimage(f::SAlgHom, I::sideal)","category":"page"},{"location":"alghom/#AbstractAlgebra.preimage-Tuple{Singular.SAlgHom, sideal}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.preimage","text":"preimage(f::AbstractAlgebra.Map(SAlgHom), I::sideal)\n\nReturn the preimage of the ideal I under the algebra homomorphism f.\n\n\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"preimage(f::SIdAlgHom, I::sideal)","category":"page"},{"location":"alghom/#AbstractAlgebra.preimage-Tuple{Singular.SIdAlgHom, sideal}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.preimage","text":"preimage(f::AbstractAlgebra.Map(SIdAlgHom), I::sideal)\n\nReturn the preimage of the ideal I under the identity algebra homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"kernel(f::SIdAlgHom)","category":"page"},{"location":"alghom/#AbstractAlgebra.kernel-Tuple{Singular.SIdAlgHom}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.kernel","text":"kernel(f::AbstractAlgebra.Map(SIdAlgHom))\n\nReturn the kernel of the identity algebra homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"kernel(f::SAlgHom)","category":"page"},{"location":"alghom/#AbstractAlgebra.kernel-Tuple{Singular.SAlgHom}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.kernel","text":"kernel(f::AbstractAlgebra.Map(SAlgHom))\n\nReturn the kernel of the algebra homomorphism f.\n\n\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Examples","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"julia> R, (x, y, z, w) = polynomial_ring(QQ, [\"x\", \"y\", \"z\", \"w\"];\n                                    ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C), spoly{n_Q}[x, y, z, w])\n\njulia> S, (a, b, c) = polynomial_ring(QQ, [\"a\", \"b\", \"c\"];\n                                    ordering=:degrevlex)\n(Singular polynomial ring (QQ),(a,b,c),(dp(3),C), spoly{n_Q}[a, b, c])\n\njulia> I = Ideal(S, [a, a + b^2, b - c, c + b])\nSingular ideal over Singular polynomial ring (QQ),(a,b,c),(dp(3),C) with generators (a, b^2 + a, b - c, b + c)\n\njulia> f = AlgebraHomomorphism(R, S, gens(I))\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Q}[a, b^2 + a, b - c, b + c]\n\njulia> idS  = IdentityAlgebraHomomorphism(S)\nIdentity algebra homomorphism\n  from Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\n  to Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Q}[a, b, c]\n\njulia> P1 = preimage(f, I)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C) with generators (x, y, z, w)\n\njulia> P2 = preimage(idS, I)\nSingular ideal over Singular polynomial ring (QQ),(a,b,c),(dp(3),C) with generators (a, b^2 + a, b - c, b + c)\n\njulia> K1 = kernel(f)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C) with generators (4*x - 4*y + z^2 + 2*z*w + w^2)\n\njulia> K2 = kernel(idS)\nSingular ideal over Singular polynomial ring (QQ),(a,b,c),(dp(3),C) with generators (0)","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"vector/#Free-modules-and-vectors","page":"Free modules and vectors","title":"Free modules and vectors","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"As generators of finitely generated modules in Singular.jl are given as submodule of free modules over a polynomial ring R, Singular.jl supports creation of the free module R^n and vectors of length n in such a module.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"The Singular.jl type for a vector is svector{T}. For the most part, these exist to help interact with the smodule{T} type provided by Singular.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"The types of vectors and associated parent objects are given in the following table according to the library providing them.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Library Element type Parent type\nSingular svector{T} Singular.FreeMod{T}","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"These types are parameterised by the type of elements in the polynomial ring R.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"All free module types belong directly to the abstract type Module{T} and vector types belong directly to ModuleElem{T}.","category":"page"},{"location":"vector/#Free-module-and-vector-functionality","page":"Free modules and vectors","title":"Free module and vector functionality","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Singular.jl modules implement standard operations one would expect on vectors and their associated parent modules.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"These include:","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.\nArithmetic operations on vectors: (unary) -, +, -\nScalar multiplication of vectors by polynomials, constants and integers\nComparison operators: ==","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Below, we describe all of the functionality for Singular.jl free modules that is not included in this list of basic operations.","category":"page"},{"location":"vector/#Constructors","page":"Free modules and vectors","title":"Constructors","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Given a Singular polynomial ring R and a rank n, the following constructors are available for creating free modules.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"FreeModule{T <: AbstractAlgebra.RingElem}(R::PolyRing{T}, n::Int)","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Construct the free module R^n over the polynomial ring R. Elements of the module returned by this function are vectors of length n, with entries in R.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"vector{T <: AbstractAlgebra.RingElem}(R::PolyRing{T}, coords::spoly{T}...)","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Construct the vector whose coordinates (which are elements of R) are the given parameters.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Examples","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> M = FreeModule(R, 3)\nFree Module of rank 3 over Singular polynomial ring (QQ),(x,y),(dp(2),C)\n\njulia> v2 = M([x + 1, x*y + 1, y])\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)","category":"page"},{"location":"vector/#Basic-manipulation","page":"Free modules and vectors","title":"Basic manipulation","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"rank(::FreeMod)","category":"page"},{"location":"vector/#LinearAlgebra.rank-Tuple{FreeMod}","page":"Free modules and vectors","title":"LinearAlgebra.rank","text":"rank(M::FreeMod)\n\nReturn the rank of the given free module.\n\n\n\n\n\n","category":"method"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"gens{T <: AbstractAlgebra.RingElem}(::FreeMod{T})","category":"page"},{"location":"vector/#GroupsCore.gens-Union{Tuple{FreeMod{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Free modules and vectors","title":"GroupsCore.gens","text":"gens{T <: AbstractAlgebra.RingElem}(M::FreeMod{T})\n\nReturn a Julia array whose entries are the generators of the given free module.\n\n\n\n\n\n","category":"method"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Examples","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> M = FreeModule(R, 5)\nFree Module of rank 5 over Singular polynomial ring (QQ),(x,y),(dp(2),C)\n\njulia> v = gens(M)\n5-element Vector{svector{spoly{n_Q}}}:\n gen(1)\n gen(2)\n gen(3)\n gen(4)\n gen(5)\n\njulia> r = rank(M)\n5","category":"page"},{"location":"vector/#Conversions","page":"Free modules and vectors","title":"Conversions","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"To convert the internal Singular representation of an svector{T} to a Julia array whose entries have type T, we have the following conversion routine.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Array{T <: Nemo.RingElem}(v::svector{spoly{T}})","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Examples","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> V = Array(v1)\n3-element Vector{spoly{n_Q}}:\n x + 1\n x*y + 1\n y","category":"page"},{"location":"vector/#Jet-of-vectors","page":"Free modules and vectors","title":"Jet of vectors","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"jet{T <: AbstractAlgebra.RingElem}(::svector{spoly{T}}, ::Int)","category":"page"},{"location":"vector/#Singular.jet-Union{Tuple{T}, Tuple{svector{spoly{T}}, Int64}} where T<:AbstractAlgebra.RingElem","page":"Free modules and vectors","title":"Singular.jet","text":"jet(x::svector{spoly{T}}, n::Int)\n\nGiven a vector x this function truncates each entry of x up to degree n.\n\n\n\n\n\n","category":"method"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Examples","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v = vector(R, x^5 + 1, 2x^3 + 3y^2, x^2)\nx^5*gen(1)+2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)\n\njulia> w = jet(v, 3)\n2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"modp/#Integers-mod-p","page":"Integers mod p","title":"Integers mod p","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Integers mod a prime p are implemented via the Singular n_Zp type for any positive prime modulus less than 2^29.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"The associated field of integers mod p is represented by a parent object which can be constructed by a call to the Fp constructor.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"The types of the parent objects and elements of the associated fields of integers modulo p are given in the following table according to the library providing them.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Library Element type Parent type\nSingular n_Zp Singular.N_ZpField","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"All integer mod p element types belong directly to the abstract type FieldElem and all the parent object types belong to the abstract type Field.","category":"page"},{"location":"modp/#Integer-mod-p-functionality","page":"Integers mod p","title":"Integer mod p functionality","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Singular.jl integers modulo p provides the field and residue ring functionality of AbstractAlgebra.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/residue","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Below, we describe the functionality that is specific to the Singular integers mod p field and not already listed at the given links.","category":"page"},{"location":"modp/#Constructors","page":"Integers mod p","title":"Constructors","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"The following constructors are available to create the field of integers modulo a prime p.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Fp(p::Int; cached=true)","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Construct the field of integers modulo p. By default, the field is cached, so that all fields of integers modulo p have the same parent object. If this is not the desired behaviour, the cached parameter can be set to false. If p is not a prime or p is not in the range (0 2^29), an exception is raised.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Given a field R of integers modulo p, we also have the following coercions in addition to the standard ones expected.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"R(n::n_Z)\nR(n::ZZRingElem)","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Coerce a Singular or Flint integer value into the field.","category":"page"},{"location":"modp/#Basic-manipulation","page":"Integers mod p","title":"Basic manipulation","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Examples","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"julia> R = Fp(23)\nFinite Field of Characteristic 23\n\njulia> a = R(5)\n5\n\njulia> is_unit(a)\ntrue\n\njulia> c = characteristic(R)\n23","category":"page"},{"location":"modp/#Conversions","page":"Integers mod p","title":"Conversions","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Int(n::n_Zp)","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Lift the integer n modulo p to a Julia Int. The result is always in the range 0 p).","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Examples","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"julia> R = Fp(23)\nFinite Field of Characteristic 23\n\njulia> a = R(5)\n5\n\njulia> b = Int(a)\n5","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"transExt/#Function-fields","page":"Function fields","title":"Function fields","text":"","category":"section"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Function fields are implemented via the Singular n_transExt type for prime fields of any characteristic.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"The associated function field is represented by a parent object which can be constructed by a call to the FunctionField constructor.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"The types of the parent objects and elements of the associated function fields are given in the following table according to the library providing them.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Library Element type Parent type\nSingular n_transExt Singular.N_FField","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"All function field element types belong directly to the abstract type FieldElem and all the parent object types belong to the abstract type Field.","category":"page"},{"location":"transExt/#Function-field-functionality","page":"Function fields","title":"Function field functionality","text":"","category":"section"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.jl function fields provide all the functionality for fields described by AbstractAlgebra.jl.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/field","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Below, we describe the functionality that is specific to Singular function field and not already listed at the given link.","category":"page"},{"location":"transExt/#Constructors","page":"Function fields","title":"Constructors","text":"","category":"section"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"The following constructors are available to create function fields and their elements.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.FunctionField(::Field, ::AbstractVector{<:VarName}; cached::Bool = true)","category":"page"},{"location":"transExt/#Singular.FunctionField-Tuple{Singular.Field, AbstractVector{<:Union{Char, AbstractString, Symbol}}}","page":"Function fields","title":"Singular.FunctionField","text":"FunctionField(F::Singular.Field, S::AbstractVector{<:VarName})\n\nReturn a tuple K a consisting of a function field K over the field F with transcendence basis stored in the array S.\n\n\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"In case the user does not want to specify a transcendence basis the following constructor can be used.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.FunctionField(::Field, ::Int; cached::Bool = true)","category":"page"},{"location":"transExt/#Singular.FunctionField-Tuple{Singular.Field, Int64}","page":"Function fields","title":"Singular.FunctionField","text":"FunctionField(F::Singular.Field, n::Int)\n\nReturn a tuple K a consisting of a function field K over the field F with transcendence degree n and transcendence basis a1  an.\n\n\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Given a function field F, we also have the following coercions in addition to the standard ones expected.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"F(n::ZZRingElem)","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Coerce a Flint integer value into the field.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Examples","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"julia> F1, (a, b, c) = FunctionField(QQ, [\"a\", \"b\", \"c\"])\n(Function Field over Rational Field with transcendence basis n_transExt[a, b, c], n_transExt[a, b, c])\n\njulia> x1 = a*b + c\na*b + c\n\njulia> F2, (a1, a2, a3) = FunctionField(Fp(5), 3)\n(Function Field over Finite Field of Characteristic 5 with transcendence basis n_transExt[a1, a2, a3], n_transExt[a1, a2, a3])\n\njulia> x2 = a1^5 + a2*a3^4\na1^5 + a2*a3^4","category":"page"},{"location":"transExt/#Basic-manipulation","page":"Function fields","title":"Basic manipulation","text":"","category":"section"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"numerator(::n_transExt)","category":"page"},{"location":"transExt/#Base.numerator-Tuple{n_transExt}","page":"Function fields","title":"Base.numerator","text":"numerator(x::n_transExt)\n\nReturn the numerator of x.\n\n\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"denominator(::n_transExt)","category":"page"},{"location":"transExt/#Base.denominator-Tuple{n_transExt}","page":"Function fields","title":"Base.denominator","text":"denominator(x::n_transExt)\n\nReturn the denominator of x.\n\n\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"transcendence_degree(::N_FField)","category":"page"},{"location":"transExt/#Singular.transcendence_degree-Tuple{N_FField}","page":"Function fields","title":"Singular.transcendence_degree","text":"transcendence_degree(F::N_FField)\n\nReturn the transcendence degree of the given function field.\n\n\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"transcendence_basis(::N_FField)","category":"page"},{"location":"transExt/#Singular.transcendence_basis-Tuple{N_FField}","page":"Function fields","title":"Singular.transcendence_basis","text":"basis(F::N_FField)\n\nReturn the transcendence basis of the given function field.\n\n\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"n_transExt_to_spoly(x::n_transExt; parent::PolyRing)","category":"page"},{"location":"transExt/#Singular.n_transExt_to_spoly-Tuple{n_transExt}","page":"Function fields","title":"Singular.n_transExt_to_spoly","text":"n_transExt_to_spoly(x::n_transExt; parent::PolyRing)\n\nReturn the numerator of x as a polynomial in a polynomial ring with at least as many variables as the transcendence degree of parent(x). If a ring parent is given to the function, it will be the parent ring of the output.\n\n\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Examples","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"julia> F1, (a, b, c) = FunctionField(QQ, [\"a\", \"b\", \"c\"])\n(Function Field over Rational Field with transcendence basis n_transExt[a, b, c], n_transExt[a, b, c])\n\njulia> x = F1(5)*a\n5*a\n\njulia> y = a^2 *b+a*b+b^2\na^2*b + a*b + b^2\n\njulia> is_unit(x)\ntrue\n\njulia> char = characteristic(F1)\n0\n\njulia> d = transcendence_degree(F1)\n3\n\njulia> S, = polynomial_ring(QQ, [\"a\", \"b\", \"c\"])\n(Singular polynomial ring (QQ),(a,b,c),(dp(3),C), spoly{n_Q}[a, b, c])\n\njulia> p = n_transExt_to_spoly(y, parent_ring = S)\na^2*b + a*b + b^2\n\njulia> F2, = FunctionField(Fp(7), 4)\n(Function Field over Finite Field of Characteristic 7 with transcendence basis n_transExt[a1, a2, a3, a4], n_transExt[a1, a2, a3, a4])\n\njulia> B = transcendence_basis(F2)\n4-element Vector{n_transExt}:\n a1\n a2\n a3\n a4","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"ideal/#Ideals","page":"Ideals","title":"Ideals","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Singular.jl allows the creation of ideals over a Singular polynomial ring. These are internally stored as a list of (polynomial) generators. This list of generators can also have the property of being a Groebner basis.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"The default ideal type in Singular.jl is the Singular sideal type.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Ideals objects have a parent object which represents the set of ideals they belong to, the data for which is given by the polynomial ring their generators belong to.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"The types of ideals and associated parent objects are given in the following table according to the library providing them.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Library Element type Parent type\nSingular sideal{T} Singular.IdealSet{T}","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"These types are parameterised by the type of elements of the polynomial ring over which the ideals are defined.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"All ideal types belong directly to the abstract type Module{T} and all the ideal set parent object types belong to the abstract type Set.","category":"page"},{"location":"ideal/#Ideal-functionality","page":"Ideals","title":"Ideal functionality","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Singular.jl ideals implement standard operations one would expect on modules. These include:","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.\nAddition","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Also implements is the following operations one expects for ideals:","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Multiplication\nPowering","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Below, we describe all of the functionality for Singular.jl ideals that is not included in this list of basic operations.","category":"page"},{"location":"ideal/#Constructors","page":"Ideals","title":"Constructors","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Given a Singular polynomial ring R, the following constructors are available for creating ideals.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Ideal(R::PolyRing{T}, ids::spoly{T}...) where T <: Nemo.RingElem\nIdeal(R::PolyRing{T}, ids::Vector{spoly{T}}) where T <: Nemo.RingElem","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Construct the ideal over the polynomial ring R whose (polynomial) generators are given by the given parameter list or array of polynomials, respectively. The list may be empty, resulting in the zero ideal.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])\n\njulia> I1 = Ideal(R, x*y + 1, x^2)\nSingular ideal over Singular polynomial ring (ZZ),(x,y),(dp(2),C) with generators (x*y + 1, x^2)\n\njulia> I2 = Ideal(R, [x*y + 1, x^2])\nSingular ideal over Singular polynomial ring (ZZ),(x,y),(dp(2),C) with generators (x*y + 1, x^2)","category":"page"},{"location":"ideal/#Basic-manipulation","page":"Ideals","title":"Basic manipulation","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"ngens(::sideal)","category":"page"},{"location":"ideal/#GroupsCore.ngens-Tuple{sideal}","page":"Ideals","title":"GroupsCore.ngens","text":"ngens(I::sideal)\n\nReturn the number of generators in the internal representation of the ideal I.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"gens(::sideal)","category":"page"},{"location":"ideal/#GroupsCore.gens-Tuple{sideal}","page":"Ideals","title":"GroupsCore.gens","text":"gens(I::sideal)\n\nReturn the generators in the internal representation of the ideal I as an array.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Singular.jl overloads the setindex! and getindex functions so that one can access the generators of an ideal using array notation.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"I[n::Int]","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"iszero(::sideal)","category":"page"},{"location":"ideal/#Base.iszero-Tuple{sideal}","page":"Ideals","title":"Base.iszero","text":"iszero(I::sideal)\n\nReturn true if the given ideal is algebraically the zero ideal.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"is_zerodim(I::sideal)","category":"page"},{"location":"ideal/#Singular.is_zerodim-Tuple{sideal}","page":"Ideals","title":"Singular.is_zerodim","text":"is_zerodim(I::sideal)\n\nReturn true if the given ideal is zero dimensional, i.e. the Krull dimension of RI is zero, where R is the polynomial ring over which I is an ideal.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"dimension(I::sideal{spoly{T}}) where T <: Nemo.RingElem","category":"page"},{"location":"ideal/#Singular.dimension-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.dimension","text":"dimension(I::sideal{spoly{T}}) where T <: Nemo.RingElem\n\nGiven an ideal I this function computes the Krull dimension of the ring RI, where R is the polynomial ring over which I is an ideal. The ideal must be over a polynomial ring and a Groebner basis.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"is_constant(::sideal)","category":"page"},{"location":"ideal/#AbstractAlgebra.is_constant-Tuple{sideal}","page":"Ideals","title":"AbstractAlgebra.is_constant","text":"is_constant(I::sideal)\n\nReturn true if the given ideal is a constant ideal, i.e. generated by constants in the polynomial ring over which it is an ideal.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"is_var_generated(::sideal)","category":"page"},{"location":"ideal/#Singular.is_var_generated-Tuple{sideal}","page":"Ideals","title":"Singular.is_var_generated","text":"is_var_generated(I::sideal)\n\nReturn true if each generator in the representation of the ideal I is a generator of the polynomial ring, i.e. a variable.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"normalize!(::sideal)","category":"page"},{"location":"ideal/#LinearAlgebra.normalize!-Tuple{sideal}","page":"Ideals","title":"LinearAlgebra.normalize!","text":"normalize!(I::sideal)\n\nNormalize the polynomial generators of the ideal I in-place. This means to reduce their coefficients to lowest terms. In most cases this does nothing, but if the coefficient ring were the rational numbers for example, the coefficients of the polynomials would be reduced to lowest terms.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"interreduce(I::sideal{S}) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}","category":"page"},{"location":"ideal/#Singular.interreduce-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T<:AbstractAlgebra.RingElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.interreduce","text":"interreduce(I::sideal{S}) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}\n\nInterreduce the elements of I such that no leading term is divisible by another leading term. This returns a new ideal and does not modify the input ideal.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (ZZ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> n = ngens(I)\n2\n\njulia> p = I[1]\nx^2 + 1\n\njulia> I[1] = 2x + y^2\ny^2 + 2*x\n\njulia> is_constant(I) == false\ntrue\n\njulia> is_var_generated(I) == false\ntrue\n\njulia> is_zerodim(I) == false\nERROR: Not a Groebner basis\n\njulia> S, (u, v) = polynomial_ring(QQ, [\"u\", \"v\"])\n(Singular polynomial ring (QQ),(u,v),(dp(2),C), spoly{n_Q}[u, v])\n\njulia> J = Ideal(S, u^2 + 1, u*v)\nSingular ideal over Singular polynomial ring (QQ),(u,v),(dp(2),C) with generators (u^2 + 1, u*v)\n\njulia> dimension(std(J)) == 0\ntrue","category":"page"},{"location":"ideal/#Containment","page":"Ideals","title":"Containment","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"contains{T <: AbstractAlgebra.RingElem}(::sideal{T}, ::sideal{T})","category":"page"},{"location":"ideal/#Base.contains-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Base.contains","text":"contains(I::sideal{S}, J::sideal{S}) where S\n\nReturn true if the ideal I contains the ideal J. This will be expensive if I is not a Groebner ideal, since its standard basis must be computed.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> J = Ideal(R, x^2 + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1)\n\njulia> contains(I, J) == true\ntrue","category":"page"},{"location":"ideal/#Comparison","page":"Ideals","title":"Comparison","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Checking whether two ideals are algebraically equal is very expensive, as it usually requires computing Groebner bases. Therefore we do not overload the == operator for ideals. Instead we have the following two functions.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"isequal(I1::sideal{S}, I2::sideal{S}) where S <: SPolyUnion","category":"page"},{"location":"ideal/#Base.isequal-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Base.isequal","text":"isequal(I1::sideal{S}, I2::sideal{S}) where S <: SPolyUnion\n\nReturn true if the given ideals have the same generators in the same order. Note that two algebraically equal ideals with different generators will return false.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"equal(I1::sideal{S}, I2::sideal{S}) where S <: SPolyUnion","category":"page"},{"location":"ideal/#Singular.equal-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Singular.equal","text":"equal(I1::sideal{S}, I2::sideal{S}) where S <: SPolyUnion\n\nReturn true if the two ideals are contained in each other, i.e. are the same ideal mathematically. This function should be called only as a last resort; it is exceptionally expensive to test equality of ideals! Do not define == as an alias for this function!\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + x*y + 1, x^2 - x*y + 1)\n\njulia> isequal(I, J) == false\ntrue\n\njulia> equal(I, J) == true\ntrue","category":"page"},{"location":"ideal/#Intersection","page":"Ideals","title":"Intersection","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"intersection(I::sideal{S}, J::sideal{S}) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}","category":"page"},{"location":"ideal/#Singular.intersection-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, sideal{S}}} where {T<:AbstractAlgebra.RingElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.intersection","text":"intersection(I::sideal{S}, J::sideal{S}) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}\n\nReturn the intersection of the two given ideals.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + x*y + 1, x^2 - x*y + 1)\n\njulia> V = intersection(I, J)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (y, x^2 - x*y + 1)","category":"page"},{"location":"ideal/#Quotient","page":"Ideals","title":"Quotient","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"quotient(I::sideal{S}, J::sideal{S}) where S <: spoly","category":"page"},{"location":"ideal/#Singular.quotient-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:spoly","page":"Ideals","title":"Singular.quotient","text":"quotient(I::sideal{S}, J::sideal{S}) where S <: spoly\n\nReturn the quotient of the two given ideals. Recall that the ideal quotient (IJ) over a polynomial ring R is defined by r in R  rJ subseteq I.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"quotient(I::sideal{S}, J::sideal{S}) where S <: spluralg","category":"page"},{"location":"ideal/#Singular.quotient-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:spluralg","page":"Ideals","title":"Singular.quotient","text":"quotient(I::sideal{S}, J::sideal{S}) where S <: spluralg\n\nReturn the quotient of the two given ideals, where J must be two-sided.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> J = Ideal(R, x + y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x + y)\n\njulia> V = quotient(I, J)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (y, x^2 + 1)","category":"page"},{"location":"ideal/#Leading-terms","page":"Ideals","title":"Leading terms","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"lead(I::sideal{S}) where S <: SPolyUnion","category":"page"},{"location":"ideal/#Singular.lead-Union{Tuple{sideal{S}}, Tuple{S}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Singular.lead","text":"lead(I::sideal{S}) where S <: SPolyUnion\n\nReturn the ideal generated by the leading terms of the polynomials generating I.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> V = lead(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2, x*y)","category":"page"},{"location":"ideal/#Homogeneous-ideals","page":"Ideals","title":"Homogeneous ideals","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"is_homogeneous(I::sideal)","category":"page"},{"location":"ideal/#Singular.is_homogeneous-Tuple{sideal}","page":"Ideals","title":"Singular.is_homogeneous","text":"is_homogeneous(I::sideal)\n\nReturn true if each stored generator of I is homogeneous, otherwise false. If base_ring(I) has a weighted monomial ordering, the test is conducted with respect to the corresponding weights.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"homogenize(I::sideal{S}, v::S) where S <: spoly","category":"page"},{"location":"ideal/#Singular.homogenize-Union{Tuple{S}, Tuple{sideal{S}, S}} where S<:spoly","page":"Ideals","title":"Singular.homogenize","text":"homogenize(I::sideal{S}, v::S) where S <: spoly\n\nMultiply each monomial in the generators of I by a suitable power of the variable v and return the corresponding homogeneous ideal. The variable v must have weight 1.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Saturation","page":"Ideals","title":"Saturation","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"saturation(I::sideal{T}, J::sideal{T}) where T <: Nemo.RingElem","category":"page"},{"location":"ideal/#Singular.saturation-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.saturation","text":"saturation(I::sideal{T}, J::sideal{T}) where T <: Nemo.RingElem\n\nReturn the saturation of the ideal I with respect to J, i.e. returns the quotient ideal (IJ^infty) and the number of iterations.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, (x^2 + x*y + 1)*(2y^2+1)^3, (2y^2 + 3)*(2y^2+1)^2)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (8*x^2*y^6 + 8*x*y^7 + 12*x^2*y^4 + 12*x*y^5 + 8*y^6 + 6*x^2*y^2 + 6*x*y^3 + 12*y^4 + x^2 + x*y + 6*y^2 + 1, 8*y^6 + 20*y^4 + 14*y^2 + 3)\n\njulia> J = Ideal(R, 2y^2 + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 1)\n\njulia> S = saturation(I, J)\n(Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 3, x^2 + x*y + 1), 2)","category":"page"},{"location":"ideal/#Standard-basis","page":"Ideals","title":"Standard basis","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"std(I::sideal{S}; complete_reduction::Bool=false) where S <: SPolyUnion","category":"page"},{"location":"ideal/#Statistics.std-Union{Tuple{sideal{S}}, Tuple{S}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Statistics.std","text":"std(I::sideal{S}; complete_reduction::Bool=false) where S <: SPolyUnion\n\nCompute a Groebner basis for the ideal I. Note that without complete_reduction set to true, the generators of the Groebner basis only have unique leading terms (up to permutation and multiplication by constants). If complete_reduction is set to true (and the ordering is a global ordering) then the Groebner basis is unique.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"fglm(I::sideal{spoly{T}}, ordering::Symbol) where T <: Nemo.RingElem","category":"page"},{"location":"ideal/#Singular.fglm-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Symbol}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.fglm","text":"fglm(I::sideal{spoly{T}}, ordering::Symbol) where T <: Nemo.RingElem\n\nCompute a Groebner basis for the zero - dimensional ideal I in the ring R using the FGLM algorithm. All involved orderings have to be global.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"satstd(I::sideal{spoly{T}}, J::sideal{spoly{T}}) where T <: Nemo.FieldElem","category":"page"},{"location":"ideal/#Singular.satstd-Union{Tuple{T}, Tuple{sideal{spoly{T}}, sideal{spoly{T}}}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.satstd","text":"satstd(I::sideal{spoly{T}}, J::sideal{spoly{T}} = Ideal(base_ring(I), gens(base_ring(I)))) where T <: Nemo.RingElem\n\nGiven an ideal J generated by variables, computes a standard basis of saturation(I, J). This is accomplished by dividing polynomials that occur throughout the std computation by variables occurring in J, where possible. Thus the result can be obtained faster than by first computing the saturation and then the standard basis.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"lift_std(M::sideal{S}; complete_reduction::Bool = false) where S <: spoly","category":"page"},{"location":"ideal/#Singular.lift_std-Union{Tuple{sideal{S}}, Tuple{S}} where S<:spoly","page":"Ideals","title":"Singular.lift_std","text":"lift_std(M::sideal{S}; complete_reduction::Bool = false) where S <: spoly\n\nComputes the Groebner base G of M and the transformation matrix T such that (Matrix(G) = Matrix(M) * T)\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"lift_std_syz(M::sideal{S}; complete_reduction::Bool = false) where S <: spoly","category":"page"},{"location":"ideal/#Singular.lift_std_syz-Union{Tuple{sideal{S}}, Tuple{S}} where S<:spoly","page":"Ideals","title":"Singular.lift_std_syz","text":"lift_std_syz(M::sideal{S}; complete_reduction::Bool = false) where S <: spoly\n\nComputes the Groebner base G of I, the transformation matrix T and the syzygies of M. Returns G,T,S (Matrix(G) = Matrix(I) * T, 0=Matrix(M)*Matrix(S))\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + x*y + 1, 2y^2 + 3)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + x*y + 1, 2*y^2 + 3)\n\njulia> J = Ideal(R, 2*y^2 + 3, x^2 + x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 3, x^2 + x*y + 1)\n\njulia> A = std(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 3, x^2 + x*y + 1)\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, (x*y + 1)*(2x^2*y^2 + x*y - 2) + 2x*y^2 + x, 2x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*x^3*y^3 + 3*x^2*y^2 + 2*x*y^2 - x*y + x - 2, 2*x*y + 1)\n\njulia> J = Ideal(R, x)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x)\n\njulia> B = satstd(I, J)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x - y - 1, 2*y^2 + 2*y + 1)\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"], ordering = :lex)\n(Singular polynomial ring (QQ),(x,y,z),(lp(3),C), spoly{n_Q}[x, y, z])\n\njulia> I = Ideal(R, y^3+x^2, x^2*y+x^2, x^3-x^2, z^4-x^2-y)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(lp(3),C) with generators (x^2 + y^3, x^2*y + x^2, x^3 - x^2, -x^2 - y + z^4)\n\njulia> J = fglm(I, :degrevlex)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(lp(3),C) with generators (z^12, y*z^4 - z^8, y^2 + y - z^8 - z^4, x*y - x*z^4 - y + z^4, x^2 + y - z^4)","category":"page"},{"location":"ideal/#Reduction","page":"Ideals","title":"Reduction","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"reduce(I::sideal{S}, G::sideal{S}) where S <: SPolyUnion","category":"page"},{"location":"ideal/#Base.reduce-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Base.reduce","text":"reduce(I::sideal{S}, G::sideal{S}) where S <: SPolyUnion\n\nReturn an ideal whose generators are the generators of I reduced by the ideal G. The ideal G need not be a Groebner basis. The returned ideal will have the same number of generators as I, even if they are zero. For PLURAL rings (S <: spluralg, GAlgebra, WeylAlgebra), the reduction is only a left reduction, and hence cannot be used to test containment in a two-sided ideal. For LETTERPLACE rings (S <: slpalg, FreeAlgebra), the reduction is two-sided as only two-sided ideals can be constructed here.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"reduce(p::S, G::sideal{S}) where S <: SPolyUnion","category":"page"},{"location":"ideal/#Base.reduce-Union{Tuple{S}, Tuple{S, sideal{S}}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Base.reduce","text":"reduce(p::S, G::sideal{S}) where S <: SPolyUnion\n\nReturn the polynomial which is p reduced by the polynomials generating G. The ideal G need not be a Groebner basis. For PLURAL rings (S <: spluralg, GAlgebra, WeylAlgebra), the reduction is only a left reduction, and hence cannot be used to test membership in a two-sided ideal. For LETTERPLACE rings (S <: slpalg, FreeAlgebra), the reduction is the full two-sided reduction as only two-sided ideals can be constructed here.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> f = x^2*y + 2y + 1\nx^2*y + 2*y + 1\n\njulia> g = y^2 + 1\ny^2 + 1\n\njulia> I = Ideal(R, (x^2 + 1)*f + (x + y)*g + x + 1, (2y^2 + x)*f + y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^4*y + 3*x^2*y + x*y^2 + y^3 + x^2 + 2*x + 3*y + 2, 2*x^2*y^3 + x^3*y + 4*y^3 + 2*x*y + 2*y^2 + x + y)\n\njulia> J = std(Ideal(R, f, g))\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (y^2 + 1, x^2 - y + 2)\n\njulia> V = reduce(I, J)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x + 1, y)\n\njulia> h1 = (x^2 + 1)*f + (x + y)*g + x + 1\nx^4*y + 3*x^2*y + x*y^2 + y^3 + x^2 + 2*x + 3*y + 2\n\njulia> h2 = reduce(h1, J)\nx + 1","category":"page"},{"location":"ideal/#Elimination","page":"Ideals","title":"Elimination","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"eliminate(I::sideal{S}, polys::S...) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}","category":"page"},{"location":"ideal/#Singular.eliminate-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, Vararg{S}}} where {T<:AbstractAlgebra.RingElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.eliminate","text":"eliminate(I::sideal{S}, polys::S...) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven a list of polynomials which are variables, construct the ideal corresponding geometrically to the projection of the variety given by the ideal I where those variables have been eliminated.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y, t) = polynomial_ring(QQ, [\"x\", \"y\", \"t\"])\n(Singular polynomial ring (QQ),(x,y,t),(dp(3),C), spoly{n_Q}[x, y, t])\n\njulia> I = Ideal(R, x - t^2, y - t^3)\nSingular ideal over Singular polynomial ring (QQ),(x,y,t),(dp(3),C) with generators (-t^2 + x, -t^3 + y)\n\njulia> J = eliminate(I, t)\nSingular ideal over Singular polynomial ring (QQ),(x,y,t),(dp(3),C) with generators (x^3 - y^2)","category":"page"},{"location":"ideal/#Syzygies","page":"Ideals","title":"Syzygies","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"syz(::sideal)","category":"page"},{"location":"ideal/#Singular.syz-Tuple{sideal}","page":"Ideals","title":"Singular.syz","text":"syz(I::sideal)\n\nCompute the module of syzygies of the ideal.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2*y + 2*y + 1, y^2 + 1)\n\njulia> F = syz(I)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\nx^2*y*gen(2)-y^2*gen(1)+2*y*gen(2)+gen(2)-gen(1)\n\njulia> M = Singular.Matrix(I)\n[x^2*y + 2*y + 1, y^2 + 1]\n\njulia> N = Singular.Matrix(F)\n[-y^2 - 1\nx^2*y + 2*y + 1]\n\njulia> iszero(M*N)  # check they are actually syzygies\ntrue","category":"page"},{"location":"ideal/#Free-resolutions","page":"Ideals","title":"Free resolutions","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"fres{T <: Nemo.FieldElem}(::sideal{spoly{T}}, ::Int, ::String)","category":"page"},{"location":"ideal/#Singular.fres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64, String}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.fres","text":"fres(id::sideal{spoly{T}}, max_length::Int, method::String=\"complete\") where T <: Nemo.FieldElem\n\nCompute a free resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The possible methods are \"complete\", \"frame\", \"extended frame\" and \"single module\". The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal/module. The max_length can be set to 0 if the full free resolution is required.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"sres{T <: Nemo.FieldElem}(::sideal{spoly{T}}, ::Int)","category":"page"},{"location":"ideal/#Singular.sres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.sres","text":"sres(id::sideal{spoly{T}}, max_length::Int) where T <: Nemo.FieldElem\n\nCompute a (free) Schreyer resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal. The max_length can be set to 0 if the full free resolution is required.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2*y + 2*y + 1, y^2 + 1)\n\njulia> F1 = fres(std(I), 0)\nSingular Resolution:\nR^1 <- R^2 <- R^1\n\njulia> F2 = sres(std(I), 2)\nSingular Resolution:\nR^1 <- R^2 <- R^1","category":"page"},{"location":"ideal/#Differential-operations","page":"Ideals","title":"Differential operations","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"jet(I::sideal{S}, n::Int) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}","category":"page"},{"location":"ideal/#Singular.jet-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, Int64}} where {T<:AbstractAlgebra.RingElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.jet","text":"jet(I::sideal{S}, n::Int) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven an ideal I this function truncates the generators of I up to degree n.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])\n\njulia> I = Ideal(R, x^5 - y^2, y^3 - x^6 + z^3)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(dp(3),C) with generators (x^5 - y^2, -x^6 + y^3 + z^3)\n\njulia> J1 = jet(I, 3)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(dp(3),C) with generators (-y^2, y^3 + z^3)","category":"page"},{"location":"ideal/#Operations-on-zero-dimensional-ideals","page":"Ideals","title":"Operations on zero-dimensional ideals","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"vdim(I::sideal{S}) where {T <: Nemo.FieldElem, S <: Union{spoly{T}, spluralg{T}}}","category":"page"},{"location":"ideal/#Singular.vdim-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T<:AbstractAlgebra.FieldElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.vdim","text":"vdim(I::sideal{S}) where {T <: Nemo.FieldElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven a zero-dimensional ideal I this function computes the dimension of the vector space base_ring(I)/I, where base_ring(I) must be a polynomial ring over a field, and I must be a Groebner basis. The return is -1 if !is_zerodim(I).\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"kbase(I::sideal{S}) where {T <: Nemo.FieldElem, S <: Union{spoly{T}, spluralg{T}}}","category":"page"},{"location":"ideal/#Singular.kbase-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T<:AbstractAlgebra.FieldElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.kbase","text":"kbase(I::sideal{S}) where {T <: Nemo.FieldElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven a zero-dimensional ideal I this function computes a vector space basis of the vector space base_ring(I)/I, where base_ring(I) must be a polynomial ring over a field, and I must be a Groebner basis. The array of vector space basis elements is returned as a Singular ideal, and this array consists of one zero polynomial if !is_zerodim(I).\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"highcorner(I::sideal{S}) where {T <: Nemo.FieldElem, S <: Union{spoly{T}, spluralg{T}}}","category":"page"},{"location":"ideal/#Singular.highcorner-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T<:AbstractAlgebra.FieldElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.highcorner","text":"highcorner(I::sideal{S}) where {T <: Nemo.FieldElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven a zero-dimensional ideal I this function computes its highest corner, which is a polynomial. The ideal must be over a polynomial ring over a field, and a Groebner basis. The return is the zero polynomial if !is_zerodim(I).\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]; ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y),(ds(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, 3*x^2 + y^3, x*y^2)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (3*x^2 + y^3, x*y^2)\n\njulia> I = std(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (3*x^2 + y^3, x*y^2, y^5)\n\njulia> n = vdim(I)\n7\n\njulia> J = kbase(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (y^4, y^3, y^2, x*y, y, x, 1)\n\njulia> f = highcorner(I)\ny^4","category":"page"},{"location":"ideal/#Operations-over-local-rings","page":"Ideals","title":"Operations over local rings","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"If the base ring R is a local ring, a minimal generating set can be computed using the following function","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"minimal_generating_set(I::sideal{S}) where S <: spoly","category":"page"},{"location":"ideal/#Singular.minimal_generating_set-Union{Tuple{sideal{S}}, Tuple{S}} where S<:spoly","page":"Ideals","title":"Singular.minimal_generating_set","text":"minimal_generating_set(I::sideal{S}) where S <: spoly\n\nGiven an ideal I in ring R with local ordering, this returns an array containing the minimal generators of I.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]; ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y),(ds(2),C), spoly{n_Q}[x, y])\n\njulia> has_local_ordering(R) == true\ntrue\n\njulia> I = Ideal(R, y, x^2, (1 + y^3) * (x^2 - y))\nSingular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (y, x^2, -y + x^2 - y^4 + x^2*y^3)\n\njulia> min = minimal_generating_set(I)\n2-element Vector{spoly{n_Q}}:\n x^2\n y","category":"page"},{"location":"ideal/#Independent-sets-of-monomial-ideals","page":"Ideals","title":"Independent sets of monomial ideals","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Let I be an ideal of Kx_1  x_n An independent set is a subset u subseteq x_1  x_n such that I cap Ku= 0 In case u cannot be enlarged, it is called non-extendable independent set. If in addition u = dim(Kx_1  x_nI) u is called maximal independent set. Using Singular.jl one can compute non-extendable, resp. maximal independent sets for monomial ideals. If an arbitrary ideal I is passed to the function, the computation is performed on the leading ideal of I.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"independent_sets(I::sideal{spoly{T}}) where T <: Nemo.FieldElem","category":"page"},{"location":"ideal/#Singular.independent_sets-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.independent_sets","text":"independent_sets(I::sideal{spoly{T}}) where T <: Nemo.FieldElem\n\nReturn all non-extendable independent sets of lead(I). I has to be given by a Groebner basis.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"maximal_independent_set(I::sideal{spoly{T}}; all::Bool = false) where T <: Nemo.FieldElem","category":"page"},{"location":"ideal/#Singular.maximal_independent_set-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.maximal_independent_set","text":"maximal_independent_set(I::sideal{spoly{T}}; all::Bool = false) where T <: Nemo.FieldElem\n\nReturns, by default, an array containing a maximal independent set of lead(I). I has to be given by a Groebner basis. If the additional parameter \"all\" is set to true, an array containing all maximal independent sets of lead(I) is returned.\n\n\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"julia> R, (x, y, u, v, w) = polynomial_ring(QQ, [\"x\", \"y\", \"u\", \"v\", \"w\"])\n(Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C), spoly{n_Q}[x, y, u, v, w])\n\njulia> has_local_ordering(R) == true\nfalse\n\njulia> I = Ideal(R, x*y*w, y*v*w, u*y*w, x*v)\nSingular ideal over Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C) with generators (x*y*w, y*v*w, y*u*w, x*v)\n\njulia> I = std(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C) with generators (x*v, y*v*w, y*u*w, x*y*w)\n\njulia> L1 = independent_sets(I)\n5-element Vector{Vector{spoly{n_Q}}}:\n [x, y, u]\n [y, u, v]\n [x, u, w]\n [u, v, w]\n [y, w]\n\njulia> L2 = maximal_independent_set(I)\n3-element Vector{spoly{n_Q}}:\n x\n y\n u\n\njulia> L3 = maximal_independent_set(I, all = true)\n4-element Vector{Vector{spoly{n_Q}}}:\n [x, y, u]\n [y, u, v]\n [x, u, w]\n [u, v, w]","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"GF/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"","category":"section"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Finite fields are implemented via the Singular n_GF type for any characteristic and degree contained in the Singular Conway tables.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"The associated finite field is represented by a parent object which can be constructed by a call to the FiniteField constructor.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"The types of the parent objects and elements of the associated finite fields are given in the following table according to the library providing them.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Library Element type Parent type\nSingular n_GF Singular.N_GField","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"All finite field element types belong directly to the abstract type FieldElem and all the parent object types belong to the abstract type Field.","category":"page"},{"location":"GF/#Finite-field-functionality","page":"Finite fields","title":"Finite field functionality","text":"","category":"section"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Singular.jl finite fields implement the Field interface of AbstractAlgebra.jl.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/fields.html","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Below, we describe the functionality that is specific to Singular finite field and not already listed at the given link.","category":"page"},{"location":"GF/#Constructors","page":"Finite fields","title":"Constructors","text":"","category":"section"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"The following constructors are available to create finite fields and their elements.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Singular.FiniteField(::Int, ::Int, ::VarName; ::Bool)","category":"page"},{"location":"GF/#Singular.FiniteField-Tuple{Int64, Int64, Union{Char, AbstractString, Symbol}}","page":"Finite fields","title":"Singular.FiniteField","text":"FiniteField(p::Int, n::Int, S::VarName; cached=true)\n\nReturn a tuple K, a consisting of a finite field K of characteristic p and degree n, and its generator a. The string used to print the generator is given by S. If the finite field is not listed in the Conway tables included in Singular, an error will be raised. By default, finite fields are cached globally, so that there is only one finite field in the system with given characteristic, degree and string. If this is not the desired behaviour, one can pass false for the optional cached parameter.\n\n\n\n\n\n","category":"method"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Given a finite field R, we also have the following coercions in addition to the standard ones expected.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"R(n::ZZRingElem)","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Coerce a Flint integer value into the field.","category":"page"},{"location":"GF/#Basic-manipulation","page":"Finite fields","title":"Basic manipulation","text":"","category":"section"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Singular.degree(::N_GField)","category":"page"},{"location":"GF/#AbstractAlgebra.degree-Tuple{N_GField}","page":"Finite fields","title":"AbstractAlgebra.degree","text":"degree(R::N_GField)\n\nReturn the degree of the field as an extension of mathbbF_p.\n\n\n\n\n\n","category":"method"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"julia> R,w = FiniteField(7, 2, \"w\")\n(Finite Field of Characteristic 7 and degree 2, w)\n\njulia> w^48 == 1\ntrue\n\njulia> a = R(5)\nw^40\n\njulia> is_unit(a)\ntrue\n\njulia> c = characteristic(R)\n7\n\njulia> d = degree(R)\n2","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"integer/#Integers","page":"Integers","title":"Integers","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"The default integer type in Singular.jl is the Singular n_Z integer type.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"The associated ring of integers is represented by the constant parent object which can be constructed by a call to Singular.Integers().","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"For convenience we define","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"ZZ = Singular.Integers()","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"so that integers can be constructed using ZZ. Note that this is the name of a specific parent object, not the name of its type.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"The types of the integer ring parent objects and elements of the associated rings of integers are given in the following table according to the library providing them.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Library Element type Parent type\nSingular n_Z Singular.Integers","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"All integer element types belong directly to the abstract type RingElem and all the integer ring parent object types belong to the abstract type Ring.","category":"page"},{"location":"integer/#Integer-functionality","page":"Integers","title":"Integer functionality","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"Singular.jl provides all the ring and possibly some parts of the Euclidean ring functionality of AbstractAlgebra.jl.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/ring","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"https://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Below, we describe the functionality that is specific to the Singular integer ring.","category":"page"},{"location":"integer/#Constructors","page":"Integers","title":"Constructors","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"ZZ(n::Integer)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Coerce a Julia integer value into the integer ring.","category":"page"},{"location":"integer/#Basic-manipulation","page":"Integers","title":"Basic manipulation","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"denominator(::n_Z)","category":"page"},{"location":"integer/#Base.denominator-Tuple{n_Z}","page":"Integers","title":"Base.denominator","text":"denominator(n::n_Z)\n\nReturn the denominator of n (which will always be 1).\n\n\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"numerator(::n_Z)","category":"page"},{"location":"integer/#Base.numerator-Tuple{n_Z}","page":"Integers","title":"Base.numerator","text":"numerator(n::n_Z)\n\nReturn the numerator of n (which is n itself).\n\n\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"julia> a = ZZ(-12)\n-12\n\njulia> is_unit(a)\nfalse\n\njulia> n = numerator(a)\n-12\n\njulia> d = denominator(a)\n1\n\njulia> c = abs(a)\n12","category":"page"},{"location":"integer/#Euclidean-division","page":"Integers","title":"Euclidean division","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"Singular.jl provides a number of Euclidean division operations. Recall that for a dividend a and divisor b, we can write a = bq + r with 0 leq r  b. We call q the quotient and r the remainder.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"In the following table we list the division functions and their rounding behaviour. We also give the return value of the function, with q representing return of the quotient and r representing return of the remainder.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function Return Rounding\ndivrem(a::n_Z, b::n_Z) q, r towards zero\nrem(a::n_Z, b::n_Z) r towards zero\nmod(a::n_Z, b::n_Z) r down","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"julia> a = ZZ(-12)\n-12\n\njulia> b = ZZ(5)\n5\n\njulia> q, r = divrem(a, b)\n(-2, -2)\n\njulia> r = mod(a, b)\n3\n\njulia> c = a % b\n-2","category":"page"},{"location":"integer/#Comparison","page":"Integers","title":"Comparison","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"Here is a list of the comparison functions implemented, with the understanding that isless provides all the usual comparison operators.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function\nisless(a::n_Z, b::n_Z)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"We also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function\nisless(a::n_Z, b::Integer)\nisless(a::Integer, b::n_Z)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"julia> a = ZZ(12)\n12\n\njulia> b = ZZ(3)\n3\n\njulia> a < b\nfalse\n\njulia> a != b\ntrue\n\njulia> a > 4\ntrue\n\njulia> 5 <= b\nfalse","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"noncommutative/#Noncommutative-algebras","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"","category":"section"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Singular.jl allows the creation of various noncommutative algebras over any of the coefficient rings described above. The constructors of the parent objects and elements thereof are given in the following table.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Constructor Element type Parent type SINGULAR kernel subsystem\nGAlgebra spluralg{T} PluralRing{T} PLURAL\nWeylAlgebra spluralg{T} PluralRing{T} PLURAL\nFreeAlgebra slpalg{T} LPRing{T} LETTERPLACE","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"These types are parameterized by the type of elements in the coefficient ring of the algebra. All noncommutative algebra element types belong directly to the abstract type AbstractAlgebra.NCRingElem and all the noncommuative algebra parent object types belong to the abstract type AbstractAlgebra.NCRing. The following union types cover all of Singular polynomial rings and algebras.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"const PolyRingUnion{T} = Union{PolyRing{T}, PluralRing{T}, LPRing{T}} where T <: Nemo.RingElem\n\nconst SPolyUnion{T} = Union{spoly{T}, spluralg{T}, slpalg{T}} where T <: Nemo.RingElem","category":"page"},{"location":"noncommutative/#Constructors","page":"Noncommutative algebras","title":"Constructors","text":"","category":"section"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"All constructors returns a tuple, R x consisting of a parent object R and an array x of variables from which elements of the algebra can be constructed.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"For constructors taking an ordering, two orderings can be specified by symbol, one for term ordering, and a second one for ordering of module components. The first ordering can also be specified by a non-symbol as with polynomial_ring, in which case the second ordering is ignored.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"By default there will only be one parent object in the system for each combination of arguments. This is accomplished by making use of a global cache. If this is not the desired behaviour cached = false may be passed.","category":"page"},{"location":"noncommutative/#GAlgebra","page":"Noncommutative algebras","title":"GAlgebra","text":"","category":"section"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"GAlgebra(R::PolyRing{T}, C::smatrix{spoly{T}}, D::smatrix{spoly{T}};\n         cached::Bool = true) where T <: Nemo.RingElem","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Construct the G-algebra from a commutative polynomial ring R and matrices C, D over R. If the variables of R are x_1dotsx_n, then the noncommutative algebra is constructed with relations x_j x_i = c_ij x_i x_j + d_ij for 1 le i  j le n. The c_ij must be nonzero constant polynomials and the relations x_i x_j  mathrmlm(d_ij) must hold in the monomial ordering of the ring R.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"The entries of the matrices C and D on or below the main diagonal are ignored. A non-matrix argument a for either C or D is turned into a matrix with all relevant entries set to a.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"note: Note\nThe conditions that assure that multiplication is associative in the resulting algebra are currently not checked. The example below illustrates how this condition can be checked.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Examples","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]);\n\njulia> G, (x, y) = GAlgebra(R, 2, Singular.Matrix(R, [0 x; 0 0]))\n(Singular G-Algebra (QQ),(x,y),(dp(2),C), spluralg{n_Q}[x, y])\n\njulia> y*x\n2*x*y + x","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Associativity can be checked via Interpreter Functionality.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"julia> iszero(Singular.LibNctools.ndcond(G))\ntrue","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"The construction of a GR-algebra proceeds by taking the quotient of a G-algebra by a two-sided ideal. Continuing with the above example:","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"julia> I = Ideal(G, [x^2 + y^2], twosided = true)\nSingular two-sided ideal over Singular G-Algebra (QQ),(x,y),(dp(2),C) with generators (x^2 + y^2)\n\njulia> Q, (x, y) = QuotientRing(G, std(I))\n(Singular G-Algebra Quotient Ring (QQ),(x,y),(dp(2),C), spluralg{n_Q}[x, y])","category":"page"},{"location":"noncommutative/#WeylAlgebra","page":"Noncommutative algebras","title":"WeylAlgebra","text":"","category":"section"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"function WeylAlgebra(R::Union{Ring, Field}, s::AbstractVector{<:VarName};\n                     ordering = :degrevlex, ordering2::Symbol = :comp1min,\n                     cached::Bool = true, degree_bound::Int = 0)\n\nfunction WeylAlgebra(R::Union{Ring, Field}, s::AbstractMatrix{<:VarName};\n                     ordering = :degrevlex, ordering2::Symbol = :comp1min,\n                     cached::Bool = true, degree_bound::Int = 0)","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Construct the ring of differential operators partial_1 dots partial_n with coefficients in Rx_1 dots x_n. In the first variant, the differential operators are named by simply appending the letter \"d\" to each of the strings in x. The second variant takes the names of the x_i from the first row of the matrix and the names of the partial_i from the second row of the matrix. Note that the functionality of this constructor can be achieved with the GAlgebra constructor: it is provided only for convenience. Note also that due to the ordering constraint on G-algebras, the orderings :neglex, :negdeglex, :negdevrevlex are excluded.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Examples","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"julia> R, (x, y, dx, dy) = WeylAlgebra(ZZ, [\"x\", \"y\"])\n(Singular G-Algebra (ZZ),(x,y,dx,dy),(dp(4),C), spluralg{n_Z}[x, y, dx, dy])\n\njulia> (dx*x, dx*y, dy*x, dy*y)\n(x*dx + 1, y*dx, x*dy, y*dy + 1)","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"The ideals of G-algebras are left ideals by default.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"julia> R, (x1, x2, x3, d1, d2, d3) = WeylAlgebra(QQ, [\"x1\" \"x2\" \"x3\"; \"d1\" \"d2\" \"d3\"])\n(Singular G-Algebra (QQ),(x1,x2,x3,d1,d2,d3),(dp(6),C), spluralg{n_Q}[x1, x2, x3, d1, d2, d3])\n\njulia> gens(std(Ideal(R, [x1^2*d2^2 + x2^2*d3^2, x1*d2 + x3])))\n7-element Vector{spluralg{n_Q}}:\n x1*d2 + x3\n x3^2\n x2*x3 - x1\n x1*x3\n x2^2\n x1*x2\n x1^2","category":"page"},{"location":"noncommutative/#FreeAlgebra","page":"Noncommutative algebras","title":"FreeAlgebra","text":"","category":"section"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"FreeAlgebra(R::Field, s::AbstractVector{<:VarName}, degree_bound::Int;\n            ordering = :degrevlex, ordering2::Symbol = :comp1min,\n            cached::Bool = true)","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Construct the free associative algebra R langle x_1dotsx_n rangle. The ordering must be global.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"note: Note\nSince this uses the LETTERPLACE backend, the degree_bound, which is the maximum length on any monomial word in the algebra, must be specified. Multiplication is checked and throws when the resulting degree exceeds this bound.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Examples","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"julia> R, (x, y) = FreeAlgebra(QQ, [\"x\", \"y\"], 5)\n(Singular letterplace Ring (QQ),(x,y,x,y,x,y,x,y,x,y),(dp(10),C,L(3)), slpalg{n_Q}[x, y])\n\njulia> (x*y)^2\nx*y*x*y\n\njulia> (x*y)^3\nERROR: degree bound of Letterplace ring is 5, but at least 6 is needed for this multiplication","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"The ideals are two-sided by default for this algebra, and there is currently no possibility of constructing one-sided ideals.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"julia> R, (x, y, z) = FreeAlgebra(QQ, [\"x\", \"y\", \"z\"], 4)\n(Singular letterplace Ring (QQ),(x,y,z,x,y,z,x,y,z,x,y,z),(dp(12),C,L(3)), slpalg{n_Q}[x, y, z])\n\njulia> gens(std(Ideal(R, [x*y + y*z, x*x + x*y - y*x - y*y])))\n8-element Vector{slpalg{n_Q}}:\n x*y + y*z\n x^2 - y*x - y^2 - y*z\n y^3 + y*z*y - y^2*z - y*z^2\n y^2*x + y*z*x + y^2*z + y*z^2\n y^2*z*y + y*z^2*y - y^2*z^2 - y*z^3\n y*z*y^2 + y*z^2*y - y*z*y*z - y*z^3\n y^2*z*x + y*z^2*x + y^2*z^2 + y*z^3\n y*z*y*x + y*z^2*x + y*z*y*z + y*z^3","category":"page"},{"location":"noncommutative/#Term-Iterators","page":"Noncommutative algebras","title":"Term Iterators","text":"","category":"section"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"For GAlgebra and WeylAlgebra, the elements can be and are represented using commutative data structures, and the function exponent_vectors is repurposed for access to the individual exponents.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Examples","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"julia> R, (x, y, dx, dy) = WeylAlgebra(QQ, [\"x\", \"y\"])\n(Singular G-Algebra (QQ),(x,y,dx,dy),(dp(4),C), spluralg{n_Q}[x, y, dx, dy])\n\njulia> p = (dx + dy)*(x + y)\nx*dx + y*dx + x*dy + y*dy + 2\n\njulia> show(collect(exponent_vectors(p)))\n[[1, 0, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1], [0, 1, 0, 1], [0, 0, 0, 0]]","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"For FreeAlgebra, the function exponent_vectors is undefined on elements and replaced by exponent_words which reads off in order the indices of the variables in a monomial. Also, the monomials for the MPolyBuildCtx are specified by these exponent words. Other than these differences the term iterators have the same behavior as in the commutative case.","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Examples","category":"page"},{"location":"noncommutative/","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"julia> R, (x, y, z) = FreeAlgebra(QQ, [\"x\", \"y\", \"z\"], 6)\n(Singular letterplace Ring (QQ),(x,y,z,x,y,z,x,y,z,x,y,z,x,y,z,x,y,z),(dp(18),C,L(3)), slpalg{n_Q}[x, y, z])\n\njulia> p = (1 + x*z + y)^2\nx*z*x*z + x*z*y + y*x*z + y^2 + 2*x*z + 2*y + 1\n\njulia> show(collect(coefficients(p)))\nn_Q[1, 1, 1, 1, 2, 2, 1]\n\njulia> show(collect(monomials(p)))\nslpalg{n_Q}[x*z*x*z, x*z*y, y*x*z, y^2, x*z, y, 1]\n\njulia> show(collect(terms(p)))\nslpalg{n_Q}[x*z*x*z, x*z*y, y*x*z, y^2, 2*x*z, 2*y, 1]\n\njulia> show(collect(exponent_words(p)))\n[[1, 3, 1, 3], [1, 3, 2], [2, 1, 3], [2, 2], [1, 3], [2], Int64[]]\n\njulia> B = MPolyBuildCtx(R)\nBuilder for an element of Singular letterplace Ring (QQ),(x,y,z,x,y,z,x,y,z,x,y,z,x,y,z,x,y,z),(dp(18),C,L(3))\n\njulia> push_term!(B, QQ(2), [3,2,1,3]);\n\njulia> push_term!(B, QQ(-1), Int[]);\n\njulia> finish(B)\n2*z*y*x*z - 1","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"resolution/#Resolutions","page":"Resolutions","title":"Resolutions","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Functions for creating free resolutions of modules and ideals in Singular.jl return a special Singular object of type sresolution{T}. The support in Singular.jl for this type primarily exists to allow interaction with such resolutions. Free resolutions can have the property of being minimal, which is specified by the minimal field of the sresolution{T} type.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Resolution objects have a parent object which represents the set of resolutions they belong to, the data for which is given by the polynomial ring R over which the modules in the resolution are defined.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"The types of resolutions and associated parent objects are given in the following table according to the library providing them.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Library Element type Parent type\nSingular sresolution{T} Singular.ResolutionSet{T}","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"These types are parameterised by the type of elements in the polynomial ring R over which the modules belonging to the resolution are defined.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"All resolution types belong directly to the abstract type SetElem and all the resolution set parent object types belong to the abstract type Set.","category":"page"},{"location":"resolution/#Resolution-functionality","page":"Resolutions","title":"Resolution functionality","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Singular.jl resolutions implement standard operations one would expect on all AbstractAlgebra compatible objects. These include:","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Below, we describe all of the functionality for Singular.jl resolutions that is not included in this list of basic operations.","category":"page"},{"location":"resolution/#Constructors","page":"Resolutions","title":"Constructors","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"There are currently two ways to create resolutions in Singular.jl: They can either be created by taking the free resolution of an ideal or module over a polynomial ring, as described in the relevant sections of the documentation, or they can be created by the following constructor:","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Resolution(::Vector{smodule{T}}) where T <: AbstractAlgebra.FieldElem","category":"page"},{"location":"resolution/#Singular.Resolution-Union{Tuple{Array{smodule{T}, 1}}, Tuple{T}} where T<:AbstractAlgebra.FieldElem","page":"Resolutions","title":"Singular.Resolution","text":"Resolution(C::Vector{smodule{T}}) where T <: AbstractAlgebra.RingElem\n\nCreate a new resolution whose maps are given by the elements of an array C of modules. Note that it is not checked that the maps are actually composable and that their pairwise composition is the zero map, that is, that the created resolution is a complex.\n\n\n\n\n\n","category":"method"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Example","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular Polynomial Ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> M1 = Singular.Module(R, vector(R, x), vector(R, y))\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\nx*gen(1)\ny*gen(1)\n\njulia> M2 = Singular.Module(R, vector(R, y, -x))\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\n-x*gen(2)+y*gen(1)\n\njulia> F = Resolution([M1, M2]);\n\njulia> F[1]\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\nx*gen(1)\ny*gen(1)\n\njulia> F[2]\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\n-x*gen(2)+y*gen(1)","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Alternatively, resolutions can be refined to minimal resolutions, as described below.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Other than this, there are currently no additional ways to create resolutions in Singular.jl.","category":"page"},{"location":"resolution/#Basic-manipulation","page":"Resolutions","title":"Basic manipulation","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"length(::sresolution)","category":"page"},{"location":"resolution/#Base.length-Tuple{sresolution}","page":"Resolutions","title":"Base.length","text":"length(r::sresolution)\n\nReturn the length of the resolution. This is what is mathematically meant by the length of a resolution. Over a field, this should be at most the number of variables in the polynomial ring.\n\n\n\n\n\n","category":"method"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Singular.jl overloads the getindex function so that one can access the modules in a resolution F.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"F[n::Int]","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Examples","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"julia> R, (w, x, y, z) = polynomial_ring(QQ, [\"w\", \"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C), spoly{n_Q}[w, x, y, z])\n\njulia> I = Ideal(R, w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\nSingular ideal over Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C) with generators (w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\n\njulia> F = fres(std(I), 0)\nSingular Resolution:\nR^1 <- R^5 <- R^6 <- R^2\n\njulia> n = length(F)\n3\n\njulia> M1 = F[1]\nSingular ideal over Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C) with generators (y^2 - w*z, x*y - z^2, x^2 - w*y, w*x - y*z, w^2 - x*z)","category":"page"},{"location":"resolution/#Betti-numbers","page":"Resolutions","title":"Betti numbers","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"betti(::sresolution)","category":"page"},{"location":"resolution/#Singular.betti-Tuple{sresolution}","page":"Resolutions","title":"Singular.betti","text":"betti(r::sresolution)\n\nReturn the Betti numbers, i.e. the ranks of the free modules in the given free resolution. These are returned as a Julia array of Ints. Note that the output of this command is useful only in the graded case.\n\n\n\n\n\n","category":"method"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Examples","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"julia> R, (w, x, y, z) = polynomial_ring(QQ, [\"w\", \"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C), spoly{n_Q}[w, x, y, z])\n\njulia> I = Ideal(R, w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\nSingular ideal over Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C) with generators (w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\n\njulia> F = fres(std(I), 3)\nSingular Resolution:\nR^1 <- R^5 <- R^6 <- R^2\n\njulia> M = minres(F)\nSingular Resolution:\nR^1 <- R^5 <- R^5 <- R^1\n\njulia> B = betti(M)\n3×4 Matrix{Int32}:\n 1  0  0  0\n 0  5  5  0\n 0  0  0  1","category":"page"},{"location":"resolution/#Minimal-resolutions","page":"Resolutions","title":"Minimal resolutions","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"minres{T <: Nemo.FieldElem}(::sresolution{spoly{T}})","category":"page"},{"location":"resolution/#Singular.minres-Union{Tuple{sresolution{spoly{T}}}, Tuple{T}} where T<:AbstractAlgebra.FieldElem","page":"Resolutions","title":"Singular.minres","text":"minres{T <: Nemo.FieldElem}(r::sresolution{spoly{T}})\n\nReturn a minimal free resolution, given any free resolution. In the graded case, there exists a uniquely determined minimal resolution. If the supplied resolution is already minimal, it may be returned without making a copy.\n\n\n\n\n\n","category":"method"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Examples","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"julia> R, (w, x, y, z) = polynomial_ring(QQ, [\"w\", \"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C), spoly{n_Q}[w, x, y, z])\n\njulia> I = Ideal(R, w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\nSingular ideal over Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C) with generators (w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\n\njulia> F = fres(std(I), 3)\nSingular Resolution:\nR^1 <- R^5 <- R^6 <- R^2\n\njulia> M = minres(F)\nSingular Resolution:\nR^1 <- R^5 <- R^5 <- R^1","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Singular.jl is a Julia interface to the Singular computer algebra system. It was written by Oleksandr Motsak, William Hart and other contributors, and is maintained by Hans Schoenemann and Max Horn. It is part of the Oscar project which is supported by the Deutsche Forschungsgemeinschaft DFG within the Collaborative Research Center TRR 195.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"https://www.singular.uni-kl.de/ (Singular website)\nhttps://github.com/oscar-system/Singular.jl (Singular.jl source code)\nhttps://oscar-system.github.io/Singular.jl/stable/ (Singular.jl online documentation)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"The features of Singular so far include:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Singular integers, rationals Z/nZ, Z/pZ, Galois fields\nMultivariate polynomials, including several noncommutative variants\nIdeals over polynomial rings\nFree modules over polynomial rings and submodules given by a finite generating set\nGroebner basis over a field\nFree/minimal resolutions\nSyzygy modules\nNemo.jl rings can be used as coefficient rings","category":"page"},{"location":"#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"To use Singular.jl we require Julia 1.6 or higher. Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"At the Julia prompt simply type","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg; Pkg.add(\"Singular\")","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Here is an example of using Singular.jl","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y + 1)\n\njulia> G = std(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x - y, y^2 + 1)\n\njulia> Z = syz(G)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\ny^2*gen(1)-x*gen(2)+y*gen(2)+gen(1)\n\njulia> F = fres(G, 0)\nSingular Resolution:\nR^1 <- R^2 <- R^1\n\njulia> F[1]\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x - y, y^2 + 1)","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"CurrentModule = Singular\nDocTestSetup = quote\n  using Singular\nend","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"DocTestSetup = quote\n  using Singular\n  using Singular: polynomial_ring, vector, std, reduce\nend","category":"page"},{"location":"module/#Finitely-generated-modules","page":"Finitely generated modules","title":"Finitely generated modules","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Singular.jl allows the creation of submodules of a free module over a Singular polynomial ring, given by a finite generating set. These are internally stored as a list of elements of a free module over a polynomial ring R. This list of generators can also have the property of being a Groebner basis.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"The default finitely generated module type in Singular.jl is the Singular smodule type.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Module objects have a parent object which represents the class of R-modules they belong to, the data for which is given by the polynomial ring R over which the modules are defined.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"The types of modules and associated parent objects are given in the following table according to the library providing them.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Library Element type Parent type\nSingular smodule{T} Singular.ModuleClass{T}","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"These types are parameterised by the type of elements in the polynomial ring R.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"All module types belong directly to the abstract type Module{T} and all the module class parent object types belong to the abstract type Set.","category":"page"},{"location":"module/#Module-functionality","page":"Finitely generated modules","title":"Module functionality","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Singular.jl modules implement standard operations one would expect on modules. These include:","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Below, we describe all of the functionality for Singular.jl modules that is not included in this list of basic operations.","category":"page"},{"location":"module/#Constructors","page":"Finitely generated modules","title":"Constructors","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Given a Singular polynomial ring R, the following constructors are available for creating modules.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Module{T <: Nemo.RingElem}(R::PolyRing{T}, vecs::svector{spoly{T}}...)","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Construct the module over the polynomial ring R whose generators are given by the given parameter list of vectors (of length n), each component of which is a polynomial. These vectors represent elements of the free module R^n.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Note that Module must be prepended with the package name Singular to disambiguate from Base.Module.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^2 + 1, 2x + 3y, x)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> M = Singular.Module(R, v1, v2)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)","category":"page"},{"location":"module/#Basic-manipulation","page":"Finitely generated modules","title":"Basic manipulation","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"ngens(::smodule)","category":"page"},{"location":"module/#GroupsCore.ngens-Tuple{smodule}","page":"Finitely generated modules","title":"GroupsCore.ngens","text":"ngens(I::smodule)\n\nReturn the number of generators in the current representation of the module (as a list of vectors).\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"rank(::smodule)","category":"page"},{"location":"module/#LinearAlgebra.rank-Tuple{smodule}","page":"Finitely generated modules","title":"LinearAlgebra.rank","text":"rank(I::smodule)\n\nReturn the rank n of the ambient space R^n of which this module is a submodule.\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Singular.jl overloads the setindex! and getindex functions so that one can access the generators of a module using array notation. Each entry is a vector in R^n.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"M[n::Int]","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"iszero(::smodule)","category":"page"},{"location":"module/#Base.iszero-Tuple{smodule}","page":"Finitely generated modules","title":"Base.iszero","text":"iszero(p::smodule)\n\nReturn true if this is algebraically the zero module.\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^2 + 1, 2x + 3y, x)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> M = Singular.Module(R, v1, v2)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> iszero(M) == false\ntrue\n\njulia> M[1] == v1\ntrue\n\njulia> n = rank(M)\n3\n\njulia> d = ngens(M)\n2","category":"page"},{"location":"module/#Standard-basis","page":"Finitely generated modules","title":"Standard basis","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"std(::smodule; ::Bool)","category":"page"},{"location":"module/#Statistics.std-Tuple{smodule}","page":"Finitely generated modules","title":"Statistics.std","text":"std(I::smodule; complete_reduction::Bool=false)\n\nCompute the Groebner basis of the module I. If complete_reduction is set to true, the result is unique, up to permutation of the generators and multiplication by constants. If not, only the leading terms are unique (up to permutation of the generators and multiplication by constants, of course). Presently the polynomial ring used must be over a field or over the Singular integers.\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"lift_std(::smodule; ::Bool)","category":"page"},{"location":"module/#Singular.lift_std-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.lift_std","text":"lift_std(M::smodule)\n\nComputes the Groebner base G of M and the transformation matrix T such that (Matrix(G) = Matrix(M) * T).\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"lift_std_syz(::smodule; ::Bool)","category":"page"},{"location":"module/#Singular.lift_std_syz-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.lift_std_syz","text":"lift_std_syz(M::smodule)\n\nComputes the Groebner base G of M, the transformation matrix T and the syzygies of M. Returns a tuple (G,T,S) satisfying (Matrix(G) = Matrix(M) * T, 0=Matrix(M)*Matrix(S)).\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^2 + 1, 2x + 3y, x)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> v3 = x*v1 + y*v2 + vector(R, x, y + 1, y^2)\nx^2*y*gen(2)+x^2*y*gen(1)+x^2*gen(1)+2*x*y*gen(3)+2*x*y*gen(2)+y^2*gen(3)+3*y^2*gen(2)+x*gen(2)+2*x*gen(1)+y*gen(2)+y*gen(1)+gen(2)\n\njulia> M = Singular.Module(R, v1, v2, v3)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\nx^2*y*gen(2)+x^2*y*gen(1)+x^2*gen(1)+2*x*y*gen(3)+2*x*y*gen(2)+y^2*gen(3)+3*y^2*gen(2)+x*gen(2)+2*x*gen(1)+y*gen(2)+y*gen(1)+gen(2)\n\njulia> G = std(M; complete_reduction=true)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\ny^2*gen(3)+x*gen(1)+y*gen(2)+gen(2)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)","category":"page"},{"location":"module/#Reduction","page":"Finitely generated modules","title":"Reduction","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"reduce(::smodule, ::smodule)","category":"page"},{"location":"module/#Base.reduce-Tuple{smodule, smodule}","page":"Finitely generated modules","title":"Base.reduce","text":"reduce(M::smodule, G::smodule; complete_reduction::Bool = true)\n\nReturn a submodule whose generators are the generators of M reduced by the submodule G. The submodule G need not be a Groebner basis. The returned submodule will have the same number of generators as M, even if they are zero.\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"julia> R, (x, y, z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])\n\njulia> v1 = vector(R, R(0), z, -y)\n-y*gen(3)+z*gen(2)\n\njulia> v2 = vector(R, -z, R(0), x)\nx*gen(3)-z*gen(1)\n\njulia> v3 = vector(R, y, x, R(0))\nx*gen(2)+y*gen(1)\n\njulia> v = y*v1+x*v2+z*v3\nx^2*gen(3)-y^2*gen(3)+x*z*gen(2)-x*z*gen(1)+y*z*gen(2)+y*z*gen(1)\n\njulia> M = Singular.Module(R, v1, v2, v3)\nSingular Module over Singular polynomial ring (QQ),(x,y,z),(dp(3),C), with Generators:\n-y*gen(3)+z*gen(2)\nx*gen(3)-z*gen(1)\nx*gen(2)+y*gen(1)\n\njulia> B = std(M; complete_reduction=true)\nSingular Module over Singular polynomial ring (QQ),(x,y,z),(dp(3),C), with Generators:\ny*gen(3)-z*gen(2)\nx*gen(2)+y*gen(1)\nx*gen(3)-z*gen(1)\ny*z*gen(1)\n\njulia> V = Singular.Module(R, v)\nSingular Module over Singular polynomial ring (QQ),(x,y,z),(dp(3),C), with Generators:\nx^2*gen(3)-y^2*gen(3)+x*z*gen(2)-x*z*gen(1)+y*z*gen(2)+y*z*gen(1)\n\njulia> reduce(V,B)\nSingular Module over Singular polynomial ring (QQ),(x,y,z),(dp(3),C), with Generators:\n0\n","category":"page"},{"location":"module/#Syzygies","page":"Finitely generated modules","title":"Syzygies","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"syz(::smodule)","category":"page"},{"location":"module/#Singular.syz-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.syz","text":"syz(M::smodule)\n\nCompute the module of syzygies of the given module. This will be given as a set of generators in an ambient space R^n, where n is the number of generators in M.\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, (x + 1)*y, (x*y + 1)*y, y)\nx*y^2*gen(2)+x*y*gen(1)+y*gen(3)+y*gen(2)+y*gen(1)\n\njulia> v2 = vector(R, (x + 1)*x, (x*y + 1)*x, x)\nx^2*y*gen(2)+x^2*gen(1)+x*gen(3)+x*gen(2)+x*gen(1)\n\njulia> M = Singular.Module(R, v1, v2)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\nx*y^2*gen(2)+x*y*gen(1)+y*gen(3)+y*gen(2)+y*gen(1)\nx^2*y*gen(2)+x^2*gen(1)+x*gen(3)+x*gen(2)+x*gen(1)\n\njulia> Z = syz(M)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\nx*gen(1)-y*gen(2)","category":"page"},{"location":"module/#Free-resolutions","page":"Finitely generated modules","title":"Free resolutions","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"sres{T <: Singular.FieldElem}(::smodule{spoly{T}}, ::Int)","category":"page"},{"location":"module/#Singular.sres-Union{Tuple{T}, Tuple{smodule{spoly{T}}, Int64}} where T<:AbstractAlgebra.FieldElem","page":"Finitely generated modules","title":"Singular.sres","text":"sres(I::smodule{spoly{T}}, max_length::Int) where T <: Singular.FieldElem\n\nCompute a free resolution of the given module I of length up to the given maximum length. If max_length is set to zero, a full length free resolution is computed. Each element of the resolution is itself a module.\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^2 + 1, 2x + 3y, x)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> M = std(Singular.Module(R, v1, v2))\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> F = sres(M, 0)\nSingular Resolution:\nR^3 <- R^2\n\njulia> M1 = Singular.Matrix(M)\n[x + 1, x^2 + 1\nx*y + 1, 2*x + 3*y\ny, x]\n\njulia> M2 = Singular.Matrix(F[2])\n[0\n0]\n\njulia> iszero(M1*M2) # test we have a complex\ntrue","category":"page"},{"location":"module/#Jet-of-module","page":"Finitely generated modules","title":"Jet of module","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"jet(::smodule, ::Int)","category":"page"},{"location":"module/#Singular.jet-Tuple{smodule, Int64}","page":"Finitely generated modules","title":"Singular.jet","text":"jet(M::smodule, n::Int)\n\nGiven a module M this function truncates the generators of M up to degree n.\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^5 + 1, 2x^3 + 3y^2, x^2)\nx^5*gen(1)+2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)\n\njulia> M = Singular.Module(R, v1, v2)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^5*gen(1)+2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)\n\njulia> N = jet(M,3)\nSingular Module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with Generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)","category":"page"},{"location":"module/#Operations-over-local-rings","page":"Finitely generated modules","title":"Operations over local rings","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"If the base ring R is a local ring, a minimal generating set can be computed using the following function","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"minimal_generating_set(::smodule)","category":"page"},{"location":"module/#Singular.minimal_generating_set-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.minimal_generating_set","text":"minimal_generating_set(M::smodule)\n\nReturn a vector containing the minimal generators of M.\n\n\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"julia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]; ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y),(ds(2),C), spoly{n_Q}[x, y])\n\njulia> has_local_ordering(R) == true\ntrue\n\njulia> v1 = vector(R, x, y^2)\nx*gen(1)+y^2*gen(2)\n\njulia> v2 = vector(R, y - x, y - y^2)\n-x*gen(1)+y*gen(2)+y*gen(1)-y^2*gen(2)\n\njulia> v3 = v1 + v2\ny*gen(2)+y*gen(1)\n\njulia> M = Singular.Module(R, v1, v2, v3)\nSingular Module over Singular polynomial ring (QQ),(x,y),(ds(2),C), with Generators:\nx*gen(1)+y^2*gen(2)\n-x*gen(1)+y*gen(2)+y*gen(1)-y^2*gen(2)\ny*gen(2)+y*gen(1)\n\njulia> min = minimal_generating_set(M)\n2-element Vector{svector{spoly{n_Q}}}:\n y*gen(2)+y*gen(1)\n x*gen(1)-y*gen(2)-y*gen(1)+y^2*gen(2)","category":"page"}]
}
