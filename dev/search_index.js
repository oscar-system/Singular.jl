var documenterSearchIndex = {"docs":
[{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"CurrentModule = Singular","category":"page"},{"location":"polynomial/#Multivariate-polynomials","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.jl allows the creation of multivariate polynomials over any of the coefficient rings described above.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The default multivariate polynomial type in Singular.jl is the Singular spoly type.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The associated polynomial ring is represented by a parent object which can be constructed by a call to the PolynomialRing constructor.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The types of the polynomial ring parent objects and elements thereof are given in the following table according to the library providing them.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Library Element type Parent type\nSingular spoly{T} Singular.PolyRing{T}","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"These types are parameterised by the type of elements in the coefficient ring of the polynomials.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"All polynomial types belong directly to the abstract type MPolyElem and all the polynomial ring parent object types belong to the abstract type MPolyRing.","category":"page"},{"location":"polynomial/#Multivariate-polynomial-functionality","page":"Multivariate polynomials","title":"Multivariate polynomial functionality","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.jl polynomials implement the Multivariate Polynomial Ring interface of AbstractAlgebra.jl.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/mpolynomial_rings.html","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"In particular, Singular polynomials are sparse distributed, but do not have random access. Instead, they implement iterator access to terms. This is due to their storage in a linked list, for efficient implementation of Groebner basis algorithms.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Some polynomial rings may also implement part of the Euclidean Ring interface, where this is appropriate.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Below, we describe the functionality that is specific to the Singular multivariate polynomials that is not documented in the general multivariate interface.","category":"page"},{"location":"polynomial/#Constructors","page":"Multivariate polynomials","title":"Constructors","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"PolynomialRing(R::Union{Ring, Field}, s::Array{String, 1};\n   cached::Bool = true, ordering::Symbol = :degrevlex,\n      ordering2::Symbol = :comp1min, degree_bound::Int = 0)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Returns a tuple, S x consisting of a multivariate polynomial ring S and an array x of variables (from which polynomials can be constructed). The ring R must be a valid Singular coefficient ring, or any Nemo/AbstractAlgebra coefficient ring. The array s must be a list of strings corresponding to how the variables will be printed. By default, there will only be one Singular polynomial ring in the system for each combination of coefficient ring, list of variable names, ordering and degree bound. This is accomplished by making use of a global cache. If this is not the desired behaviour, false can be passed to the optional argument cached.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Two orderings can be specified, one for term ordering of the polynomials, and another for ordering of module components. They can occur in either order, the first taking precedence over the other, when the polynomials are used to represent module generators. If either is not specified, the indicated default is used.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The options for polynomial term ordering are the symbols, :lex, :deglex, :degrevlex, :neglex, :negdeglex and :negdegrevlex, and the options for module component ordering are comp1min and comp1max.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"If one has an a priori bound on the degree in each variable of a polynomial (including for all intermediate computations in this ring), one can specify it using the degree_bound optional parameter. Singular may then be able to use a more efficient representation internally, which will use less memory and allow for faster arithmetic. By default, Singular uses a bound of 16 bits internally for the exponent of each variable, however this is a signed value, so that the default is for nonnegative exponents that fit in 15 bits.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Note that internally, Singular may use a higher bound than specified, if it will not increase the amount of storage required.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R, (x, y, z) = PolynomialRing(ZZ, [\"x\", \"y\", \"z\"])\n\nS, vars = PolynomialRing(QQ, [\"x\", \"y\"]; ordering=:deglex)\n\nT, x = PolynomialRing(ZZ, [\"x$i\" for i in 1:5];\n       ordering=:comp1max, ordering2=:degrevlex, degree_bound=5)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"See also the convenience macros below for simple use cases.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The following function allows creating a Singular polynomial ring from a given polynomial ring of type AbstractAlgebra.Generic.MPolyRing:","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"PolynomialRing(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true, ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min, degree_bound::Int = 0)  where {T <: RingElement}","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Polynomials can be constructed using arithmetic operations on the generators, but this can be extremely inefficient. For this purpose, Singular polynomials support construction using a build context, as described in the AbstractAlgebra documentation:","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/mpolynomial_rings.html","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\nC = MPolyBuildCtx(R)\n\npush_term!(C, ZZ(1), [1, 2])\npush_term!(C, ZZ(3), [1, 1])\npush_term!(C, -ZZ(1), [0, 1])\nf = finish(C)","category":"page"},{"location":"polynomial/#Polynomial-ring-macros","page":"Multivariate polynomials","title":"Polynomial ring macros","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"For convenience, we provide some macros for constructing polynomial rings and injecting the variables into scope. These are easier to use, but have some limitations. In particular, they can only be used at the top level by the user, and cannot be used programmatically or in library code (it is not possible to inject an arbitrary number of variables into scope inside a function).","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The macros are designed for simple use cases, and do not offer the full power of the most general constructor above.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"@PolynomialRing(R, s, n, o)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Given a coefficient ring R, a root variable name, e.g. \"x\", a number of variable n and a polynomial term ordering o, create the variables x1, x2, ..., xn and inject them into scope, and return the corresponding polynomial ring S.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"@PolynomialRing(R, s, n)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"As per the previous macro, with a default of :degrevlex for the polynomial term ordering.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"S = @PolynomialRing(ZZ, \"x\", 5, :deglex)\n\nT = @PolynomialRing(QQ, \"y\", 10)","category":"page"},{"location":"polynomial/#Basic-manipulation","page":"Multivariate polynomials","title":"Basic manipulation","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"nvars(::PolyRing)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.nvars-Tuple{PolyRing}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.nvars","text":"nvars(R::PolyRing)\n\nReturn the number of variables in the given polynomial ring.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"symbols(::PolyRing)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.symbols-Tuple{PolyRing}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.symbols","text":"symbols(R::PolyRing)\n\nReturn symbols for the generators of the polynomial ring R.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"has_global_ordering(R::PolyRing)","category":"page"},{"location":"polynomial/#Singular.has_global_ordering-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.has_global_ordering","text":"has_global_ordering(R::PolyRing)\n\nReturn true if the given ring has a global ordering, i.e. if 1  x for each variable x in the ring. This include :lex, :deglex and :degrevlex orderings.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"has_mixed_ordering(R::PolyRing)","category":"page"},{"location":"polynomial/#Singular.has_mixed_ordering-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.has_mixed_ordering","text":"has_mixed_ordering(R::PolyRing)\n\nReturn true if the given ring has a mixed ordering, i.e. if 1  x_i for a variable x_i and 1x_j for another variable x_j.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"has_local_ordering(R::PolyRing)","category":"page"},{"location":"polynomial/#Singular.has_local_ordering-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.has_local_ordering","text":"has_local_ordering(R::PolyRing)\n\nReturn true if the given ring has a local ordering, i.e. if 1  x for all variables x.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.characteristic(R::PolyRing)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"degree_bound(R::PolyRing)","category":"page"},{"location":"polynomial/#Singular.degree_bound-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.degree_bound","text":"degree_bound(R::PolyRing)\n\nReturn the internal degree bound in each variable, enforced by Singular. This is the largest positive value any degree can have before an overflow will occur. This internal bound may be higher than the bound requested by the user via the degree_bound parameter of the PolynomialRing constructor.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"lead_exponent(p::spoly)","category":"page"},{"location":"polynomial/#Singular.lead_exponent-Tuple{spoly}","page":"Multivariate polynomials","title":"Singular.lead_exponent","text":"lead_exponent(p::spoly)\n\nReturn the exponent vector of the leading term of the given polynomial. The return value is a Julia 1-dimensional array giving the exponent for each variable of the leading term.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"total_degree(p::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.total_degree-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.total_degree","text":"total_degree(p::spoly)\n\nReturn the total degree (largest sum of exponents of any monomial) of p.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"order(p::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.order-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.order","text":"order(p::spoly)\n\nReturns the order of p.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R = @PolynomialRing(ZZ, \"x\", 3)\n\nn = ngens(R)\nhas_global_ordering(R) == true\nc = characteristic(R)\nL = degree_bound(R)\nexps = lead_exponent(x1*x2 + 3x1*x2^2 + x3 + 2)\ndeg = total_degree(x1*x2 + 3x1*x2^2 + x3 + 2)\nord = order(x1*x2 + 3x1*x2^2 + x3 + 2)","category":"page"},{"location":"polynomial/#Differential-functions","page":"Multivariate polynomials","title":"Differential functions","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Working over any coefficient ring, basic functionality involving differential operations is available.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.jet(::spoly, ::Int)","category":"page"},{"location":"polynomial/#Singular.jet-Tuple{spoly, Int64}","page":"Multivariate polynomials","title":"Singular.jet","text":"jet(x::spoly, n::Int) Given a polynomial x this function truncates x up to degree n.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.derivative(::spoly, ::Int)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.derivative-Tuple{spoly, Int64}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.derivative","text":"derivative(x::spoly, n::Int) Given a polynomial x this function returns the derivative of x with respect to the variable with number n.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.derivative(::spoly, ::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.derivative-Tuple{spoly, spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.derivative","text":"derivative(x::spoly, v::spoly) Given a polynomial x this function returns the derivative of x with respect to the variable v.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.jacobian_ideal(::spoly)","category":"page"},{"location":"polynomial/#Singular.jacobian_ideal-Tuple{spoly}","page":"Multivariate polynomials","title":"Singular.jacobian_ideal","text":"jacobian_ideal(x::spoly) Given a polynomial x this function returns the Jacobian ideal of x.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.jacobian_matrix(::spoly)","category":"page"},{"location":"polynomial/#Singular.jacobian_matrix-Tuple{spoly}","page":"Multivariate polynomials","title":"Singular.jacobian_matrix","text":"jacobian_matrix(x::spoly) Given a polynomial x this function returns the Jacobian matrix of x.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.jacobian_matrix(A::Vector{spoly{T}}) where T <: Nemo.RingElem","category":"page"},{"location":"polynomial/#Singular.jacobian_matrix-Union{Tuple{Array{spoly{T}, 1}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.jacobian_matrix","text":"jacobian_matrix(A::Vector{spoly, 1}) Given an array A of polynomials over the same base ring, this function returns the Jacobian matrix of A.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n\nf = x^2*y*z + z^2*x + x*y*z\n\ng = jet(f, 3)\n\nderivative(f, 1)\n\nderivative(f, y)\n\nJ = jacobian_ideal(f)\n\nJf1 = jacobian_matrix(f)\n\nJf2 = jacobian_matrix([f, g])","category":"page"},{"location":"polynomial/#Content-and-primitive-part","page":"Multivariate polynomials","title":"Content and primitive part","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"When coefficient rings have a meaningful GCD function, the following functions are available.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.primpart(x::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.primpart-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.primpart","text":"primpart(x::spoly)\n\nReturn the primitive part of the polynomial, i.e. the polynomial divided by the GCD of its coefficients.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.content(x::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.Generic.content-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.content","text":"content(x::spoly)\n\nReturn the content of the polynomial, i.e. the GCD of its coefficients.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R = @PolynomialRing(ZZ, \"x\", 2)\n\nf = 3x1^2 + 3x1*x2 + 6x2^2\n\np = primpart(f)\nc = content(f)","category":"page"},{"location":"polynomial/#Multivariate-Factorisation","page":"Multivariate polynomials","title":"Multivariate Factorisation","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"For the Singular base fields QQ and Fp a function to compute a squarefree factorization is available.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.factor_squarefree(p::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.factor_squarefree-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.factor_squarefree","text":"factor_squarefree(x::spoly)\n\nReturns a squarefree factorization of x.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R = @PolynomialRing(QQ, \"x\", 4)\n\nf = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2\n\nFac = factor(f)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"For the Singular base rings QQ, ZZ and Fp a function to compute the multivariate factorization is available.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.factor(p::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.factor-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.factor","text":"factor(x::spoly)\n\nReturns the factorization of x.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R = @PolynomialRing(ZZ, \"x\", 4)\n\nf = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2\n\nFac = factor(f)","category":"page"},{"location":"polynomial/#Change-of-coefficient-rings","page":"Multivariate polynomials","title":"Change of coefficient rings","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"It is possible to change the coefficient ring of a given polynomial p via the function 'changebasering'.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.change_base_ring(C::Union{Ring, Field}, p::spoly)","category":"page"},{"location":"polynomial/#AbstractAlgebra.change_base_ring-Tuple{Union{Singular.Field, Singular.Ring}, spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.change_base_ring","text":"changebasering(C::T, p::spoly) where T <: Union{Ring, Field}\n\nReturn a polynomial ring, whose coefficient ring is subsituted by the ring C.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n\np = x^5 + y^3+1\n\nchange_base_ring(QQ, p)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"It also possible to work with Nemo rings, if a type conversion for the Singular coefficients is implemented. One has to cast the Nemo ring via 'CoefficientRing' to a suitable Singular type.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n\np = x^5 + y^3+1\n\nchange_base_ring(CoefficientRing(Nemo.QQ), p)","category":"page"},{"location":"polynomial/#Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials","page":"Multivariate polynomials","title":"Conversion between Singular.jl polynomials and MPoly polynomials","text":"","category":"section"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"There are conversion functions between the polynomial ring implementation from Singular.jl and the generic MPoly implementation from AbstractAlgebra.jl.","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"AsEquivalentSingularPolynomialRing(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true,\n      ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min,\n      degree_bound::Int = 0)  where {T <: RingElem}","category":"page"},{"location":"polynomial/#Singular.AsEquivalentSingularPolynomialRing-Union{Tuple{AbstractAlgebra.Generic.MPolyRing{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.AsEquivalentSingularPolynomialRing","text":"AsEquivalentSingularPolynomialRing(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true,\n  ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min,\n  degree_bound::Int = 0)  where {T <: RingElem}\n\nReturn a Singular (multivariate) polynomial ring over the base ring of R in variables having the same names as those of R.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"AsEquivalentAbstractAlgebraPolynomialRing(R::Singular.PolyRing{Singular.n_unknown{T}}; ordering::Symbol = :degrevlex)  where {T <: Nemo.RingElem}","category":"page"},{"location":"polynomial/#Singular.AsEquivalentAbstractAlgebraPolynomialRing-Union{Tuple{PolyRing{Singular.n_unknown{T}}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.AsEquivalentAbstractAlgebraPolynomialRing","text":"AsEquivalentAbstractAlgebraPolynomialRing(R::Singular.PolyRing{Singular.n_unknown{T}}; ordering::Symbol = :degrevlex)  where {T <: RingElem}\n\nReturn an AbstractAlgebra (multivariate) polynomial ring over the base ring of R in variables having the same names as those of R.\n\n\n\n","category":"method"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Examples","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Conversion of generic AbstractAlgebra polynomials to Singular.jl polynomials:","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"K = Nemo.ZZ\nR, (x, y) = AbstractAlgebra.Generic.PolynomialRing(K, [\"x\", \"y\"]);\nRsing, vars_Rsing = Singular.AsEquivalentSingularPolynomialRing(R);\nRsing(x + y) == Rsing(x) + Rsing(y)","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Conversion of Singular.jl polynomials to generic AbstractAlgebra polynomials:","category":"page"},{"location":"polynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"K = Nemo.ZZ\nS, (u, v) = Singular.PolynomialRing(K, [\"u\", \"v\"])\nSaa, (uu, vv) = Singular.AsEquivalentAbstractAlgebraPolynomialRing(S)\nSaa(u) + Saa(v) == Saa(u) + Saa(v)","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"CurrentModule = Singular","category":"page"},{"location":"modn/#Integers-mod-n","page":"Integers mod n","title":"Integers mod n","text":"","category":"section"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Integers mod n are implemented via the Singular n_Zn type for any positive modulus that can fit in a Julia Int.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"The associated ring of integers mod n is represented by a parent object which can be constructed by a call to the ResidueRing constructor.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"The types of the parent objects and elements of the associated rings of integers modulo n are given in the following table according to the library providing them.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Library Element type Parent type\nSingular n_Zn Singular.N_ZnRing","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"All integer mod n element types belong directly to the abstract type RingElem and all the parent object types belong to the abstract type Ring.","category":"page"},{"location":"modn/#Integer-mod-n-functionality","page":"Integers mod n","title":"Integer mod n functionality","text":"","category":"section"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Singular.jl integers modulo n implement the Ring and Residue Ring interfaces of AbstractAlgebra.jl.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"https://nemocas.github.io/AbstractAlgebra.jl/rings.html","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"https://nemocas.github.io/AbstractAlgebra.jl/residue_rings.html","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Parts of the Euclidean Ring interface may also be implemented, though Singular will report an error if division is meaningless (even after cancelling zero divisors).","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Below, we describe the functionality that is specific to the Singular integers mod n ring and not already listed at the given links.","category":"page"},{"location":"modn/#Constructors","page":"Integers mod n","title":"Constructors","text":"","category":"section"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Given a ring R of integers modulo n, we also have the following coercions in addition to the standard ones expected.","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"R(n::n_Z)\nR(n::fmpz)","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Coerce a Singular or Flint integer value into the ring.","category":"page"},{"location":"modn/#Basic-manipulation","page":"Integers mod n","title":"Basic manipulation","text":"","category":"section"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"isunit(::n_Zn)","category":"page"},{"location":"modn/#AbstractAlgebra.isunit-Tuple{n_Zn}","page":"Integers mod n","title":"AbstractAlgebra.isunit","text":"isunit(n::n_Zn)\n\nReturn true if the given value is a unit in the integers modulo n.\n\n\n\n","category":"method"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Singular.characteristic(::N_ZnRing)","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"Examples","category":"page"},{"location":"modn/","page":"Integers mod n","title":"Integers mod n","text":"R = ResidueRing(ZZ, 26)\na = R(5)\n\nisunit(a)\nc = characteristic(R)","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"CurrentModule = Singular","category":"page"},{"location":"rational/#Rational-field","page":"Rational field","title":"Rational field","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Singular.jl provides rational numbers via Singular's n_Q type.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"There is a constant parent object representing the field of rationals, called QQ in Singular.jl. It is defined by QQ = Rationals(), which calls the constructor for the unique field of rationals in Singular.","category":"page"},{"location":"rational/#Rational-functionality","page":"Rational field","title":"Rational functionality","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"The rationals in Singular.jl implement the Field interface defined by AbstractAlgebra.jl. They also implement the Fraction Field interface.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"https://nemocas.github.io/AbstractAlgebra.jl/fields.html","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"https://nemocas.github.io/AbstractAlgebra.jl/fraction_fields.html","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"We describe here only the extra functionality provided by Singular that is not already described in those interfaces.","category":"page"},{"location":"rational/#Constructors","page":"Rational field","title":"Constructors","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"In addition to the standard constructors required for the interfaces listed above, Singular.jl provides the following constructors.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"QQ(n::n_Z)\nQQ(n::fmpz)","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Construct a Singular rational from the given integer n.","category":"page"},{"location":"rational/#Basic-manipulation","page":"Rational field","title":"Basic manipulation","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"numerator(::n_Q)","category":"page"},{"location":"rational/#Base.numerator-Tuple{n_Q}","page":"Rational field","title":"Base.numerator","text":"numerator(n::n_Q)\n\nReturn the numerator of the given fraction.\n\n\n\n","category":"method"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"denominator(::n_Q)","category":"page"},{"location":"rational/#Base.denominator-Tuple{n_Q}","page":"Rational field","title":"Base.denominator","text":"denominator(n::n_Q)\n\nReturn the denominator of the given fraction.\n\n\n\n","category":"method"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"abs(::n_Q)","category":"page"},{"location":"rational/#Base.abs-Tuple{n_Q}","page":"Rational field","title":"Base.abs","text":"abs(n::n_Q)\n\nReturn the absolute value of the given fraction.\n\n\n\n","category":"method"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"f = QQ(-12, 7)\n\nh = numerator(QQ)\nk = denominator(QQ)\nm = abs(f)","category":"page"},{"location":"rational/#Comparison","page":"Rational field","title":"Comparison","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Here is a list of the comparison functions implemented, with the understanding that isless provides all the usual comparison operators.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Function\nisless(a::n_Q, b::n_Q)","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"We also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Function\nisless(a::n_Q, b::Integer)\nisless(a::Integer, b::n_Q)","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"a = QQ(12, 7)\nb = QQ(-3, 5)\n\na > b\na != b\na > 1\n5 >= b","category":"page"},{"location":"rational/#Rational-reconstruction","page":"Rational field","title":"Rational reconstruction","text":"","category":"section"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"reconstruct(::n_Z, ::n_Z)","category":"page"},{"location":"rational/#Nemo.reconstruct-Tuple{n_Z, n_Z}","page":"Rational field","title":"Nemo.reconstruct","text":"reconstruct(x::n_Z, y::n_Z)\n\nGiven x modulo y, find rs such that x equiv rs pmody for values r and s satisfying the bound y  2(r + 1)(s + 1).\n\n\n\n","category":"method"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"The following ad hoc versions of the same function also exist.","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"reconstruct(::n_Z, ::Integer)\nreconstruct(::Integer, ::n_Z)","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"rational/","page":"Rational field","title":"Rational field","text":"q1 = reconstruct(ZZ(7), ZZ(3))\nq2 = reconstruct(ZZ(7), 5)","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"CurrentModule = Singular","category":"page"},{"location":"matrix/#Matrices","page":"Matrices","title":"Matrices","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Singular internally allows for matrices over polynomial rings to be created extremely efficiently from ideals and modules (often without copying data). This allows for introspection of modules and operations that can be expressed in terms of matrices (e.g. composition of R-module homomorphisms) to be computed, at a low level.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"The default matrix type in Singular.jl is the smatrix type.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Matrix objects have a parent object which represents the space of matrices they belong to, the data for which is given by the polynomial ring R over which the matrices are defined, and the number of rows and columns of the matrices in the space.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"The types of matrices and associated parent objects are given in the following table according to the library providing them.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Library Element type Parent type\nSingular smatrix{T} Singular.MatrixSpace{T}","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"These types are parameterised by the type of elements in the polynomial ring R over which the matrices are defined.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"All matrix types belong directly to the abstract type SetElem and all the matrix space parent object types belong to the abstract type Set.","category":"page"},{"location":"matrix/#Matrix-functionality","page":"Matrices","title":"Matrix functionality","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Singular.jl matrices implement standard operations one would expect. These include:","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"The following parts of the Matrix interface from AbstractAlgebra are also implemented:","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"arithmetic operations: +, -, *\ncomparison: ==","category":"page"},{"location":"matrix/#Basic-constructors","page":"Matrices","title":"Basic constructors","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Using Singular.jl, the user has two basic constructors for matrices.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"identity_matrix(::PolyRing, ::Int)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.identity_matrix-Tuple{PolyRing, Int64}","page":"Matrices","title":"AbstractAlgebra.Generic.identity_matrix","text":"identity_matrix(R::PolyRing, n::Int) Returns the n times n identity matrix over R\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"zero_matrix(::PolyRing, ::Int, ::Int)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.zero_matrix-Tuple{PolyRing, Int64, Int64}","page":"Matrices","title":"AbstractAlgebra.Generic.zero_matrix","text":"zero_matrix(R::PolyRing, r::Int, c::Int) Returns the r times c zero matrix over R\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"R, (x, y, u, v, w) = Singular.PolynomialRing(Singular.QQ, [\"x\", \"y\", \"u\", \"v\", \"w\"])\n\nidentity_matrix(R, 4)\n\nzero_matrix(R, 3, 8)","category":"page"},{"location":"matrix/#Basic-manipulation","page":"Matrices","title":"Basic manipulation","text":"","category":"section"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"The following functions are provided to manipulate matrices and to set and retrieve entries other basic data associated with the matrices.","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"nrows(::smatrix)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.nrows-Tuple{smatrix}","page":"Matrices","title":"AbstractAlgebra.Generic.nrows","text":"nrows(M::smatrix)\n\nReturn the number of rows of M.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"ncols(::smatrix)","category":"page"},{"location":"matrix/#AbstractAlgebra.Generic.ncols-Tuple{smatrix}","page":"Matrices","title":"AbstractAlgebra.Generic.ncols","text":"nrows(M::smatrix) Return the number of colums of M.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"getindex(::smatrix{T}, ::Int, ::Int) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix/#Base.getindex-Union{Tuple{T}, Tuple{smatrix{T}, Int64, Int64}} where T<:AbstractAlgebra.RingElem","page":"Matrices","title":"Base.getindex","text":"getindex(M::smatrix{T}, i::Int, j::Int) where T <: AbstractAlgebra.RingElem Given a matrix M = (m_ij)_i j, return the entry m_ij.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"setindex!(::smatrix, ::spoly, ::Int, ::Int)","category":"page"},{"location":"matrix/#Base.setindex!-Tuple{smatrix, spoly, Int64, Int64}","page":"Matrices","title":"Base.setindex!","text":"setindex!(M::smatrix, p::spoly i::Int, j::Int) Given a matrix M = (m_ij)_i j, set the entry m_ij to the value p.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"transpose(M::smatrix{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"matrix/#Base.transpose-Union{Tuple{smatrix{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Matrices","title":"Base.transpose","text":"transpose(M::smatrix{T}) where T <: AbstractAlgebra.RingElem Given a matrix M=(m_ij)_i j, return the matrix M^T=(m_ji)_j i.\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"iszero(M::smatrix)","category":"page"},{"location":"matrix/#Base.iszero-Tuple{smatrix}","page":"Matrices","title":"Base.iszero","text":"iszero(M::smatrix)\n\nReturn whether the supplied matrix M is the zero matrix.\n\n\n\n\n\n","category":"method"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"matrix/","page":"Matrices","title":"Matrices","text":"R, (x, y, u, v, w) = Singular.PolynomialRing(QQ, [\"x\", \"y\", \"u\", \"v\", \"w\"])\n\nM = identity_matrix(R, 4)\n\nnrows(M)\n\nncols(M)\n\niszero(M)\n\nM[3, 4] = x*y + 5*u*w\n\nN = transpose(M)\n\nN[4, 3]","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"CurrentModule = Singular","category":"page"},{"location":"nemo/#Nemo-rings-and-fields","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"","category":"section"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Any type that satisfies AbstractAlgebra.jl Ring or Field interface, such as all Nemo ring and field types, can be used as coefficient rings in Singular.jl. Theses are implemented via the Singular n_unknown type.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"The associated ring/field is represented by a parent object which can be constructed by a call to the CoefficientRing constructor. In practice, however, this constructor is only used internally, and Nemo rings and fields work directly as Singular coefficient rings, and all the coercions and ad hoc functions that one would expect to be present are implemented.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"All of the Singular polynomial arithmetic should work for any Nemo ring and everything, including ideals, modules, standard basis, syzygies, resolutions, etc., should work with any Nemo field.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"The types of the parent objects and elements of the associated foreign rings are given in the following table according to the library providing them.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Library Element type Parent type\nSingular n_unknown{T} Singular.CoefficientRing{T}","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"These types are parameterised with the element type of the given Nemo/AbstractAlgebra element type.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"The Singular.jl n_unknown types belong directly to the abstract type RingElem and their parent object types belong to the abstract type Ring.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Specialised efficient wrappers exist for certain Nemo coefficient ring types.","category":"page"},{"location":"nemo/#Nemo-ring-functionality","page":"Nemo rings and fields","title":"Nemo ring functionality","text":"","category":"section"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Singular.jl foreign ring types implement the Ring interface and possibly the Field interface of AbstractAlgebra.jl.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/rings.html","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/fields.html","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Parts of the Euclidean Ring interface may also be implemented, though Singular will report an error if division is meaningless (even after cancelling zero divisors).","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Below, we describe the functionality that is specific to the Singular foreign ring interface that is not already listed at the given links.","category":"page"},{"location":"nemo/#Constructors","page":"Nemo rings and fields","title":"Constructors","text":"","category":"section"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Given an AbstractAlgebra compatible ring R, e.g. a Nemo ring, we have the following constructor, which returns the associated Singular.jl coefficient ring..","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"CoefficientRing(R::Ring)","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"If there are generators to be coerced from Nemo/AbstractAlgebra into corresponding elements, the Singular.jl coefficient ring can be used to coerce them to a Singular n_unknown element.","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Examples","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"R, x = Nemo.PolynomialRing(ZZ, \"x\")\nS = CoefficientRing(R)\nt = S(x)","category":"page"},{"location":"nemo/","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Note that it is unlikely that a user directly needs to construct the Singular coefficient ring from a Nemo ring, since the Singular.jl constructors are designed to accept Nemo coefficient rings directly. Singular.jl automatically constructs the required Singular coefficient ring and makes use of it.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"CurrentModule = Singular","category":"page"},{"location":"alghom/#Algebra-Homomorphisms","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Singular.jl allows the creation of algebra homomorphisms of Singular polynomial rings over Nemo/Singular coefficient rings.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"The default algebra homomorphism type in Singular.jl is the Singular SAlgHom type.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Additionally, a special type for the identity homomorphism has been implemented. The type in Singular.jl for the latter is SIdAlgHom.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"All algebra homomorphism types belong directly to the abstract type AbstractAlgebraHomomorphism{T}.","category":"page"},{"location":"alghom/#Algebra-Homomorphism-functionality","page":"Algebra Homomorphisms","title":"Algebra Homomorphism functionality","text":"","category":"section"},{"location":"alghom/#Constructors","page":"Algebra Homomorphisms","title":"Constructors","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Given two Singular polynomial rings R and S over the same base ring, the following constructors are available for creating algebra homomorphisms.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"AlgebraHomomorphism(D::PolyRing, C::PolyRing, V::Vector)","category":"page"},{"location":"alghom/#Singular.AlgebraHomomorphism-Tuple{PolyRing, PolyRing, Vector{T} where T}","page":"Algebra Homomorphisms","title":"Singular.AlgebraHomomorphism","text":"Algebra_Homomorphism(D::PolyRing, C::PolyRing, V::Vector)\n\nConstructs an algebra homomorphism f D -- C, where the i-th variable of D is mapped to the i-th entry of V. D and C must be polynomial rings over the same base ring.\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"IdentityAlgebraHomomorphism(D::PolyRing)","category":"page"},{"location":"alghom/#Singular.IdentityAlgebraHomomorphism-Tuple{PolyRing}","page":"Algebra Homomorphisms","title":"Singular.IdentityAlgebraHomomorphism","text":"IdentityAlgebraHomomorphism(R::PolyRing) Constructs the canonical identity algebra homomorphism id D -- D, where the i-th variable of D is mapped to itself.\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Examples","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"L = FiniteField(3, 2, String(\"a\"))\n\nR, (x, y, z, w) = PolynomialRing(L[1], [\"x\", \"y\", \"z\", \"w\"];\n                             ordering=:negdegrevlex)\n\nS, (a, b, c) = PolynomialRing(L[1], [\"a\", \"b\", \"c\"];\n                             ordering=:degrevlex)\n\nV = [a, a + b^2, b - c, c + b]\n\nf = AlgebraHomomorphism(R, S, V)","category":"page"},{"location":"alghom/#Operating-on-objects","page":"Algebra Homomorphisms","title":"Operating on objects","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"It is possible to act on polynomials and ideals via algebra homomorphisms.","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Examples","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"R, (x, y, z, w) = PolynomialRing(Nemo.ZZ, [\"x\", \"y\", \"z\", \"w\"];\n                             ordering=:negdegrevlex)\n\nS, (a, b, c) = PolynomialRing(Nemo.ZZ, [\"a\", \"b\", \"c\"];\n                             ordering=:degrevlex)\n\nV = [a, a + b^2, b - c, c + b]\n\nf = AlgebraHomomorphism(R, S, V)\n\nid  = IdentityAlgebraHomomorphism(S)\n\n\nJ = Ideal(R, [x, y^3])\n\np = x + y^3 + z*w\n\nK = f(J)\n\nq = f(p)","category":"page"},{"location":"alghom/#Composition","page":"Algebra Homomorphisms","title":"Composition","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"compose(f::SAlgHom, g::SAlgHom)","category":"page"},{"location":"alghom/#AbstractAlgebra.Generic.compose-Tuple{Singular.SAlgHom, Singular.SAlgHom}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.Generic.compose","text":"compose(f::AbstractAlgebra.Map(Singular.SAlgHom),\n                     g::AbstractAlgebra.Map(Singular.SAlgHom))\n\nReturns an algebra homomorphism h domain(f) -- codomain(g), where h = g(f).\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"A short command for the composition of f and g is f*g, which is the same as compose(f, g).","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Examples","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"R, (x, y, z, w) = PolynomialRing(QQ, [\"x\", \"y\", \"z\", \"w\"];\n                             ordering=:negdegrevlex)\n\nS, (a, b, c) = PolynomialRing(QQ, [\"a\", \"b\", \"c\"];\n                             ordering=:degrevlex)\n\nV = [a, a + b^2, b - c, c + b]\n\nW = [x^2, x + y + z, z*y]\n\nf = AlgebraHomomorphism(R, S, V)\n\ng = AlgebraHomomorphism(S, R, W)\n\nidR  = IdentityAlgebraHomomorphism(R)\n\nh1 = f*g\n\nh2 = idR*f\n\nh3 = g*idR\n\nh4 = idR*idR","category":"page"},{"location":"alghom/#Preimages","page":"Algebra Homomorphisms","title":"Preimages","text":"","category":"section"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"preimage(f::SAlgHom, I::sideal)","category":"page"},{"location":"alghom/#AbstractAlgebra.Generic.preimage-Tuple{Singular.SAlgHom, sideal}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.Generic.preimage","text":"preimage(f::AbstractAlgebra.Map(SAlgHom), I::sideal)\n\nReturns the preimage of the ideal I under the algebra homomorphism f.\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"preimage(f::SIdAlgHom, I::sideal)","category":"page"},{"location":"alghom/#AbstractAlgebra.Generic.preimage-Tuple{Singular.SIdAlgHom, sideal}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.Generic.preimage","text":"preimage(f::AbstractAlgebra.Map(SIdAlgHom), I::sideal)\n\nReturns the preimage of the ideal I under the identity algebra homomorphism.\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"kernel(f::SIdAlgHom)","category":"page"},{"location":"alghom/#AbstractAlgebra.Generic.kernel-Tuple{Singular.SIdAlgHom}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.Generic.kernel","text":"kernel(f::AbstractAlgebra.Map(SIdAlgHom)) Returns the kernel of the identity algebra homomorphism.\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"kernel(f::SAlgHom)","category":"page"},{"location":"alghom/#AbstractAlgebra.Generic.kernel-Tuple{Singular.SAlgHom}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.Generic.kernel","text":"kernel(f::AbstractAlgebra.Map(SAlgHom))\n\nReturns the kernel of the algebra homomorphism f.\n\n\n\n","category":"method"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Examples","category":"page"},{"location":"alghom/","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"R, (x, y, z, w) = PolynomialRing(QQ, [\"x\", \"y\", \"z\", \"w\"];\n                             ordering=:negdegrevlex)\n\nS, (a, b, c) = PolynomialRing(QQ, [\"a\", \"b\", \"c\"];\n                             ordering=:degrevlex)\n\nI = Ideal(S, [a, a + b^2, b - c, c + b])\n\nf = SAlgebraHomomorphism(R, S, gens(I))\n\nidS  = IdentityAlgebraHomomorphism(S)\n\nP1 = preimage(f, I)\n\nP2 = preimage(idS, I)\n\nK1 = kernel(f)\n\nK2 = preimage(idS)","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"CurrentModule = Singular","category":"page"},{"location":"vector/#Free-modules-and-vectors","page":"Free modules and vectors","title":"Free modules and vectors","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"As generators of finitely generated modules in Singular.jl are given as submodule of free modules over a polynomial ring R, Singular.jl supports creation of the free module R^n and vectors of length n in such a module.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"The Singular.jl type for a vector is svector{T}. For the most part, these exist to help interact with the smodule{T} type provided by Singular.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"The types of vectors and associated parent objects are given in the following table according to the library providing them.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Library Element type Parent type\nSingular svector{T} Singular.FreeMod{T}","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"These types are parameterised by the type of elements in the polynomial ring R.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"All free module types belong directly to the abstract type Module{T} and vector types belong directly to ModuleElem{T}.","category":"page"},{"location":"vector/#Free-module-and-vector-functionality","page":"Free modules and vectors","title":"Free module and vector functionality","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Singular.jl modules implement standard operations one would expect on vectors and their associated parent modules.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"These include:","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.\nArithmetic operations on vectors: (unary) -, +, -\nScalar multiplication of vectors by polynomials, constants and integers\nComparison operators: ==","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Below, we describe all of the functionality for Singular.jl free modules that is not included in this list of basic operations.","category":"page"},{"location":"vector/#Constructors","page":"Free modules and vectors","title":"Constructors","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Given a Singular polynomial ring R and a rank n, the following constructors are available for creating free modules.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"FreeModule{T <: AbstractAlgebra.RingElem}(R::PolyRing{T}, n::Int)","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Construct the free module R^n over the polynomial ring R. Elements of the module returned by this function are vectors of length n, with entries in R.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"vector{T <: AbstractAlgebra.RingElem}(R::PolyRing{T}, coords::spoly{T}...)","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Construct the vector whose coordinates (which are elements of R) are the given parameters.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Examples","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nM = FreeModule(R, 3)\nv2 = M([x + 1, x*y + 1, y])\n\nv1 = vector(R, x + 1, x*y + 1, y)","category":"page"},{"location":"vector/#Basic-manipulation","page":"Free modules and vectors","title":"Basic manipulation","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"rank(::FreeMod)","category":"page"},{"location":"vector/#LinearAlgebra.rank-Tuple{FreeMod}","page":"Free modules and vectors","title":"LinearAlgebra.rank","text":"rank(M::FreeMod)\n\nReturn the rank of the given free module.\n\n\n\n","category":"method"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"gens{T <: AbstractAlgebra.RingElem}(::FreeMod{T})","category":"page"},{"location":"vector/#AbstractAlgebra.gens-Union{Tuple{FreeMod{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Free modules and vectors","title":"AbstractAlgebra.gens","text":"gens{T <: AbstractAlgebra.RingElem}(M::FreeMod{T})\n\nReturn a Julia array whose entries are the generators of the given free module.\n\n\n\n","category":"method"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Examples","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nM = FreeModule(R, 5)\n\nv = gens(M)\nr = rank(M)","category":"page"},{"location":"vector/#Conversions","page":"Free modules and vectors","title":"Conversions","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"To convert the internal Singular representation of an svector{T} to a Julia array whose entries have type T, we have the following conversion routine.","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Array{T <: Nemo.RingElem}(v::svector{spoly{T}})","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Examples","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nv1 = vector(R, x + 1, x*y + 1, y)\n\nV = Array(v1)","category":"page"},{"location":"vector/#Jet-of-vectors","page":"Free modules and vectors","title":"Jet of vectors","text":"","category":"section"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"jet{T <: AbstractAlgebra.RingElem}(::svector{spoly{T}}, ::Int)","category":"page"},{"location":"vector/#Singular.jet-Union{Tuple{T}, Tuple{svector{spoly{T}}, Int64}} where T<:AbstractAlgebra.RingElem","page":"Free modules and vectors","title":"Singular.jet","text":"jet(x::svector{spoly{T}}, n::Int)\n\nGiven a vector x this function truncates each entry of x up to degree n.\n\n\n\n","category":"method"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"Examples","category":"page"},{"location":"vector/","page":"Free modules and vectors","title":"Free modules and vectors","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nv = vector(R, x^5 + 1, 2x^3 + 3y^2, x^2)\nw = jet(v, 3)","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"CurrentModule = Singular","category":"page"},{"location":"modp/#Integers-mod-p","page":"Integers mod p","title":"Integers mod p","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Integers mod a prime p are implemented via the Singular n_Zp type for any positive prime modulus less than 2^29.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"The associated field of integers mod p is represented by a parent object which can be constructed by a call to the Fp constructor.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"The types of the parent objects and elements of the associated fields of integers modulo p are given in the following table according to the library providing them.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Library Element type Parent type\nSingular n_Zp Singular.N_ZpField","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"All integer mod p element types belong directly to the abstract type FieldElem and all the parent object types belong to the abstract type Field.","category":"page"},{"location":"modp/#Integer-mod-p-functionality","page":"Integers mod p","title":"Integer mod p functionality","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Singular.jl integers modulo p implement the Field and Residue Ring interfaces of AbstractAlgebra.jl.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"https://nemocas.github.io/AbstractAlgebra.jl/fields.html","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"https://nemocas.github.io/AbstractAlgebra.jl/residue_rings.html","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Below, we describe the functionality that is specific to the Singular integers mod p field and not already listed at the given links.","category":"page"},{"location":"modp/#Constructors","page":"Integers mod p","title":"Constructors","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"The following constructors are available to create the field of integers modulo a prime p.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Fp(p::Int; cached=true)","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Construct the field of integers modulo p. By default, the field is cached, so that all fields of integers modulo p have the same parent object. If this is not the desired behaviour, the cached parameter can be set to false. If p is not a prime or p is not in the range (0 2^29), an exception is raised.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Given a field R of integers modulo p, we also have the following coercions in addition to the standard ones expected.","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"R(n::n_Z)\nR(n::fmpz)","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Coerce a Singular or Flint integer value into the field.","category":"page"},{"location":"modp/#Basic-manipulation","page":"Integers mod p","title":"Basic manipulation","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"isunit(::n_Zp)","category":"page"},{"location":"modp/#AbstractAlgebra.isunit-Tuple{n_Zp}","page":"Integers mod p","title":"AbstractAlgebra.isunit","text":"isunit(n::n_Zp)\n\nReturn true if n is a unit in the field, i.e. nonzero.\n\n\n\n","category":"method"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Singular.characteristic(::N_ZpField)","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Examples","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"R = Fp(23)\na = R(5)\n\nisunit(a)\nc = characteristic(R)","category":"page"},{"location":"modp/#Conversions","page":"Integers mod p","title":"Conversions","text":"","category":"section"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Int(n::n_Zp)","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Lift the integer n modulo p to a Julia Int. The result is always in the range 0 p).","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"Examples","category":"page"},{"location":"modp/","page":"Integers mod p","title":"Integers mod p","text":"R = Fp(23)\na = R(5)\n\nb = Int(a)","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"CurrentModule = Singular","category":"page"},{"location":"transExt/#Function-fields","page":"Function fields","title":"Function fields","text":"","category":"section"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Function fields are implemented via the Singular n_transExt type for prime fields of any characteristic.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"The associated function field is represented by a parent object which can be constructed by a call to the FunctionField constructor.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"The types of the parent objects and elements of the associated function fields are given in the following table according to the library providing them.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Library Element type Parent type\nSingular n_transExt Singular.N_FField","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"All function field element types belong directly to the abstract type FieldElem and all the parent object types belong to the abstract type Field.","category":"page"},{"location":"transExt/#Function-field-functionality","page":"Function fields","title":"Function field functionality","text":"","category":"section"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.jl function fields implement the Field interface of AbstractAlgebra.jl.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/fields.html","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Below, we describe the functionality that is specific to Singular function field and not already listed at the given link.","category":"page"},{"location":"transExt/#Constructors","page":"Function fields","title":"Constructors","text":"","category":"section"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"The following constructors are available to create function fields and their elements.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.FunctionField(::Field, ::Array{String, 1}; ::Bool)","category":"page"},{"location":"transExt/#Singular.FunctionField-Tuple{Singular.Field, Vector{String}}","page":"Function fields","title":"Singular.FunctionField","text":"FunctionField(F::Singular.Field, S::Vector{String})\n\nReturns a tuple K a consisting of a function field K over the field F with transcendence basis stored in the array S.\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"In case the user does not want to specify a transcendence basis the following constructor can be used.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.FunctionField(::Field, ::Int; ::Bool)","category":"page"},{"location":"transExt/#Singular.FunctionField-Tuple{Singular.Field, Int64}","page":"Function fields","title":"Singular.FunctionField","text":"FunctionField(F::Singular.Field, n::Int)\n\nReturns a tuple K a consisting of a function field K over the field F with transcendence degree n and transcendence basis a1  an.\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Given a function field F, we also have the following coercions in addition to the standard ones expected.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"F(n::fmpz)","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Coerce a Flint integer value into the field.","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Examples","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"F1, (a, b, c) = FunctionField(QQ, [\"a\", \"b\", \"c\"])\n\nx1 = a*b + c\n\nF2, (a1, a2, a3) = FunctionField(Fp(5), 3)\n\nx2 = a1^5 + a2*a3^4","category":"page"},{"location":"transExt/#Basic-manipulation","page":"Function fields","title":"Basic manipulation","text":"","category":"section"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"numerator(::n_transExt)","category":"page"},{"location":"transExt/#Base.numerator-Tuple{n_transExt}","page":"Function fields","title":"Base.numerator","text":"numerator(n::n_transExt)\n\nReturn the numerator of the given fraction.\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"denominator(::n_transExt)","category":"page"},{"location":"transExt/#Base.denominator-Tuple{n_transExt}","page":"Function fields","title":"Base.denominator","text":"denominator(n::n_transExt)\n\nReturn the denominator of the given fraction.\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.transcendence_degree(::N_FField)","category":"page"},{"location":"transExt/#Singular.transcendence_degree-Tuple{N_FField}","page":"Function fields","title":"Singular.transcendence_degree","text":"transcendence_degree(F::N_FField)\n\nReturn the transcendence degree of the given function field.\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.transcendence_basis(::N_FField)","category":"page"},{"location":"transExt/#Singular.transcendence_basis-Tuple{N_FField}","page":"Function fields","title":"Singular.transcendence_basis","text":"basis(F::N_FField)\n\nReturn the transcendence basis of the given function field.\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.characteristic(::N_FField)","category":"page"},{"location":"transExt/#AbstractAlgebra.Generic.characteristic-Tuple{N_FField}","page":"Function fields","title":"AbstractAlgebra.Generic.characteristic","text":"characteristic(R::N_FField)\n\nReturn the characteristic of the field.\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"isunit(::n_transExt)","category":"page"},{"location":"transExt/#AbstractAlgebra.isunit-Tuple{n_transExt}","page":"Function fields","title":"AbstractAlgebra.isunit","text":"isunit(n::n_transExt) Return true if n is a unit in the field, i.e. nonzero.\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Singular.n_transExt_to_spoly(::n_transExt)","category":"page"},{"location":"transExt/#Singular.n_transExt_to_spoly-Tuple{n_transExt}","page":"Function fields","title":"Singular.n_transExt_to_spoly","text":"ntransExttospoly(x::ntransExt; parent::PolyRing) Returns the numerator of x as a polynomial in a polynomial ring with at least as many variables, as the transcendence degree of parent(x). If a ring parent_ring is given to the function, it will be the parent ring of the output.\n\n\n\n","category":"method"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"Examples","category":"page"},{"location":"transExt/","page":"Function fields","title":"Function fields","text":"F1, (a, b, c) = FunctionField(QQ, [\"a\", \"b\", \"c\"])\nx = F1(5)*a\ny = a^2 *b+a*b+b^2\n\nisunit(x)\nchar = characteristic(F1)\nd = transcendence_degree(F1)\n\nS, = PolynomialRing(QQ, [\"a\", \"b\", \"c\"])\n\np = n_transExt_to_spoly(y, parent_ring = S)\n\nF2, = FunctionField(Fp(7), 4)\nB = transcendence_basis(F2)","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"CurrentModule = Singular","category":"page"},{"location":"ideal/#Ideals","page":"Ideals","title":"Ideals","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Singular.jl allows the creation of ideals over a Singular polynomial ring. These are internally stored as a list of (polynomial) generators. This list of generators can also have the property of being a Groebner basis.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"The default ideal type in Singular.jl is the Singular sideal type.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Ideals objects have a parent object which represents the set of ideals they belong to, the data for which is given by the polynomial ring their generators belong to.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"The types of ideals and associated parent objects are given in the following table according to the library provding them.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Library Element type Parent type\nSingular sideal{T} Singular.IdealSet{T}","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"These types are parameterised by the type of elements of the polynomial ring over which the ideals are defined.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"All ideal types belong directly to the abstract type Module{T} and all the ideal set parent object types belong to the abstract type Set.","category":"page"},{"location":"ideal/#Ideal-functionality","page":"Ideals","title":"Ideal functionality","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Singular.jl ideals implement standard operations one would expect on modules. These include:","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.\nAddition","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Also implements is the following operations one expects for ideals:","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Multiplication\nPowering","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Below, we describe all of the functionality for Singular.jl ideals that is not included in this list of basic operations.","category":"page"},{"location":"ideal/#Constructors","page":"Ideals","title":"Constructors","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Given a Singular polynomial ring R, the following constructors are available for creating ideals.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Ideal(R::PolyRing{T}, ids::spoly{T}...) where T <: Nemo.RingElem\nIdeal(R::PolyRing{T}, ids::Array{spoly{T}, 1}) where T <: Nemo.RingElem","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Construct the ideal over the polynomial ring R whose (polynomial) generators are given by the given parameter list or array of polynomials, respectively. The list may be empty, resulting in the zero ideal.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n\nI1 = Ideal(R, x*y + 1, x^2)\nI2 = Ideal(R, [x*y + 1, x^2])","category":"page"},{"location":"ideal/#Basic-manipulation","page":"Ideals","title":"Basic manipulation","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"ngens(::sideal)","category":"page"},{"location":"ideal/#AbstractAlgebra.Generic.ngens-Tuple{sideal}","page":"Ideals","title":"AbstractAlgebra.Generic.ngens","text":"ngens(I::sideal)\n\nReturn the number of generators in the internal representation of the ideal I.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"gens(::sideal)","category":"page"},{"location":"ideal/#AbstractAlgebra.gens-Tuple{sideal}","page":"Ideals","title":"AbstractAlgebra.gens","text":"gens(I::sideal)\n\nReturn the generators in the internal representation of the ideal I as an array.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Singular.jl overloads the setindex! and getindex functions so that one can access the generators of an ideal using array notation.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"I[n::Int]","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"iszero(::sideal)","category":"page"},{"location":"ideal/#Base.iszero-Tuple{sideal}","page":"Ideals","title":"Base.iszero","text":"iszero(I::sideal)\n\nReturn true if the given ideal is algebraically the zero ideal.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"iszerodim(::sideal)","category":"page"},{"location":"ideal/#Singular.iszerodim-Tuple{sideal}","page":"Ideals","title":"Singular.iszerodim","text":"iszerodim(I::sideal)\n\nReturn true if the given ideal is zero dimensional, i.e. the Krull dimension of RI is zero, where R is the polynomial ring over which I is an ideal..\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"dimension(I::sideal{S}) where S <: Union{spoly{T}, spoly{n_unknown{U}}} where {T <: Singular.FieldElem, U <: Nemo.FieldElem}","category":"page"},{"location":"ideal/#Singular.dimension-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{U}, Tuple{T}} where {T<:AbstractAlgebra.FieldElem, U<:AbstractAlgebra.FieldElem, S<:Union{spoly{T}, spoly{Singular.n_unknown{U}}}}","page":"Ideals","title":"Singular.dimension","text":"dimension(I::sideal{S}) where S <: Union{spoly{T}, spoly{n_unknown{U}}} where {T <: Singular.FieldElem, U <: Nemo.FieldElem}\n\nGiven an ideal I this function computes the Krull dimension of the ring RI, where R is the polynomial ring over which I is an ideal. The ideal must be over a polynomial ring over a field, and a Groebner basis.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"isconstant(::sideal)","category":"page"},{"location":"ideal/#AbstractAlgebra.Generic.isconstant-Tuple{sideal}","page":"Ideals","title":"AbstractAlgebra.Generic.isconstant","text":"isconstant(I::sideal)\n\nReturn true if the given ideal is a constant ideal, i.e. generated by constants in the polynomial ring over which it is an ideal.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"isvar_generated(::sideal)","category":"page"},{"location":"ideal/#Singular.isvar_generated-Tuple{sideal}","page":"Ideals","title":"Singular.isvar_generated","text":"isvar_generated(I::sideal)\n\nReturn true if each generator in the representation of the ideal I is a generator of the polynomial ring, i.e. a variable.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"normalize!(::sideal)","category":"page"},{"location":"ideal/#LinearAlgebra.normalize!-Tuple{sideal}","page":"Ideals","title":"LinearAlgebra.normalize!","text":"normalize!(I::sideal)\n\nNormalize the polynomial generators of the ideal I in-place. This means to reduce their coefficients to lowest terms. In most cases this does nothing, but if the coefficient ring were the rational numbers for example, the coefficients of the polynomials would be reduced to lowest terms.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n\nI = Ideal(R, x^2 + 1, x*y)\n\nn = ngens(I)\np = I[1]\nI[1] = 2x + y^2\nisconstant(I) == false\nisvar_generated(I) == false\niszerodim(I) == false\n\nS, (u, v) = PolynomialRing(QQ, [\"u\", \"v\"])\nJ = Ideal(S, u^2 + 1, u*v)\ndimension(std(J)) == 0","category":"page"},{"location":"ideal/#Containment","page":"Ideals","title":"Containment","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"contains{T <: AbstractAlgebra.RingElem}(::sideal{T}, ::sideal{T})","category":"page"},{"location":"ideal/#Base.contains-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Base.contains","text":"contains{T <: AbstractAlgebra.RingElem}(I::sideal{T}, J::sideal{T})\n\nReturns true if the ideal I contains the ideal J. This will be expensive if I is not a Groebner ideal, since its standard basis must be computed.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x , y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, x^2 + 1, x*y)\nJ = Ideal(R, x^2 + 1)\n\ncontains(I, J) == true","category":"page"},{"location":"ideal/#Comparison","page":"Ideals","title":"Comparison","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Checking whether two ideals are algebraically equal is very expensive, as it usually requires computing Groebner bases. Therefore we do not overload the == operator for ideals. Instead we have the following two functions.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"isequal{T <: AbstractAlgebra.RingElem}(::sideal{T}, ::sideal{T})","category":"page"},{"location":"ideal/#Base.isequal-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Base.isequal","text":"isequal{T <: AbstractAlgebra.RingElem}(I1::sideal{T}, I2::sideal{T})\n\nReturn true if the given ideals have the same generators in the same order. Note that two algebraically equal ideals with different generators will return false.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"equal{T <: AbstractAlgebra.RingElem}(::sideal{T}, ::sideal{T})","category":"page"},{"location":"ideal/#Singular.equal-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.equal","text":"equal(I1::sideal{T}, I2::sideal{T}) where T <: AbstractAlgebra.RingElem\n\nReturn true if the two ideals are contained in each other, i.e. are the same ideal mathematically. This function should be called only as a last resort; it is exceptionally expensive to test equality of ideals! Do not define == as an alias for this function!\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x , y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, x^2 + 1, x*y)\nJ = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)\n\nisequal(I, J) == false\nequal(I, J) == true","category":"page"},{"location":"ideal/#Intersection","page":"Ideals","title":"Intersection","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"intersection{T <: Nemo.RingElem}(::sideal{T}, ::sideal{T})","category":"page"},{"location":"ideal/#Singular.intersection-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.intersection","text":"intersection{T <: Nemo.RingElem}(I::sideal{T}, J::sideal{T})\n\nReturns the intersection of the two given ideals.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x , y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, x^2 + 1, x*y)\nJ = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)\n\nV = intersection(I, J)","category":"page"},{"location":"ideal/#Quotient","page":"Ideals","title":"Quotient","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"quotient{T <: Nemo.RingElem}(::sideal{T}, ::sideal{T})","category":"page"},{"location":"ideal/#Singular.quotient-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.quotient","text":"quotient{T <: Nemo.RingElem}(I::sideal{T}, J::sideal{T})\n\nReturns the quotient of the two given ideals. Recall that the ideal quotient (IJ) over a polynomial ring R is defined by r in R  rJ subseteq I.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x , y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, x^2 + 1, x*y)\nJ = Ideal(R, x + y)\n\nV = quotient(I, J)","category":"page"},{"location":"ideal/#Leading-terms","page":"Ideals","title":"Leading terms","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"lead(::sideal)","category":"page"},{"location":"ideal/#AbstractAlgebra.lead-Tuple{sideal}","page":"Ideals","title":"AbstractAlgebra.lead","text":"lead(I::sideal)\n\nReturn the ideal generated by the leading terms of the polynomials generating I.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x , y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, x^2 + 1, x*y)\n\nV = lead(I)","category":"page"},{"location":"ideal/#Saturation","page":"Ideals","title":"Saturation","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"saturation{T <: Nemo.RingElem}(::sideal{T}, ::sideal{T})","category":"page"},{"location":"ideal/#Singular.saturation-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.saturation","text":"saturation{T <: Nemo.RingElem}(I::sideal{T}, J::sideal{T})\n\nReturns the saturation of the ideal I with respect to J, i.e. returns the quotient ideal (IJ^infty) and the number of iterations.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, (x^2 + x*y + 1)*(2y^2+1)^3, (2y^2 + 3)*(2y^2+1)^2)\nJ = Ideal(R, 2y^2 + 1)\n\nS = saturation(I, J)","category":"page"},{"location":"ideal/#Standard-basis","page":"Ideals","title":"Standard basis","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"std(::sideal; ::Bool)","category":"page"},{"location":"ideal/#Statistics.std-Tuple{sideal}","page":"Ideals","title":"Statistics.std","text":"std(I::sideal; complete_reduction::Bool=false)\n\nCompute a Groebner basis for the ideal I. Note that without complete_reduction set to true, the generators of the Groebner basis only have unique leading terms (up to permutation and multiplication by constants). If complete_reduction is set to true (and the ordering is a global ordering) then the Groebner basis is unique.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"fglm(::sideal, ::Symbol)","category":"page"},{"location":"ideal/#Singular.fglm-Tuple{sideal, Symbol}","page":"Ideals","title":"Singular.fglm","text":"fglm(I::sideal, ::Symbol)\n\nCompute a Groebner basis for the zero - dimensional ideal I in the ring R using the FGLM algorithm. All involved orderings have to be global.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"satstd{T <: AbstractAlgebra.RingElem}(::sideal{T}, ::sideal{T})","category":"page"},{"location":"ideal/#Singular.satstd-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.satstd","text":"satstd{T <: AbstractAlgebra.RingElem}(I::sideal{T}, J::sideal{T}) Given an ideal J generated by variables, computes a standard basis of saturation(I, J). This is accomplished by dividing polynomials that occur throughout the std computation by variables occuring in J, where possible. Thus the result can be obtained faster than by first computing the saturation and then the standard basis.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"lift_std(::sideal; ::Bool)","category":"page"},{"location":"ideal/#Singular.lift_std-Tuple{sideal}","page":"Ideals","title":"Singular.lift_std","text":"lift_std(I::sideal)\n\ncomputes the Groebner base G of I and the transformation matrix T such that (Matrix(G) = Matrix(I) * T)\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"lift_std_syz(::sideal; ::Bool)","category":"page"},{"location":"ideal/#Singular.lift_std_syz-Tuple{sideal}","page":"Ideals","title":"Singular.lift_std_syz","text":"lift_std_syz(I::sdeal)\n\ncomputes the Groebner base G of I, the transformation matrix T and the syzygies of M. Returns G,T,S (Matrix(G) = Matrix(I) * T, 0=Matrix(M)*Matrix(S))\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, x^2 + x*y + 1, 2y^2 + 3)\nJ = Ideal(R, 2*y^2 + 3, x^2 + x*y + 1)\n\nA = std(I)\n\nR, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, (x*y + 1)*(2x^2*y^2 + x*y - 2) + 2x*y^2 + x, 2x*y + 1)\nJ = Ideal(R, x)\n\nB = satstd(I, J)\n\nR, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"], ordering = :lex)\nI = Ideal(R, y^3+x^2, x^2*y+x^2, x^3-x^2, z^4-x^2-y)\nJ = fglm(I, :degrevlex)","category":"page"},{"location":"ideal/#Reduction","page":"Ideals","title":"Reduction","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"reduce(::sideal, ::sideal)","category":"page"},{"location":"ideal/#Base.reduce-Tuple{sideal, sideal}","page":"Ideals","title":"Base.reduce","text":"reduce(I::sideal, G::sideal) Return an ideal whose generators are the generators of I reduced by the ideal G. The ideal G is required to be a Groebner basis. The returned ideal will have the same number of generators as I, even if they are zero.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"reduce(::spoly, ::sideal)","category":"page"},{"location":"ideal/#Base.reduce-Tuple{spoly, sideal}","page":"Ideals","title":"Base.reduce","text":"reduce(p::spoly, G::sideal)\n\nReturn the polynomial which is p reduced by the polynomials generating G. It is assumed that G is a Groebner basis.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nf = x^2*y + 2y + 1\ng = y^2 + 1\n\nI = Ideal(R, (x^2 + 1)*f + (x + y)*g + x + 1, (2y^2 + x)*f + y)\nJ = std(Ideal(R, f, g))\n\nV = reduce(I, J)\n\nh1 = (x^2 + 1)*f + (x + y)*g + x + 1\n\nh2 = reduce(h1, J)","category":"page"},{"location":"ideal/#Elimination","page":"Ideals","title":"Elimination","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"eliminate(::sideal, ::spoly...)","category":"page"},{"location":"ideal/#Singular.eliminate-Tuple{sideal, Vararg{spoly, N} where N}","page":"Ideals","title":"Singular.eliminate","text":"eliminate(I::sideal, polys::spoly...)\n\nGiven a list of polynomials which are variables, construct the ideal corresponding geometrically to the projection of the variety given by the ideal I where those variables have been eliminated.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y, t) = PolynomialRing(QQ, [\"x\", \"y\", \"t\"])\n\nI = Ideal(R, x - t^2, y - t^3)\n\nJ = eliminate(I, t)","category":"page"},{"location":"ideal/#Syzygies","page":"Ideals","title":"Syzygies","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"syz(::sideal)","category":"page"},{"location":"ideal/#Singular.syz-Tuple{sideal}","page":"Ideals","title":"Singular.syz","text":"syz(I::sideal)\n\nCompute the module of syzygies of the ideal.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, x^2*y + 2y + 1, y^2 + 1)\n\nF = syz(I)\n\nM = Singular.Matrix(I)\nN = Singular.Matrix(F)\n\n# check they are actually syzygies\niszero(M*N)","category":"page"},{"location":"ideal/#Free-resolutions","page":"Ideals","title":"Free resolutions","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"fres{T <: Nemo.RingElem}(::sideal{T}, ::Int, ::String)","category":"page"},{"location":"ideal/#Singular.fres-Union{Tuple{T}, Tuple{sideal{T}, Int64, String}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.fres","text":" fres{T <: Nemo.RingElem}(id::Union{sideal{T}, smodule{T}},\n  max_length::Int, method::String=\"complete\")\n\nCompute a free resolution of the given ideal/module up to the maximum given length. The ideal/module must be over a polynomial ring over a field, and a Groebner basis. The possible methods are \"complete\", \"frame\", \"extended frame\" and \"single module\". The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal/module. The max_length can be set to 0 if the full free resolution is required.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"sres{T <: Nemo.RingElem}(::sideal{T}, ::Int)","category":"page"},{"location":"ideal/#Singular.sres-Union{Tuple{T}, Tuple{sideal{T}, Int64}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.sres","text":" sres{T <: Nemo.RingElem}(id::sideal{T}, max_length::Int)\n\nCompute a (free) Schreyer resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal. The max_length can be set to 0 if the full free resolution is required.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nI = Ideal(R, x^2*y + 2y + 1, y^2 + 1)\n\nF1 = fres(std(I), 0)\nF2 = sres(std(I), 2)","category":"page"},{"location":"ideal/#Differential-operations","page":"Ideals","title":"Differential operations","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"jet(::sideal, ::Int)","category":"page"},{"location":"ideal/#Singular.jet-Tuple{sideal, Int64}","page":"Ideals","title":"Singular.jet","text":"jet(I::sideal, n::Int) Given an ideal I this function truncates the generators of I up to degree n.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n\nI = Ideal(R, x^5 - y^2, y^3 - x^6 + z^3)\n\nJ1 = jet(I, 3)","category":"page"},{"location":"ideal/#Operations-on-zero-dimensional-ideals","page":"Ideals","title":"Operations on zero-dimensional ideals","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"vdim(::sideal)","category":"page"},{"location":"ideal/#Singular.vdim-Tuple{sideal}","page":"Ideals","title":"Singular.vdim","text":"vdim(I::sideal) Given a zero-dimensional ideal I this function computes the dimension of the vector space RI, where R is the polynomial ring over which I is an ideal. The ideal must be over a polynomial ring over a field, and a Groebner basis.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"kbase(::sideal)","category":"page"},{"location":"ideal/#Singular.kbase-Tuple{sideal}","page":"Ideals","title":"Singular.kbase","text":"kbase(I::sideal) Given a zero-dimensional ideal I this function computes a vector space basis of the vector space RI, where R is the polynomial ring over which I is an ideal. The ideal must be over a polynomial ring over a field, and a Groebner basis.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"highcorner(::sideal)","category":"page"},{"location":"ideal/#Singular.highcorner-Tuple{sideal}","page":"Ideals","title":"Singular.highcorner","text":"highcorner(I::sideal) Given a zero-dimensional ideal I this function computes a The highest corner of I. The output is a polynomial. The ideal must be over a polynomial ring over a field, and a Groebner basis.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]; ordering=:negdegrevlex)\n\nI = Ideal(R, 3*x^2 + y^3, x*y^2)\n\nI = std(I)\n\nn = vdim(I)\nJ = kbase(I)\nf = highcorner(I)","category":"page"},{"location":"ideal/#Operations-over-local-rings","page":"Ideals","title":"Operations over local rings","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"If the base ring R is a local ring, a minimal generating set can be computed using the following function","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"minimal_generating_set(::sideal)","category":"page"},{"location":"ideal/#Singular.minimal_generating_set-Tuple{sideal}","page":"Ideals","title":"Singular.minimal_generating_set","text":"minimalgeneratingset(I::sideal) Given an ideal I in ring R with local ordering, this returns an array containing the minimal generators of I.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Examples","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]; ordering=:negdegrevlex)\n\nhas_local_ordering(R) == true\n\nI = Ideal(R, y, x^2, (1 + y^3) * (x^2 - y))\n\nmin = minimal_generating_set(I)","category":"page"},{"location":"ideal/#Independent-sets-of-monomial-ideals","page":"Ideals","title":"Independent sets of monomial ideals","text":"","category":"section"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"Let I be an ideal of Kx_1  x_n An independent set is a subset u subseteq x_1  x_n such that I cap Ku= 0 In case u cannot be enlarged, it is called non-extendable independent set. If in addition u = dim(Kx_1  x_nI) u is called maximal independent set. Using Singular.jl one can compute non-extendable, resp. maximal independent sets for monomial ideals. If an arbitrary ideal I is passed to the function, the computation is performed on the leading ideal of I.","category":"page"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"independent_sets(I::sideal{S}) where S <: Union{spoly{T}, spoly{n_unknown{U}}} where {T <: Singular.FieldElem, U <: Nemo.FieldElem}","category":"page"},{"location":"ideal/#Singular.independent_sets-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{U}, Tuple{T}} where {T<:AbstractAlgebra.FieldElem, U<:AbstractAlgebra.FieldElem, S<:Union{spoly{T}, spoly{Singular.n_unknown{U}}}}","page":"Ideals","title":"Singular.independent_sets","text":"independent_sets(I::sideal{S}) where S <: Union{spoly{T}, spoly{n_unknown{U}}} where {T <: Singular.FieldElem, U <: Nemo.FieldElem}\n\nReturns all non-extendable independent sets of lead(I). I has to be given by a Grbner basis.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"maximal_independent_set(I::sideal{S}; all::Bool = false) where S <: Union{spoly{T}, spoly{n_unknown{U}}} where {T <: Singular.FieldElem, U <: Nemo.FieldElem}","category":"page"},{"location":"ideal/#Singular.maximal_independent_set-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{U}, Tuple{T}} where {T<:AbstractAlgebra.FieldElem, U<:AbstractAlgebra.FieldElem, S<:Union{spoly{T}, spoly{Singular.n_unknown{U}}}}","page":"Ideals","title":"Singular.maximal_independent_set","text":"maximal_independent_set(I::sideal{S}; all::Bool = false) where S <: Union{spoly{T}, spoly{n_unknown{U}}} where {T <: Singular.FieldElem, U <: Nemo.FieldElem}\n\nReturns, by default, an array containing a maximal independet set of lead(I). I has to be given by a Grbner basis. If the additional parameter \"all\" is set to true, an array containing all maximal independent sets of lead(I) is returned.\n\n\n\n","category":"method"},{"location":"ideal/","page":"Ideals","title":"Ideals","text":"R, (x, y, u, v, w) = PolynomialRing(QQ, [\"x\", \"y\", \"u\", \"v\", \"w\"])\n\nhas_local_ordering(R) == true\n\nI = Ideal(R, x*y*w, y*v*w, u*y*w, x*v)\n\nI = std(I)\n\nL1 = independent_sets(I)\n\nL2 = maximal_independent_set(I)\n\nL3 = maximal_independent_set(I, all = true)\n\n","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"CurrentModule = Singular","category":"page"},{"location":"GF/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"","category":"section"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Finite fields are implemented via the Singular n_GF type for any characteristic and degree contained in the Singular Conway tables.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"The associated finite field is represented by a parent object which can be constructed by a call to the FiniteField constructor.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"The types of the parent objects and elements of the associated finite fields are given in the following table according to the library providing them.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Library Element type Parent type\nSingular n_GF Singular.N_GField","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"All finite field element types belong directly to the abstract type FieldElem and all the parent object types belong to the abstract type Field.","category":"page"},{"location":"GF/#Finite-field-functionality","page":"Finite fields","title":"Finite field functionality","text":"","category":"section"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Singular.jl finite fields implement the Field interface of AbstractAlgebra.jl.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/fields.html","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Below, we describe the functionality that is specific to Singular finite field and not already listed at the given link.","category":"page"},{"location":"GF/#Constructors","page":"Finite fields","title":"Constructors","text":"","category":"section"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"The following constructors are available to create finite fields and their elements.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Singular.FiniteField(::Int, ::Int, ::String; ::Bool)","category":"page"},{"location":"GF/#Singular.FiniteField-Tuple{Int64, Int64, String}","page":"Finite fields","title":"Singular.FiniteField","text":"FiniteField(p::Int, n::Int, S::String; cached=true)\n\nReturns a tuple K, a consisting of a finite field K of characteristic p and degree n, and its generator a. The string used to print the generator is given by S. If the finite field is not listed in the Conway tables included in Singular, an error will be raised. By default, finite fields are cached globally, so that there is only one finite field in the system with given characteristic, degree and string. If this is not the desired behaviour, one can pass false for the optional cached parameter.\n\n\n\n","category":"method"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Given a finite field R, we also have the following coercions in addition to the standard ones expected.","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"R(n::fmpz)","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Coerce a Flint integer value into the field.","category":"page"},{"location":"GF/#Basic-manipulation","page":"Finite fields","title":"Basic manipulation","text":"","category":"section"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Singular.degree(::N_GField)","category":"page"},{"location":"GF/#AbstractAlgebra.Generic.degree-Tuple{N_GField}","page":"Finite fields","title":"AbstractAlgebra.Generic.degree","text":"degree(R::N_GField)\n\nReturn the degree of the field as an extension of mathbbF_p.\n\n\n\n","category":"method"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Singular.characteristic(::N_GField)","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"isunit(::n_GF)","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"GF/","page":"Finite fields","title":"Finite fields","text":"R,w = FiniteField(7, 2, \"w\")\nw^48 == 1\na = R(5)\n\nisunit(a)\nc = characteristic(R)\nd = degree(R)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"CurrentModule = Singular","category":"page"},{"location":"integer/#Integers","page":"Integers","title":"Integers","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"The default integer type in Singular.jl is the Singular n_Z integer type.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"The associated ring of integers is represented by the constant parent object which can be constructed by a call to Singular.Integers().","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"For convenience we define","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"ZZ = Singular.Integers()","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"so that integers can be constructed using ZZ. Note that this is the name of a specific parent object, not the name of its type.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"The types of the integer ring parent objects and elements of the associated rings of integers are given in the following table according to the library providing them.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Library Element type Parent type\nSingular n_Z Singular.Integers","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"All integer element types belong directly to the abstract type RingElem and all the integer ring parent object types belong to the abstract type Ring.","category":"page"},{"location":"integer/#Integer-functionality","page":"Integers","title":"Integer functionality","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"Singular.jl integers implement the ring and possibly some parts of the Euclidean ring interfaces of AbstractAlgebra.jl.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"https://nemocas.github.io/AbstractAlgebra.jl/rings.html","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Below, we describe the functionality that is specific to the Singular integer ring.","category":"page"},{"location":"integer/#Constructors","page":"Integers","title":"Constructors","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"ZZ(n::Integer)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Coerce a Julia integer value into the integer ring.","category":"page"},{"location":"integer/#Basic-manipulation","page":"Integers","title":"Basic manipulation","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"isunit(::n_Z)","category":"page"},{"location":"integer/#AbstractAlgebra.isunit-Tuple{n_Z}","page":"Integers","title":"AbstractAlgebra.isunit","text":"isunit(n::n_Z)\n\nReturn true if n is pm 1.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"denominator(::n_Z)","category":"page"},{"location":"integer/#Base.denominator-Tuple{n_Z}","page":"Integers","title":"Base.denominator","text":"denominator(n::n_Z)\n\nReturn the denominator of n (which will always be 1).\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"numerator(::n_Z)","category":"page"},{"location":"integer/#Base.numerator-Tuple{n_Z}","page":"Integers","title":"Base.numerator","text":"numerator(n::n_Z)\n\nReturn the numerator of n (which is n itself).\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"abs(::n_Z)","category":"page"},{"location":"integer/#Base.abs-Tuple{n_Z}","page":"Integers","title":"Base.abs","text":"abs(n::n_Z)\n\nReturn the absolute value of n.\n\n\n\n","category":"method"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = ZZ(-12)\n\nisunit(a)\nn = numerator(a)\nd = denominator(a)\nc = abs(a)","category":"page"},{"location":"integer/#Euclidean-division","page":"Integers","title":"Euclidean division","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"Singular.jl provides a number of Euclidean division operations. Recall that for a dividend a and divisor b, we can write a = bq + r with 0 leq r  b. We call q the quotient and r the remainder.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"In the following table we list the division functions and their rounding behaviour. We also give the return value of the function, with q representing return of the quotient and r representing return of the remainder.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function Return Rounding\ndivrem(a::n_Z, b::n_Z) q, r towards zero\nrem(a::n_Z, b::n_Z) r towards zero\nmod(a::n_Z, b::n_Z) r down","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = ZZ(-12)\nb = ZZ(5)\n\nq, r = divrem(a, b)\nr = mod(a, b)\nc = a % b","category":"page"},{"location":"integer/#Comparison","page":"Integers","title":"Comparison","text":"","category":"section"},{"location":"integer/","page":"Integers","title":"Integers","text":"Here is a list of the comparison functions implemented, with the understanding that isless provides all the usual comparison operators.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function\nisless(a::n_Z, b::n_Z)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"We also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Function\nisless(a::n_Z, b::Integer)\nisless(a::Integer, b::n_Z)","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"integer/","page":"Integers","title":"Integers","text":"a = ZZ(12)\nb = ZZ(3)\n\na < b\na != b\na > 4\n5 <= b","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"CurrentModule = Singular","category":"page"},{"location":"resolution/#Resolutions","page":"Resolutions","title":"Resolutions","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Functions for creating free resolutions of modules and ideals in Singular.jl return a special Singular object of type sresolution{T}. The support in Singular.jl for this type primarily exists to allow interaction with such resolutions. Free resolutions can have the property of being minimal, which is specified by the minimal field of the sresolution{T} type.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Resolution objects have a parent object which represents the set of resolutions they belong to, the data for which is given by the polynomial ring R over which the modules in the resolution are defined.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"The types of resolutions and associated parent objects are given in the following table according to the library providing them.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Library Element type Parent type\nSingular sresolution{T} Singular.ResolutionSet{T}","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"These types are parameterised by the type of elements in the polynomial ring R over which the modules belonging to the resolution are defined.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"All resolution types belong directly to the abstract type SetElem and all the resolution set parent object types belong to the abstract type Set.","category":"page"},{"location":"resolution/#Resolution-functionality","page":"Resolutions","title":"Resolution functionality","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Singular.jl resolutions implement standard operations one would expect on all AbstractAlgebra compatible objects. These include:","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Below, we describe all of the functionality for Singular.jl resolutions that is not included in this list of basic operations.","category":"page"},{"location":"resolution/#Constructors","page":"Resolutions","title":"Constructors","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"There are currently two ways to create resolutions in Singular.jl: They can either be created by taking the free resolution of an ideal or module over a polynomial ring, as described in the relevant sections of the documentation, or they can be created by the following constructor:","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Resolution(::Array{smodule{T}, 1}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"resolution/#Singular.Resolution-Union{Tuple{Array{smodule{T}, 1}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Resolutions","title":"Singular.Resolution","text":"Resolution(C::Array{smodule{T}, 1}) where T <: AbstractAlgebra.RingElem\n\nCreate a new resolution whose maps are given by the elements of an array C of modules. Note that it is not checked that the maps are actually composable and that their pairwise composition is the zero map, that is, that the created resolution is a complex.\n\n\n\n","category":"method"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Example","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nM1 = Singular.Module(R, vector(R, x), vector(R, y))\nM2 = Singular.Module(R, vector(R, y, -x))\n\nF = Resolution([M1, M2])\nF[1]\nF[2]","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Alternatively, resolutions can be refined to minimal resolutions, as described below.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Other than this, there are currently no additional ways to create resolutions in Singular.jl.","category":"page"},{"location":"resolution/#Basic-manipulation","page":"Resolutions","title":"Basic manipulation","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"length(::sresolution)","category":"page"},{"location":"resolution/#Base.length-Tuple{sresolution}","page":"Resolutions","title":"Base.length","text":"length(r::sresolution)\n\nReturn the length of the resolution. This is what is mathematically meant by the length of a resolution. Over a field, this should be at most the number of variables in the polynomial ring.\n\n\n\n","category":"method"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Singular.jl overloads the getindex function so that one can access the modules in a resolution F.","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"F[n::Int]","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Examples","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"R, (w, x, y, z) = PolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"])\n\nI = Ideal(R, w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\nF = fres(std(I), 0)\n\nn = length(F)\nM1 = F[1]","category":"page"},{"location":"resolution/#Betti-numbers","page":"Resolutions","title":"Betti numbers","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"betti(::sresolution)","category":"page"},{"location":"resolution/#Singular.betti-Tuple{sresolution}","page":"Resolutions","title":"Singular.betti","text":"betti(r::sresolution)\n\nReturn the Betti numbers, i.e. the ranks of the free modules in the given free resolution. These are returned as a Julia array of Ints. Note that the output of this command is useful only in the graded case.\n\n\n\n","category":"method"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Examples","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"R, (w, x, y, z) = PolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"])\n\nI = Ideal(R, w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\nF = fres(std(I), 3)\nM = minres(F)\n\nB = betti(M)","category":"page"},{"location":"resolution/#Minimal-resolutions","page":"Resolutions","title":"Minimal resolutions","text":"","category":"section"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"minres{T <: AbstractAlgebra.RingElem}(::sresolution{T})","category":"page"},{"location":"resolution/#Singular.minres-Union{Tuple{sresolution{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Resolutions","title":"Singular.minres","text":"minres{T <: AbstractAlgebra.RingElem}(r::sresolution{T})\n\nReturn a minimal free resolution, given any free resolution. In the graded case, there exists a uniquely determined minimal resolution. If the supplied resolution is already minimal, it may be returned without making a copy.\n\n\n\n","category":"method"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"Examples","category":"page"},{"location":"resolution/","page":"Resolutions","title":"Resolutions","text":"R, (w, x, y, z) = PolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"])\n\nI = Ideal(R, w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\nF = fres(std(I), 3)\nM = minres(F)","category":"page"},{"location":"#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Singular.jl is a Julia interface to the Singular computer algebra system. It was written by Oleksandr Motsak, William Hart and other contributors, and is maintained by William Hart, Hans Schoenemann and Andreas Steenpas. It is part of the Oscar project which is funded by the DFG TRR 195 program.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"https://www.singular.uni-kl.de/ (Singular website)\nhttps://github.com/oscar-system/Singular.jl (Singular.jl source code)\nhttps://oscar-system.github.io/Singular.jl/ (Singular.jl online documentation)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"The features of Singular so far include:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Singular integers, rationals Z/nZ, Z/pZ, Galois fields\nMultivariate polynomials\nIdeals over polynomial rings\nFree modules over polynomial rings and submodules given by a finite generating set\nGroebner basis over a field\nFree/minimal resolutions\nSyzygy modules\nNemo.jl rings can be used as coefficient rings","category":"page"},{"location":"#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"To use Singular.jl we require Julia 1.3 or higher. Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"At the Julia prompt simply type","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg\njulia> Pkg.add(\"Singular\")","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Here is an example of using Singular.jl","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> using Singular\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Singular Polynomial Ring (QQ),(x,y),(dp(2),C), Singular.spoly{Singular.n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y + 1)\nSingular Ideal over Singular Polynomial Ring (QQ),(x,y),(dp(2),C) with generators (x^2+1, x*y+1)\n\njulia> G = std(I)\nSingular Ideal over Singular Polynomial Ring (QQ),(x,y),(dp(2),C) with generators (x-y, y^2+1)\n\njulia> Z = syz(G)\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\ny^2*gen(1)-x*gen(2)+y*gen(2)+gen(1)\n\njulia> F = fres(G, 0)\nSingular Resolution:\nR^1 <- R^2 <- R^1\n\njulia> F[1]\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\nx-y\ny^2+1","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"CurrentModule = Singular","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"DocTestSetup = quote\n  using Singular\n  using Singular: PolynomialRing, vector, std, reduce\nend","category":"page"},{"location":"module/#Finitely-generated-modules","page":"Finitely generated modules","title":"Finitely generated modules","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Singular.jl allows the creation of submodules of a free module over a Singular polynomial ring, given by a finite generating set. These are internally stored as a list of elements of a free module over a polynomial ring R. This list of generators can also have the property of being a Groebner basis.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"The default finitely generated module type in Singular.jl is the Singular smodule type.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Module objects have a parent object which represents the class of R-modules they belong to, the data for which is given by the polynomial ring R over which the modules are defined.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"The types of modules and associated parent objects are given in the following table according to the library providing them.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Library Element type Parent type\nSingular smodule{T} Singular.ModuleClass{T}","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"These types are parameterised by the type of elements in the polynomial ring R.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"All module types belong directly to the abstract type Module{T} and all the module class parent object types belong to the abstract type Set.","category":"page"},{"location":"module/#Module-functionality","page":"Finitely generated modules","title":"Module functionality","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Singular.jl modules implement standard operations one would expect on modules. These include:","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Operations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Below, we describe all of the functionality for Singular.jl modules that is not included in this list of basic operations.","category":"page"},{"location":"module/#Constructors","page":"Finitely generated modules","title":"Constructors","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Given a Singular polynomial ring R, the following constructors are available for creating modules.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Module{T <: Nemo.RingElem}(R::PolyRing{T}, vecs::svector{spoly{T}}...)","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Construct the module over the polynomial ring R whose generators are given by the given parameter list of vectors (of length n), each component of which is a polynomial. These vectors represent elements of the free module R^n.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Note that Module must be prepended with the package name Singular to disambiguate from Base.Module.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nv1 = vector(R, x + 1, x*y + 1, y)\nv2 = vector(R, x^2 + 1, 2x + 3y, x)\n\nM = Singular.Module(R, v1, v2)","category":"page"},{"location":"module/#Basic-manipulation","page":"Finitely generated modules","title":"Basic manipulation","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"ngens(::smodule)","category":"page"},{"location":"module/#AbstractAlgebra.Generic.ngens-Tuple{smodule}","page":"Finitely generated modules","title":"AbstractAlgebra.Generic.ngens","text":"ngens(I::smodule)\n\nReturn the number of generators in the current representation of the module (as a list of vectors).\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"rank(::smodule)","category":"page"},{"location":"module/#LinearAlgebra.rank-Tuple{smodule}","page":"Finitely generated modules","title":"LinearAlgebra.rank","text":"rank(I::smodule)\n\nReturn the rank n of the ambient space R^n of which this module is a submodule.\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Singular.jl overloads the setindex! and getindex functions so that one can access the generators of a module using array notation. Each entry is a vector in R^n.","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"M[n::Int]","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"iszero(::smodule)","category":"page"},{"location":"module/#Base.iszero-Tuple{smodule}","page":"Finitely generated modules","title":"Base.iszero","text":"iszero(p::smodule)\n\nReturn true if this is algebraically the zero module.\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nv1 = vector(R, x + 1, x*y + 1, y)\nv2 = vector(R, x^2 + 1, 2x + 3y, x)\n\nM = Singular.Module(R, v1, v2)\n\niszero(M) == false\nM[1] == v1\nn = rank(M)\nd = ngens(M)","category":"page"},{"location":"module/#Standard-basis","page":"Finitely generated modules","title":"Standard basis","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"std(::smodule; ::Bool)","category":"page"},{"location":"module/#Statistics.std-Tuple{smodule}","page":"Finitely generated modules","title":"Statistics.std","text":"std(I::smodule; complete_reduction::Bool=false)\n\nCompute the Groebner basis of the module I. If complete_reduction is set to true, the result is unique, up to permutation of the generators and multiplication by constants. If not, only the leading terms are unique (up to permutation of the generators and multiplication by constants, of course). Presently the polynomial ring used must be over a field or over the Singular integers.\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"lift_std(::smodule; ::Bool)","category":"page"},{"location":"module/#Singular.lift_std-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.lift_std","text":"lift_std(M::smodule)\n\ncomputes the Groebner base G of M and the transformation matrix T such that (Matrix(G) = Matrix(M) * T)\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"lift_std_syz(::smodule; ::Bool)","category":"page"},{"location":"module/#Singular.lift_std_syz-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.lift_std_syz","text":"lift_std_syz(M::smodule)\n\ncomputes the Groebner base G of M, the transformation matrix T and the syzygies of M. Returns G,T,S (Matrix(G) = Matrix(M) * T, 0=Matrix(M)*Matrix(S))\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nv1 = vector(R, x + 1, x*y + 1, y)\nv2 = vector(R, x^2 + 1, 2x + 3y, x)\nv3 = x*v1 + y*v2 + vector(R, x, y + 1, y^2)\n\nM = Singular.Module(R, v1, v2, v3)\n\nG = std(M; complete_reduction=true)","category":"page"},{"location":"module/#Reduction","page":"Finitely generated modules","title":"Reduction","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"reduce(::smodule, ::smodule)","category":"page"},{"location":"module/#Base.reduce-Tuple{smodule, smodule}","page":"Finitely generated modules","title":"Base.reduce","text":"reduce(M::smodule, G::smodule) Return a submodule whose generators are the generators of M reduced by the submodule G. The submodule G is required to be given by a Groebner basis. The returned submodule will have the same number of generators as M, even if they are zero.\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"julia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])\n\njulia> v1 = vector(R, R(0), z, -y)\n-y*gen(3)+z*gen(2)\n\njulia> v2 = vector(R, -z, R(0), x)\nx*gen(3)-z*gen(1)\n\njulia> v3 = vector(R, y, x, R(0))\nx*gen(2)+y*gen(1)\n\njulia> v = y*v1+x*v2+z*v3\nx^2*gen(3)-y^2*gen(3)+x*z*gen(2)-x*z*gen(1)+y*z*gen(2)+y*z*gen(1)\n\njulia> M = Singular.Module(R, v1, v2, v3)\nSingular Module over Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), with Generators:\n-y*gen(3)+z*gen(2)\nx*gen(3)-z*gen(1)\nx*gen(2)+y*gen(1)\n\njulia> B = std(M; complete_reduction=true)\nSingular Module over Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), with Generators:\ny*gen(3)-z*gen(2)\nx*gen(2)+y*gen(1)\nx*gen(3)-z*gen(1)\ny*z*gen(1)\n\njulia> V = Singular.Module(R, v)\nSingular Module over Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), with Generators:\nx^2*gen(3)-y^2*gen(3)+x*z*gen(2)-x*z*gen(1)+y*z*gen(2)+y*z*gen(1)\n\njulia> reduce(V,B)\nSingular Module over Singular Polynomial Ring (QQ),(x,y,z),(dp(3),C), with Generators:\n0\n","category":"page"},{"location":"module/#Syzygies","page":"Finitely generated modules","title":"Syzygies","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"syz(::smodule)","category":"page"},{"location":"module/#Singular.syz-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.syz","text":"syz(M::smodule)\n\nCompute the module of syzygies of the given module. This will be given as a set of generators in an ambient space R^n, where n is the number of generators in M.\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nv1 = vector(R, (x + 1)*y, (x*y + 1)*y, y)\nv2 = vector(R, (x + 1)*x, (x*y + 1)*x, x)\n\nM = Singular.Module(R, v1, v2)\n\nZ = syz(M)","category":"page"},{"location":"module/#Free-resolutions","page":"Finitely generated modules","title":"Free resolutions","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"sres{T <: Nemo.RingElem}(::smodule{T}, ::Int)","category":"page"},{"location":"module/#Singular.sres-Union{Tuple{T}, Tuple{smodule{T}, Int64}} where T<:AbstractAlgebra.RingElem","page":"Finitely generated modules","title":"Singular.sres","text":"sres{T <: Nemo.RingElem}(I::smodule{T}, max_length::Int)\n\nCompute a free resolution of the given module I of length up to the given maximum length. If max_length is set to zero, a full length free resolution is computed. Each element of the resolution is itself a module.\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nv1 = vector(R, x + 1, x*y + 1, y)\nv2 = vector(R, x^2 + 1, 2x + 3y, x)\n\nM = std(Singular.Module(R, v1, v2))\n\nF = sres(M, 0)\n\nM1 = Singular.Matrix(M)\nM2 = Singular.Matrix(F[2])\n\n# test we have a complex\niszero(M1*M2)","category":"page"},{"location":"module/#Jet-of-module","page":"Finitely generated modules","title":"Jet of module","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"jet(::smodule, ::Int)","category":"page"},{"location":"module/#Singular.jet-Tuple{smodule, Int64}","page":"Finitely generated modules","title":"Singular.jet","text":"jet(M::smodule, n::Int) Given a module M this function truncates the generators of M up to degree n.\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n\nv1 = vector(R, x + 1, x*y + 1, y)\nv2 = vector(R, x^5 + 1, 2x^3 + 3y^2, x^2)\n\nM = Singular.Module(R, v1, v2)\nN = jet(M,3)","category":"page"},{"location":"module/#Operations-over-local-rings","page":"Finitely generated modules","title":"Operations over local rings","text":"","category":"section"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"If the base ring R is a local ring, a minimal generating set can be computed using the following function","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"minimal_generating_set(::smodule)","category":"page"},{"location":"module/#Singular.minimal_generating_set-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.minimal_generating_set","text":"minimalgeneratingset(M::smodule) Given a module M in ring R with local ordering, this returns an array containing the minimal generators of M.\n\n\n\n","category":"method"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"Examples","category":"page"},{"location":"module/","page":"Finitely generated modules","title":"Finitely generated modules","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]; ordering=:negdegrevlex)\n\nhas_local_ordering(R) == true\n\nv1 = vector(R, x, y^2)\nv2 = vector(R, y - x, y - y^2)\nv3 = v1 + v2\n\nM = Singular.Module(R, v1, v2, v3)\n\nmin = minimal_generating_set(M)","category":"page"}]
}
