var documenterSearchIndex = {"docs":
[{"location":"polynomial/#Multivariate-polynomials","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Singular.jl allows the creation of multivariate polynomials over any of the coefficient rings described above.\n\nThe default multivariate polynomial type in Singular.jl is the Singular spoly type.\n\nThe associated polynomial ring is represented by a parent object which can be constructed by a call to the polynomial_ring constructor.\n\nThe types of the polynomial ring parent objects and elements thereof are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular spoly{T} Singular.PolyRing{T}\n\nThese types are parameterised by the type of elements in the coefficient ring of the polynomials.\n\nAll polynomial types belong directly to the abstract type MPolyRingElem and all the polynomial ring parent object types belong to the abstract type MPolyRing.","category":"section"},{"location":"polynomial/#Multivariate-polynomial-functionality","page":"Multivariate polynomials","title":"Multivariate polynomial functionality","text":"Singular.jl polynomials provides all the Multivariate Polynomial Ring functionality described by AbstractAlgebra.jl.\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial\n\nIn particular, Singular polynomials are sparse distributed, but do not have random access. Instead, they implement iterator access to terms. This is due to their storage in a linked list, for efficient implementation of Groebner basis algorithms.\n\nSome polynomial rings may also implement part of the Euclidean Ring interface, where this is appropriate.\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface\n\nBelow, we describe the functionality that is specific to the Singular multivariate polynomials that is not documented in the general multivariate interface.","category":"section"},{"location":"polynomial/#Constructors","page":"Multivariate polynomials","title":"Constructors","text":"polynomial_ring(R::Union{Ring, Field}, s::AbstractVector{<:VarName};\n               cached::Bool = true, ordering = :degrevlex,\n               ordering2::Symbol = :comp1min, degree_bound::Int = 0)\n\nReturns a tuple, S x consisting of a multivariate polynomial ring S and an array x of variables (from which polynomials can be constructed). The ring R must be a valid Singular coefficient ring, or any Nemo/AbstractAlgebra coefficient ring. The array s must be a list of strings corresponding to how the variables will be printed. By default, there will only be one Singular polynomial ring in the system for each combination of coefficient ring, list of variable names, ordering and degree bound. This is accomplished by making use of a global cache. If this is not the desired behaviour, false can be passed to the optional argument cached.\n\nIf the first ordering ordering is specified as a symbol, then two orderings can be specified, one for term ordering of the polynomials, and another for ordering of module components. They can occur in either order, the first taking precedence over the other, when the polynomials are used to represent module generators. If either is not specified, the indicated default is used. The options for polynomial term ordering are, :lex, :deglex, :degrevlex, :neglex, :negdeglex and :negdegrevlex, and the options for module component ordering are comp1min and comp1max.\n\nIf the first ordering ordering is specified as a non-symbol, the second ordering ordering2 will be ignored. For specifying non-symbolic term orderings, please see the Term orderings section below.\n\nIf one has an a priori bound on the degree in each variable of a polynomial (including for all intermediate computations in this ring), one can specify it using the degree_bound optional parameter. Singular may then be able to use a more efficient representation internally, which will use less memory and allow for faster arithmetic. By default, Singular uses a bound of 16 bits internally for the exponent of each variable, however this is a signed value, so that the default is for nonnegative exponents that fit in 15 bits.\n\nNote that internally, Singular may use a higher bound than specified, if it will not increase the amount of storage required.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(ZZ, [\"x\", \"y\", \"z\"])\n(Singular polynomial ring (ZZ),(x,y,z),(dp(3),C), spoly{n_Z}[x, y, z])\n\njulia> S, vars = polynomial_ring(QQ, [\"x\", \"y\"]; ordering=:deglex)\n(Singular polynomial ring (QQ),(x,y),(Dp(2),C), spoly{n_Q}[x, y])\n\njulia> T, x = polynomial_ring(ZZ, [\"x$i\" for i in 1:5];\n              ordering=:comp1max, ordering2=:degrevlex, degree_bound=5)\n(Singular polynomial ring (ZZ),(x1,x2,x3,x4,x5),(c,dp(5),L(5)), spoly{n_Z}[x1, x2, x3, x4, x5])\n\nSee also the convenience macros below for simple use cases.\n\nThe following function allows creating a Singular polynomial ring from a given polynomial ring of type AbstractAlgebra.Generic.MPolyRing:\n\npolynomial_ring(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true, ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min, degree_bound::Int = 0)  where {T <: RingElement}\n\nPolynomials can be constructed using arithmetic operations on the generators, but this can be extremely inefficient. For this purpose, Singular polynomials support construction using a build context, as described in the AbstractAlgebra documentation:\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/mpolynomial\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])\n\njulia> C = MPolyBuildCtx(R)\nBuilder for an element of Singular polynomial ring (ZZ),(x,y),(dp(2),C)\n\njulia> push_term!(C, ZZ(1), [1, 2])\nx*y^2\n\njulia> push_term!(C, ZZ(3), [1, 1])\nx*y^2 + 3*x*y\n\njulia> push_term!(C, -ZZ(1), [0, 1])\nx*y^2 + 3*x*y - y\n\njulia> f = finish(C)\nx*y^2 + 3*x*y - y","category":"section"},{"location":"polynomial/#Term-orderings","page":"Multivariate polynomials","title":"Term orderings","text":"A general term ordering can be constructed as a product of one or more of the following block orderings.\n\nExamples\n\npolynomial_ring(QQ, \"x\".*string.(1:8), ordering = ordering_M([1 2; 3 5])*ordering_lp(3)*ordering_wp([1, 2, 3]))\n\npolynomial_ring(QQ, \"x\".*string.(1:5), ordering = ordering_dp(3)*ordering_dp())","category":"section"},{"location":"polynomial/#Polynomial-ring-macros","page":"Multivariate polynomials","title":"Polynomial ring macros","text":"For convenience, we provide some macros for constructing polynomial rings and injecting the variables into scope. These are easier to use, but have some limitations. In particular, they can only be used at the top level by the user, and cannot be used programmatically or in library code (it is not possible to inject an arbitrary number of variables into scope inside a function).\n\nThe macros are designed for simple use cases, and do not offer the full power of the most general constructor above.\n\n@polynomial_ring(R, s, n, o)\n\nGiven a coefficient ring R, a root variable name, e.g. \"x\", a number of variable n and a polynomial term ordering o, create the variables x1, x2, ..., xn and inject them into scope, and return the corresponding polynomial ring S.\n\n@polynomial_ring(R, s, n)\n\nAs per the previous macro, with a default of :degrevlex for the polynomial term ordering.\n\nExamples\n\njulia> S = @polynomial_ring(ZZ, \"x\", 5, :deglex)\nSingular polynomial ring (ZZ),(x1,x2,x3,x4,x5),(Dp(5),C)\n\njulia> T = @polynomial_ring(QQ, \"y\", 10)\nSingular polynomial ring (QQ),(y1,y2,y3,y4,y5,y6,y7,y8,y9,y10),(dp(10),C)","category":"section"},{"location":"polynomial/#Basic-manipulation","page":"Multivariate polynomials","title":"Basic manipulation","text":"Examples\n\njulia> R = @polynomial_ring(ZZ, \"x\", 3)\nSingular polynomial ring (ZZ),(x1,x2,x3),(dp(3),C)\n\njulia> n = nvars(R)\n3\n\njulia> has_global_ordering(R) == true\ntrue\n\njulia> c = characteristic(R)\n0\n\njulia> L = degree_bound(R)\n1048575\n\njulia> exps = leading_exponent_vector(x1*x2 + 3x1*x2^2 + x3 + 2)\n3-element Vector{Int64}:\n 1\n 2\n 0\n\njulia> deg = total_degree(x1*x2 + 3x1*x2^2 + x3 + 2)\n3\n\njulia> ord = order(x1*x2 + 3x1*x2^2 + x3 + 2)\n0","category":"section"},{"location":"polynomial/#Differential-functions","page":"Multivariate polynomials","title":"Differential functions","text":"Working over any coefficient ring, basic functionality involving differential operations is available.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])\n\njulia> f = x^2*y*z + z^2*x + x*y*z\nx^2*y*z + x*y*z + x*z^2\n\njulia> g = jet(f, 3)\nx*y*z + x*z^2\n\njulia> derivative(f, 1)\n2*x*y*z + y*z + z^2\n\njulia> derivative(f, y)\nx^2*z + x*z\n\njulia> J = jacobian_ideal(f)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(dp(3),C) with generators (2*x*y*z + y*z + z^2, x^2*z + x*z, x^2*y + x*y + 2*x*z)\n\njulia> Jf1 = jacobian_matrix(f)\n[2*x*y*z + y*z + z^2\nx^2*z + x*z\nx^2*y + x*y + 2*x*z]\n\njulia> Jf2 = jacobian_matrix([f, g])\n[2*x*y*z + y*z + z^2, x^2*z + x*z, x^2*y + x*y + 2*x*z\ny*z + z^2, x*z, x*y + 2*x*z]","category":"section"},{"location":"polynomial/#Content-and-primitive-part","page":"Multivariate polynomials","title":"Content and primitive part","text":"When coefficient rings have a meaningful GCD function, the following functions are available.\n\nExamples\n\njulia> R = @polynomial_ring(ZZ, \"x\", 2)\nSingular polynomial ring (ZZ),(x1,x2),(dp(2),C)\n\njulia> f = 3x1^2 + 3x1*x2 + 6x2^2\n3*x1^2 + 3*x1*x2 + 6*x2^2\n\njulia> p = primpart(f)\nx1^2 + x1*x2 + 2*x2^2\n\njulia> c = content(f)\n3","category":"section"},{"location":"polynomial/#Homogeneous-polynomials","page":"Multivariate polynomials","title":"Homogeneous polynomials","text":"","category":"section"},{"location":"polynomial/#Multivariate-Factorisation","page":"Multivariate polynomials","title":"Multivariate Factorisation","text":"For the Singular base fields QQ and Fp a function to compute a squarefree factorization is available.\n\nExamples\n\njulia> R = @polynomial_ring(QQ, \"x\", 4)\nSingular polynomial ring (QQ),(x1,x2,x3,x4),(dp(4),C)\n\njulia> f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2;\n\njulia> Fac = factor(f)\n123 * (x2*x3 + x1)^2 * (x1^2 + x1 + 1)^2 * (x4^5 + 57*x2^3)^3\n\nFor the Singular base rings QQ, ZZ and Fp a function to compute the multivariate factorization is available.\n\nExamples\n\njulia> R = @polynomial_ring(ZZ, \"x\", 4)\nSingular polynomial ring (ZZ),(x1,x2,x3,x4),(dp(4),C)\n\njulia> f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2;\n\njulia> Fac = factor(f)\n123 * (x2*x3 + x1)^2 * (x1^2 + x1 + 1)^2 * (x4^5 + 57*x2^3)^3","category":"section"},{"location":"polynomial/#Change-of-coefficient-rings","page":"Multivariate polynomials","title":"Change of coefficient rings","text":"It is possible to change the coefficient ring of a given polynomial p via the function 'changebasering'.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])\n\njulia> p = x^5 + y^3+1\nx^5 + y^3 + 1\n\njulia> p2 = change_base_ring(QQ, p)\nx^5 + y^3 + 1\n\njulia> parent(p2)\nSingular polynomial ring (QQ),(x,y),(dp(2),C)\n\nIt also possible to work with Nemo rings by casting to a suitable Singular type via CoefficientRing.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])\n\njulia> p = x^5 + y^3+1\nx^5 + y^3 + 1\n\njulia> p2 = change_base_ring(CoefficientRing(Singular.Nemo.QQ), p)\nx^5 + y^3 + 1","category":"section"},{"location":"polynomial/#Singular.ordering_lp","page":"Multivariate polynomials","title":"Singular.ordering_lp","text":"ordering_lp(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the lexicographical ordering (:lex).\n\nThis is the Singular ordering lp.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_ip","page":"Multivariate polynomials","title":"Singular.ordering_ip","text":"ordering_ip(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the Singular ordering ip. This stands for what the Singular manual refers to as \"reverse lexicographical ordering\" (and is elsewhere sometimes called \"inverse lexicographical ordering), i.e. a lexicographical ordering from the right with 1 < x_1 < ... < x_n.\n\nNote that this reverses the \"natural\" order x_1 > ... > x_n.\n\nThis is the Singular ordering ip.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_rp","page":"Multivariate polynomials","title":"Singular.ordering_rp","text":"ordering_rp(nvars::Int = 1)\n\nAlias for ordering_ip, provided for backwards compatibility.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_dp","page":"Multivariate polynomials","title":"Singular.ordering_dp","text":"ordering_dp(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the degree reverse lexicographical ordering (:degrevlex).\n\nThis is the Singular ordering dp.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_Dp","page":"Multivariate polynomials","title":"Singular.ordering_Dp","text":"ordering_Dp(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the degree lexicographical ordering (:deglex).\n\nThis is the Singular ordering Dp.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_wp-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_wp","text":"ordering_wp(w::Vector{Int})\n\nRepresents a block of variables with the weighted reverse lexicographical ordering. The weight vector w is expected to consist of positive integers only.\n\nThis is the Singular ordering wp.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.ordering_Wp-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_Wp","text":"ordering_Wp(w::Vector{Int})\n\nRepresents a block of variables with the weighted lexicographical ordering. The weight vector is expected to consist of positive integers only.\n\nThis is the Singular ordering Wp.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.ordering_Ip","page":"Multivariate polynomials","title":"Singular.ordering_Ip","text":"ordering_Ip(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the degree inverse lexicographical ordering (:deginvlex).\n\nNote that this reverses the \"natural\" order x_1 > ... > x_n.\n\nThis is the Singular ordering Ip.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_ls","page":"Multivariate polynomials","title":"Singular.ordering_ls","text":"ordering_ls(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the negative lexicographical ordering (:neglex).\n\nThis is the Singular ordering ls.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_is","page":"Multivariate polynomials","title":"Singular.ordering_is","text":"ordering_is(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the negative inverse lexicographical ordering (:neginvlex).\n\nNote that this reverses the \"natural\" order x_1 > ... > x_n.\n\nThis is the Singular ordering is.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_rs","page":"Multivariate polynomials","title":"Singular.ordering_rs","text":"ordering_rs(nvars::Int = 1)\n\nAlias for ordering_is, provided for backwards compatibility.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_ds","page":"Multivariate polynomials","title":"Singular.ordering_ds","text":"ordering_ds(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the negative degree reverse lexicographical ordering (:negdegrevlex).\n\nThis is the Singular ordering ds.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_Ds","page":"Multivariate polynomials","title":"Singular.ordering_Ds","text":"ordering_Ds(nvars::Int = 1)\n\nRepresents a block of at least nvars variables with the negative degree reverse lexicographical ordering (:negdeglex).\n\nThis is the Singular ordering Ds.\n\n\n\n\n\n","category":"function"},{"location":"polynomial/#Singular.ordering_ws-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_ws","text":"ordering_ws(w::Vector{Int})\n\nRepresents a block of variables with the general weighted reverse lexicographical ordering. The weight vector w is expected to have a nonzero first entry.\n\nThis is the Singular ordering ws.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.ordering_Ws-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_Ws","text":"ordering_Ws(w::Vector{Int})\n\nRepresents a block of variables with the general weighted lexicographical ordering. The weight vector w is expected to have a nonzero first entry.\n\nThis is the Singular ordering Ws.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.ordering_a-Tuple{Vector{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_a","text":"ordering_a(w::Vector{Int})\n\nRepresents an extra weight vector that may precede any monomial ordering. An extra weight vector does not define a monomial ordering by itself: it can only be used in combination with other orderings to insert an extra line of weights into the ordering matrix.\n\nThis is the Singular ordering a.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.ordering_M-Tuple{Matrix{Int64}}","page":"Multivariate polynomials","title":"Singular.ordering_M","text":"ordering_M(m::Matrix{Int}; checked::Bool = true)\n\nRepresents a block of variables with a general matrix ordering. The matrix m is expected to be invertible, and this is checked by default.\n\nThis is the Singular ordering M.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.ordering_C-Tuple{}","page":"Multivariate polynomials","title":"Singular.ordering_C","text":"ordering_C()\n\nRepresents an ascending ordering on vector components gen(1) < gen(2) < .... All monomial block orderings preceding the component ordering have higher precedence, and all succeeding monomial block orderings have lower precedence. It is not necessary to specify this ordering explicitly since it appended automatically to an ordering lacking a component specification.\n\nThis is the Singular ordering C.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.ordering_c-Tuple{}","page":"Multivariate polynomials","title":"Singular.ordering_c","text":"ordering_c()\n\nRepresents a descending ordering on vector components gen(1) > gen(2) > .... All monomial block orderings preceding the component ordering have higher precedence, and all succeeding monomial block orderings have lower precedence.\n\nThis is the Singular ordering c.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.has_global_ordering-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.has_global_ordering","text":"has_global_ordering(R::PolyRingUnion)\n\nReturn true if the given ring has a global ordering, i.e. if 1  x for each variable x in the ring. This include :lex, :deglex and :degrevlex orderings.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.has_mixed_ordering-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.has_mixed_ordering","text":"has_mixed_ordering(R::PolyRingUnion)\n\nReturn true if the given ring has a mixed ordering, i.e. if 1  x_i for a variable x_i and 1x_j for another variable x_j.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.has_local_ordering-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.has_local_ordering","text":"has_local_ordering(R::PolyRingUnion)\n\nReturn true if the given ring has a local ordering, i.e. if 1  x for all variables x.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.degree_bound-Tuple{PolyRing}","page":"Multivariate polynomials","title":"Singular.degree_bound","text":"degree_bound(R::PolyRing)\n\nReturn the internal degree bound in each variable, enforced by Singular. This is the largest positive value any degree can have before an overflow will occur. This internal bound may be higher than the bound requested by the user via the degree_bound parameter of the polynomial_ring constructor.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.Generic.total_degree-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.Generic.total_degree","text":"total_degree(p::spoly)\n\nReturn the total degree (largest sum of exponents of any monomial) of p.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.order-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.order","text":"order(p::spoly)\n\nReturn the order of p.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.jet-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.jet","text":"jet(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the truncation of x up to degree n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, Int64}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"AbstractAlgebra.derivative","text":"derivative(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable of index n.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.derivative-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"AbstractAlgebra.derivative","text":"derivative(x::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable v.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.jacobian_ideal-Union{Tuple{spoly{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.jacobian_ideal","text":"jacobian_ideal(p::spoly{T}) where T <: Nemo.RingElem\n\nReturn the ideal generated by all partial derivatives of x.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.jacobian_matrix-Union{Tuple{spoly{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.jacobian_matrix","text":"jacobian_matrix(p::spoly{T}) where T <: Nemo.RingElem\n\nReturn the column matrix fracpartial ppartial x_i_i of partial derivatives.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.jacobian_matrix-Union{Tuple{Array{spoly{T}, 1}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.jacobian_matrix","text":"jacobian_matrix(a::Vector{spoly{T}}) where T <: Nemo.RingElem\n\nReturn the matrix fracpartial a_ipartial x_j_ij of partial derivatives.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.primpart-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.primpart","text":"primpart(x::SPolyUnion)\n\nReturn the primitive part of the polynomial, i.e. the polynomial divided by the GCD of its coefficients.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#AbstractAlgebra.content-Tuple{spoly}","page":"Multivariate polynomials","title":"AbstractAlgebra.content","text":"content(x::SPolyUnion)\n\nReturn the content of the polynomial, i.e. the GCD of its coefficients.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#Singular.homogenize-Union{Tuple{T}, Tuple{spoly{T}, spoly{T}}} where T<:AbstractAlgebra.RingElem","page":"Multivariate polynomials","title":"Singular.homogenize","text":"homogenize(p::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nMultiply each monomial in p by a suitable power of the variable v and return the corresponding homogeneous polynomial. The variable v must have weight 1.\n\n\n\n\n\n","category":"method"},{"location":"modn/#Integers-mod-n","page":"Integers mod n","title":"Integers mod n","text":"Integers mod n are implemented via the Singular n_Zn type for any positive modulus that can fit in a Julia Int.\n\nThe associated ring of integers mod n is represented by a parent object which can be constructed by a call to the residue_ring constructor.\n\nThe types of the parent objects and elements of the associated rings of integers modulo n are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular n_Zn Singular.N_ZnRing\n\nAll integer mod n element types belong directly to the abstract type RingElem and all the parent object types belong to the abstract type Ring.","category":"section"},{"location":"modn/#Integer-mod-n-functionality","page":"Integers mod n","title":"Integer mod n functionality","text":"Singular.jl integers modulo n provide all the AbstractAlgebra ring and residue ring functionality.\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/ring\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/residue\n\nParts of the Euclidean Ring interface may also be implemented, though Singular will report an error if division is meaningless (even after cancelling zero divisors).\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface\n\nBelow, we describe the functionality that is specific to the Singular integers mod n ring and not already listed at the given links.","category":"section"},{"location":"modn/#Constructors","page":"Integers mod n","title":"Constructors","text":"Given a ring R of integers modulo n, we also have the following coercions in addition to the standard ones expected.\n\nR(n::n_Z)\nR(n::ZZRingElem)\n\nCoerce a Singular or Flint integer value into the ring.","category":"section"},{"location":"modn/#Basic-manipulation","page":"Integers mod n","title":"Basic manipulation","text":"Examples\n\njulia> R, = residue_ring(ZZ, 26);\n\njulia> a = R(5)\n5\n\njulia> is_unit(a)\ntrue\n\njulia> c = characteristic(R)\n26","category":"section"},{"location":"qring/#Quotient-Rings","page":"Quotient Rings","title":"Quotient Rings","text":"Quotient rings Q = RI in Singular.jl are constructed with the constructor QuotientRing(R, I). The input ideal I to the constructor must be a Groebner basis. The R-ideal I may be recovered as quotient_ideal(Q).\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]);\n\njulia> is_quotient_ring(R)\nfalse\n\njulia> Q1, (x, y) = QuotientRing(R, Ideal(R, x^2+y^2));\n\njulia> is_quotient_ring(Q1)\ntrue\n\njulia> quotient_ideal(Q1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + y^2)\n\njulia> Q2, (x, y) = QuotientRing(Q1, std(Ideal(Q1, x*y)));\n\njulia> quotient_ideal(Q2)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x*y, y^3, x^2 + y^2)\n\njulia> base_ring(quotient_ideal(Q1)) == base_ring(quotient_ideal(Q2))\ntrue","category":"section"},{"location":"qring/#Singular.is_quotient_ring-Tuple{Union{LPRing{T}, PluralRing{T}, PolyRing{T}} where T<:AbstractAlgebra.RingElem}","page":"Quotient Rings","title":"Singular.is_quotient_ring","text":"is_quotient_ring(R::PolyRingUnion)\n\nReturn true if the given ring is the quotient of a polynomial ring with a non - zero ideal.\n\n\n\n\n\n","category":"method"},{"location":"qring/#Singular.quotient_ideal-Union{Tuple{PolyRing{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Quotient Rings","title":"Singular.quotient_ideal","text":"quotient_ideal(Q::PolyRing{T}) where T <: Nemo.RingElem\n\nReturn I for a given quotient ring Q = R/I.\n\n\n\n\n\n","category":"method"},{"location":"rational/#Rational-field","page":"Rational field","title":"Rational field","text":"Singular.jl provides rational numbers via Singular's n_Q type.\n\nThere is a constant parent object representing the field of rationals, called QQ in Singular.jl. It is defined by QQ = Rationals(), which calls the constructor for the unique field of rationals in Singular.","category":"section"},{"location":"rational/#Rational-functionality","page":"Rational field","title":"Rational functionality","text":"The rationals in Singular.jl provide all functionality for fields and fraction fields described by AbstractAlgebra.jl.\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/field\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/fraction\n\nWe describe here only the extra functionality provided by Singular that is not already described in those interfaces.","category":"section"},{"location":"rational/#Constructors","page":"Rational field","title":"Constructors","text":"In addition to the standard constructors required for the interfaces listed above, Singular.jl provides the following constructors.\n\nQQ(n::n_Z)\nQQ(n::ZZRingElem)\n\nConstruct a Singular rational from the given integer n.\n\nExamples\n\njulia> f = QQ(-12, 7)\n-12//7\n\njulia> h = numerator(f)\n-12\n\njulia> k = denominator(f)\n7\n\njulia> m = abs(f)\n12//7\n\njulia> a = QQ(12, 7)\n12//7\n\njulia> b = QQ(-3, 5)\n-3//5\n\njulia> a > b\ntrue\n\njulia> a != b\ntrue\n\njulia> a > 1\ntrue\n\njulia> 5 >= b\ntrue","category":"section"},{"location":"rational/#Rational-reconstruction","page":"Rational field","title":"Rational reconstruction","text":"The following ad hoc versions of the same function also exist.\n\nreconstruct(::n_Z, ::Integer)\nreconstruct(::Integer, ::n_Z)\n\nExamples\n\njulia> q1 = reconstruct(ZZ(7), ZZ(3))\n1\n\njulia> q2 = reconstruct(ZZ(7), 5)\n-1//2","category":"section"},{"location":"rational/#Nemo.reconstruct-Tuple{n_Z, n_Z}","page":"Rational field","title":"Nemo.reconstruct","text":"reconstruct(x::n_Z, y::n_Z)\n\nGiven x modulo y, find rs such that x equiv rs pmody for values r and s satisfying the bound y  2(r + 1)(s + 1).\n\n\n\n\n\n","category":"method"},{"location":"matrix/#Matrices","page":"Matrices","title":"Matrices","text":"Singular internally allows for matrices over polynomial rings to be created extremely efficiently from ideals and modules (often without copying data). This allows for introspection of modules and operations that can be expressed in terms of matrices (e.g. composition of R-module homomorphisms) to be computed, at a low level.\n\nThe default matrix type in Singular.jl is the smatrix type.\n\nMatrix objects have a parent object which represents the space of matrices they belong to, the data for which is given by the polynomial ring R over which the matrices are defined, and the number of rows and columns of the matrices in the space.\n\nThe types of matrices and associated parent objects are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular smatrix{T} Singular.matrix_space{T}\n\nThese types are parameterised by the type of elements in the polynomial ring R over which the matrices are defined.\n\nAll matrix types belong directly to the abstract type SetElem and all the matrix space parent object types belong to the abstract type Set.","category":"section"},{"location":"matrix/#Matrix-functionality","page":"Matrices","title":"Matrix functionality","text":"Singular.jl matrices implement standard operations one would expect. These include:\n\nOperations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.\n\nThe following parts of the Matrix interface from AbstractAlgebra are also implemented:\n\nconstruction: identity_matrix, identity_matrix\narithmetic operations: +, -, *\ncomparison: ==\nmanipulation: number_of_rows, number_of_columns, getindex, setindex!, transpose, iszero\n\nExamples\n\njulia> R, (x, y, u, v, w) = Singular.polynomial_ring(Singular.QQ, [\"x\", \"y\", \"u\", \"v\", \"w\"])\n(Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C), spoly{n_Q}[x, y, u, v, w])\n\njulia> identity_matrix(R, 4)\n[1, 0, 0, 0\n0, 1, 0, 0\n0, 0, 1, 0\n0, 0, 0, 1]\n\njulia> zero_matrix(R, 3, 8)\n[0, 0, 0, 0, 0, 0, 0, 0\n0, 0, 0, 0, 0, 0, 0, 0\n0, 0, 0, 0, 0, 0, 0, 0]\n\njulia> M = identity_matrix(R, 4)\n[1, 0, 0, 0\n0, 1, 0, 0\n0, 0, 1, 0\n0, 0, 0, 1]\n\njulia> number_of_rows(M)\n4\n\njulia> number_of_columns(M)\n4\n\njulia> iszero(M)\nfalse\n\njulia> M[3, 4] = x*y + 5*u*w\nx*y + 5*u*w\n\njulia> N = transpose(M)\n[1, 0, 0, 0\n0, 1, 0, 0\n0, 0, 1, 0\n0, 0, x*y + 5*u*w, 1]\n\njulia> N[4, 3]\nx*y + 5*u*w","category":"section"},{"location":"nemo/#Nemo-rings-and-fields","page":"Nemo rings and fields","title":"Nemo rings and fields","text":"Any type that satisfies AbstractAlgebra.jl Ring or Field interface, such as all Nemo ring and field types, can be used as coefficient rings in Singular.jl. These are implemented via the Singular n_RingElem{T} and n_FieldElem{T} types, parameterised by the given Nemo/AbstractAlgebra element type.\n\nThe associated parent object of type N_Ring{T} or N_Field{T} can be constructed by a call to the CoefficientRing constructor. In practice, however, this constructor is only used internally, and Nemo rings and fields work directly as Singular coefficient rings, and all the coercions and ad hoc functions that one would expect to be present are implemented.\n\nThe Singular.jl n_RingElem (resp. n_FieldElem) types belong directly to the abstract type RingElem (resp. FieldElem) and their parent object types belong to the abstract type Ring (resp. Field). We also have the following type definitions for compatibility with previous version of Singular.jl.\n\nconst N_unknown{T} = Union{N_Ring{T}, N_Field{T}}\nconst n_unknown{T} = Union{n_RingElem{T}, n_FieldElem{T}}\n\nAll of the Singular polynomial arithmetic should work for any Nemo ring and everything, including ideals, modules, standard basis, syzygies, resolutions, etc., should work with any Nemo field.\n\nSpecialised efficient wrappers exist for certain Nemo coefficient ring types.","category":"section"},{"location":"nemo/#Nemo-ring-functionality","page":"Nemo rings and fields","title":"Nemo ring functionality","text":"Singular.jl foreign ring types provide all of the AbstractAlgebra defined ring and some field functionality.\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/ring\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/field\n\nParts of the Euclidean Ring interface may also be implemented, though Singular will report an error if division is meaningless (even after cancelling zero divisors).\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface\n\nBelow, we describe the functionality that is specific to the Singular foreign ring interface that is not already listed at the given links.","category":"section"},{"location":"nemo/#Constructors","page":"Nemo rings and fields","title":"Constructors","text":"Given an AbstractAlgebra compatible ring R, e.g. a Nemo ring, we have the following constructor, which returns the associated Singular.jl coefficient ring.\n\nCoefficientRing(R::Ring)\n\nIf there are generators to be coerced from Nemo/AbstractAlgebra into corresponding elements, the Singular.jl coefficient ring can be used to coerce them to a Singular n_RingElem or n_FieldElem element.\n\nExamples\n\nR, x = Nemo.polynomial_ring(ZZ, \"x\")\nS = CoefficientRing(R)\nt = S(x)\n\nNote that it is unlikely that a user directly needs to construct the Singular coefficient ring from a Nemo ring, since the Singular.jl constructors are designed to accept Nemo coefficient rings directly. Singular.jl automatically constructs the required Singular coefficient ring and makes use of it.","category":"section"},{"location":"caller/#Interpreter-Functionality","page":"Interpreter Functionality","title":"Interpreter Functionality","text":"Singular.jl provides limited access to the functionality of the Singular interpreter and its associated standard library procedures. The following features of the Singular language are not supported:\n\nThe singular language allows arbitrary attributes to be attached to each object. These are not supported because Singular.jl works with the raw kernel types ring, poly, ideal, etc. that do not have attributes.\nMaps between polynomial rings cannot be effectively communicated between the Singular language and Singular.jl because the Singular language tracks the preimage ring by name only and the rings in Singular.jl do not have names.\nVery few library procedures work with Nemo rings and fields.","category":"section"},{"location":"caller/#Calling-a-Library-Procedure","page":"Interpreter Functionality","title":"Calling a Library Procedure","text":"In general, if we have a procedure sort in general.lib, then the corresponding function in Singular.jl is called Singular.LibGeneral.sort. The full list of libraries included can be viewed by typing Singular.Lib at the REPL and double pressing the tab key.\n\nOne issue that comes up in calling library procedures is the implicit argument basering that all procedures receive in the Singular language. Singular.jl tries to infer the base ring from the arguments provided to the function. When this fails or is simply not possible, the user can always provide a base ring by passing it in as the first argument to the Singular.jl function. Note that if the first argument to the Singular.jl version of a library procedure is a polynomial or non-commutative ring, then this is automatically assumed to be the base ring. Hence, if a procedure in the Singular language takes a ring as a first argument, you will have to pass that ring as the second argument after specifying the base ring in the first argument.\n\nExamples\n\nThis example illustrates passing Singular lists and providing the base ring.\n\njulia> r0, (x, y, z, t) = polynomial_ring(QQ, [\"x\", \"y\", \"z\", \"t\"], ordering=ordering_lp());\n\njulia> Singular.LibGeneral.sort([x, y])\nERROR: `intvec` may be passed in as Vector{Int}. All other vectors (`list` in Singular) must be passed in as Vector{Any} along with an explicit base ring in the first argument\n\njulia> Singular.LibGeneral.sort(r0, Any[x, y])\n2-element Vector{Vector}:\n spoly{n_Q}[y, x]\n [2, 1]\n\nThis example illustrates the base ring inference:\n\njulia> AA, (x, y, z, t) = polynomial_ring(QQ, [\"x\", \"y\", \"z\", \"t\"]);\n\njulia> D = zero_matrix(AA, 4, 4);\n\njulia> D[1,2] = -z; D[1,3] = 2*x; D[2,3] = -2*y;\n\njulia> A, (x, y, z, t) = GAlgebra(AA, 1, D);\n\njulia> Singular.LibNctools.isCentral(x)   # base ring A is inferred from x\n0\n\njulia> Singular.LibCentral.center(A, 3)   # base ring cannot be inferred from the plain Int 3\nSingular ideal over Singular G-algebra (QQ),(x,y,z,t),(dp(4),C) with generators (t, 4*x*y + z^2 - 2*z)","category":"section"},{"location":"caller/#Global-Interpreter-Variables","page":"Interpreter Functionality","title":"Global Interpreter Variables","text":"The function Singular.call_interpreter can be used to execute arbitrary strings inside the Singular interpreter, and the function Singular.lookup_library_symbol fetches results from the interpreter.","category":"section"},{"location":"caller/#Global-Kernel-Variables","page":"Interpreter Functionality","title":"Global Kernel Variables","text":"The global variables degBound and multBound can be used in a local fashion. As with any global variable, their usage should be accompanied with caution.\n\nThe following options are available. The usage of, say, the option infRefTail would be as with_infRefTail(f, flag::Bool) where the same do-block syntax can be used as with the degree bounds.\n\nfastHC, infRedTail, lazy, length, notBuckets, prot, qringNF, redTail, redThrough\n\nExamples\n\njulia> r, (x,y,z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"], ordering=ordering_ds());\n\njulia> i = Ideal(r, [x^7+y^7+z^6,x^6+y^8+z^7,x^7+y^5+z^8,x^2*y^3+y^2*z^3+x^3*z^2,x^3*y^2+y^3*z^2+x^2*z^3]);\n\njulia> degree(std(i))   # default behaviour of no multiplicity bound\n(0, 86)\n\njulia> with_multBound(100) do\n           # run with a multiplicity bound of 100\n           return degree(std(i))\n       end\n(0, 98)\n\njulia> degree(std(i))   # back to default behaviour\n(0, 86)\n\njulia> gens(std(i))\n11-element Vector{spoly{n_Q}}:\n x^3*y^2 + y^3*z^2 + x^2*z^3\n x^2*y^3 + x^3*z^2 + y^2*z^3\n y^5 + x^7 + z^8\n x^6 + z^7 + y^8\n x^4*z^2 - y^4*z^2 - x^2*y*z^3 + x*y^2*z^3\n z^6 + x^7 + y^7\n y^4*z^3 - y^3*z^4 - x^2*z^5 - x^9\n x^3*y*z^4 - x^2*y^2*z^4 + x*y^3*z^4 - y^4*z^4 - x^2*y*z^5 - y^2*z^6 - y^2*z^7 - y^10 - x^7*y*z^2\n x^3*z^5 + y^2*z^6 + x^10 + x^7*y*z^2\n x^2*y*z^5 + y^3*z^5 + x^2*z^6\n x*y^3*z^5 - y^4*z^5 - x^3*z^6 - x^2*y*z^6 + x^2*z^7 - 2*y^2*z^7\n\njulia> gens(with_degBound(5) do; return std(i); end)\n5-element Vector{spoly{n_Q}}:\n x^3*y^2 + y^3*z^2 + x^2*z^3\n x^2*y^3 + x^3*z^2 + y^2*z^3\n y^5 + x^7 + z^8\n x^6 + z^7 + y^8\n z^6 + x^7 + y^7\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> with_prot(true) do; return std(Ideal(R, x^5 - y*x + 1, y^6*x + x^2 + y^3)); end\n[4294967295:2]5s7s11s1214-s15\nproduct criterion:1 chain criterion:1\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^5 - x*y + 1, x*y^6 + y^3 + x^2, x^4*y^3 - y^6 - y^4 - x, y^9 + y^7 + x^3*y^3 + x*y^3 + x*y - 1)","category":"section"},{"location":"caller/#Singular.lookup_library_symbol-Tuple{String, String}","page":"Interpreter Functionality","title":"Singular.lookup_library_symbol","text":"lookup_library_symbol(package::String, name::String)\n\nAttempt to look up a symbol in a particular Singular interpreter package and return its value as a usable Singular.jl object. The package at the top level is called \"Top\", and ring dependent objects are contained in their basering, which is returned as a dictionary.\n\nExamples\n\njulia> Singular.call_interpreter(\"bigint a = 42;\");\n\njulia> a = Singular.lookup_library_symbol(\"Top\", \"a\"); (a, typeof(a))\n(42, BigInt)\n\njulia> Singular.call_interpreter(\"ring r=0,(x,y,z),dp; poly f = (x+y)^2;\");\n\njulia> Singular.lookup_library_symbol(\"Top\", \"r\")\n2-element Vector{Any}:\n Singular polynomial ring (QQ),(x,y,z),(dp(3),C)\n Dict{Symbol, spoly{n_Q}}(:f => x^2 + 2*x*y + y^2)\n\n\n\n\n\n","category":"method"},{"location":"caller/#Singular.with_degBound-Tuple{Any, Integer}","page":"Interpreter Functionality","title":"Singular.with_degBound","text":"with_degBound(f, degb::Integer)\n\nEvaluate and return f() with the Singular global setting degBound = degb. The value of degBound is automatically restored upon return; the effect is only a local one on f(). The value degBound = 0 corresponds to no degree bound in Singular and this is the starting value.\n\n\n\n\n\n","category":"method"},{"location":"caller/#Singular.with_multBound-Tuple{Any, Integer}","page":"Interpreter Functionality","title":"Singular.with_multBound","text":"with_multBound(f, mu::Integer)\n\nEvaluate and return f() with the Singular global setting multBound = mu. The value of multBound is automatically restored upon return; the effect is only a local one on f(). The value multBound = 0 corresponds to no multiplicity bound in Singular and this is the starting value.\n\n\n\n\n\n","category":"method"},{"location":"alghom/#Algebra-Homomorphisms","page":"Algebra Homomorphisms","title":"Algebra Homomorphisms","text":"Singular.jl allows the creation of algebra homomorphisms of Singular polynomial rings over Nemo/Singular coefficient rings.\n\nThe default algebra homomorphism type in Singular.jl is the Singular SAlgHom type.\n\nAdditionally, a special type for the identity homomorphism has been implemented. The type in Singular.jl for the latter is SIdAlgHom.\n\nAll algebra homomorphism types belong directly to the abstract type AbstractAlgebraHomomorphism{T}.","category":"section"},{"location":"alghom/#Algebra-Homomorphism-functionality","page":"Algebra Homomorphisms","title":"Algebra Homomorphism functionality","text":"","category":"section"},{"location":"alghom/#Constructors","page":"Algebra Homomorphisms","title":"Constructors","text":"Given two Singular polynomial rings R and S over the same base ring, the following constructors are available for creating algebra homomorphisms.\n\nExamples\n\njulia> L = FiniteField(3, 2, \"a\")\n(Finite field of characteristic 3 and degree 2, a)\n\njulia> R, (x, y, z, w) = polynomial_ring(L[1], [\"x\", \"y\", \"z\", \"w\"];\n                                    ordering=:negdegrevlex)\n(Singular polynomial ring (9,a),(x,y,z,w),(ds(4),C), spoly{n_GF}[x, y, z, w])\n\njulia> S, (a, b, c) = polynomial_ring(L[1], [\"a\", \"b\", \"c\"];\n                                    ordering=:degrevlex)\n(Singular polynomial ring (9,a),(a@1,b,c),(dp(3),C), spoly{n_GF}[a, b, c])\n\njulia> V = [a, a + b^2, b - c, c + b]\n4-element Vector{spoly{n_GF}}:\n a\n b^2 + a\n b + a^4*c\n b + c\n\njulia> f = AlgebraHomomorphism(R, S, V)\nAlgebra homomorphism\n  from Singular polynomial ring (9,a),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (9,a),(a@1,b,c),(dp(3),C)\nDefining equations: spoly{n_GF}[a, b^2 + a, b + a^4*c, b + c]","category":"section"},{"location":"alghom/#Operating-on-objects","page":"Algebra Homomorphisms","title":"Operating on objects","text":"It is possible to act on polynomials and ideals via algebra homomorphisms.\n\nExamples\n\njulia> R, (x, y, z, w) = polynomial_ring(ZZ, [\"x\", \"y\", \"z\", \"w\"];\n                                    ordering=:negdegrevlex)\n(Singular polynomial ring (ZZ),(x,y,z,w),(ds(4),C), spoly{n_Z}[x, y, z, w])\n\njulia> S, (a, b, c) = polynomial_ring(ZZ, [\"a\", \"b\", \"c\"];\n                                    ordering=:degrevlex)\n(Singular polynomial ring (ZZ),(a,b,c),(dp(3),C), spoly{n_Z}[a, b, c])\n\njulia> V = [a, a + b^2, b - c, c + b]\n4-element Vector{spoly{n_Z}}:\n a\n b^2 + a\n b - c\n b + c\n\njulia> f = AlgebraHomomorphism(R, S, V)\nAlgebra homomorphism\n  from Singular polynomial ring (ZZ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (ZZ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Z}[a, b^2 + a, b - c, b + c]\n\njulia> id  = IdentityAlgebraHomomorphism(S)\nIdentity algebra homomorphism\n  from Singular polynomial ring (ZZ),(a,b,c),(dp(3),C)\n  to Singular polynomial ring (ZZ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Z}[a, b, c]\n\njulia> J = Ideal(R, [x, y^3])\nSingular ideal over Singular polynomial ring (ZZ),(x,y,z,w),(ds(4),C) with generators (x, y^3)\n\njulia> p = x + y^3 + z*w\nx + z*w + y^3\n\njulia> K = f(J)\nSingular ideal over Singular polynomial ring (ZZ),(a,b,c),(dp(3),C) with generators (a, b^6 + 3*a*b^4 + 3*a^2*b^2 + a^3)\n\njulia> q = f(p)\nb^6 + 3*a*b^4 + 3*a^2*b^2 + a^3 + b^2 - c^2 + a","category":"section"},{"location":"alghom/#Composition","page":"Algebra Homomorphisms","title":"Composition","text":"A short command for the composition of f and g is f*g, which is the same as compose(f, g).\n\nExamples\n\njulia> R, (x, y, z, w) = polynomial_ring(QQ, [\"x\", \"y\", \"z\", \"w\"];\n                                    ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C), spoly{n_Q}[x, y, z, w])\n\njulia> S, (a, b, c) = polynomial_ring(QQ, [\"a\", \"b\", \"c\"];\n                                    ordering=:degrevlex)\n(Singular polynomial ring (QQ),(a,b,c),(dp(3),C), spoly{n_Q}[a, b, c])\n\njulia> V = [a, a + b^2, b - c, c + b]\n4-element Vector{spoly{n_Q}}:\n a\n b^2 + a\n b - c\n b + c\n\njulia> W = [x^2, x + y + z, z*y]\n3-element Vector{spoly{n_Q}}:\n x^2\n x + y + z\n y*z\n\njulia> f = AlgebraHomomorphism(R, S, V)\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Q}[a, b^2 + a, b - c, b + c]\n\njulia> g = AlgebraHomomorphism(S, R, W)\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly{n_Q}[x^2, x + y + z, y*z]\n\njulia> idR  = IdentityAlgebraHomomorphism(R)\nIdentity algebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly{n_Q}[x, y, z, w]\n\njulia> h1 = f*g\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly[x^2, 2*x^2 + 2*x*y + y^2 + 2*x*z + 2*y*z + z^2, x + y + z - y*z, x + y + z + y*z]\n\njulia> h2 = idR*f\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Q}[a, b^2 + a, b - c, b + c]\n\njulia> h3 = g*idR\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly{n_Q}[x^2, x + y + z, y*z]\n\njulia> h4 = idR*idR\nIdentity algebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\nDefining equations: spoly{n_Q}[x, y, z, w]","category":"section"},{"location":"alghom/#Preimages","page":"Algebra Homomorphisms","title":"Preimages","text":"Examples\n\njulia> R, (x, y, z, w) = polynomial_ring(QQ, [\"x\", \"y\", \"z\", \"w\"];\n                                    ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C), spoly{n_Q}[x, y, z, w])\n\njulia> S, (a, b, c) = polynomial_ring(QQ, [\"a\", \"b\", \"c\"];\n                                    ordering=:degrevlex)\n(Singular polynomial ring (QQ),(a,b,c),(dp(3),C), spoly{n_Q}[a, b, c])\n\njulia> I = Ideal(S, [a, a + b^2, b - c, c + b])\nSingular ideal over Singular polynomial ring (QQ),(a,b,c),(dp(3),C) with generators (a, b^2 + a, b - c, b + c)\n\njulia> f = AlgebraHomomorphism(R, S, gens(I))\nAlgebra homomorphism\n  from Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C)\n  to Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Q}[a, b^2 + a, b - c, b + c]\n\njulia> idS  = IdentityAlgebraHomomorphism(S)\nIdentity algebra homomorphism\n  from Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\n  to Singular polynomial ring (QQ),(a,b,c),(dp(3),C)\nDefining equations: spoly{n_Q}[a, b, c]\n\njulia> P1 = preimage(f, I)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C) with generators (x, y, z, w)\n\njulia> P2 = preimage(idS, I)\nSingular ideal over Singular polynomial ring (QQ),(a,b,c),(dp(3),C) with generators (a, b^2 + a, b - c, b + c)\n\njulia> K1 = kernel(f)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z,w),(ds(4),C) with generators (4*x - 4*y + z^2 + 2*z*w + w^2)\n\njulia> K2 = kernel(idS)\nSingular ideal over Singular polynomial ring (QQ),(a,b,c),(dp(3),C) with generators (0)","category":"section"},{"location":"alghom/#Singular.AlgebraHomomorphism-Tuple{PolyRing, PolyRing, Vector}","page":"Algebra Homomorphisms","title":"Singular.AlgebraHomomorphism","text":"AlgebraHomomorphism(D::PolyRing, C::PolyRing, V::Vector)\n\nConstructs an algebra homomorphism f D to C, where the i-th variable of D is mapped to the i-th entry of V. D and C must be polynomial rings over the same base ring.\n\n\n\n\n\n","category":"method"},{"location":"alghom/#Singular.IdentityAlgebraHomomorphism-Tuple{PolyRing}","page":"Algebra Homomorphisms","title":"Singular.IdentityAlgebraHomomorphism","text":"IdentityAlgebraHomomorphism(R::PolyRing)\n\nConstructs the canonical identity algebra homomorphism id D to D, where the i-th variable of D is mapped to itself.\n\n\n\n\n\n","category":"method"},{"location":"alghom/#AbstractAlgebra.compose-Tuple{Singular.SAlgHom, Singular.SAlgHom}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.compose","text":"compose(f::AbstractAlgebra.Map(Singular.SAlgHom),\n                     g::AbstractAlgebra.Map(Singular.SAlgHom))\n\nReturn an algebra homomorphism h domain(f) to codomain(g), where h = g(f).\n\n\n\n\n\n","category":"method"},{"location":"alghom/#AbstractAlgebra.preimage-Tuple{Singular.SAlgHom, sideal}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.preimage","text":"preimage(f::AbstractAlgebra.Map(SAlgHom), I::sideal)\n\nReturn the preimage of the ideal I under the algebra homomorphism f.\n\n\n\n\n\n","category":"method"},{"location":"alghom/#AbstractAlgebra.preimage-Tuple{Singular.SIdAlgHom, sideal}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.preimage","text":"preimage(f::AbstractAlgebra.Map(SIdAlgHom), I::sideal)\n\nReturn the preimage of the ideal I under the identity algebra homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"alghom/#AbstractAlgebra.kernel-Tuple{Singular.SIdAlgHom}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.kernel","text":"kernel(f::AbstractAlgebra.Map(SIdAlgHom))\n\nReturn the kernel of the identity algebra homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"alghom/#AbstractAlgebra.kernel-Tuple{Singular.SAlgHom}","page":"Algebra Homomorphisms","title":"AbstractAlgebra.kernel","text":"kernel(f::AbstractAlgebra.Map(SAlgHom))\n\nReturn the kernel of the algebra homomorphism f.\n\n\n\n\n\n","category":"method"},{"location":"vector/#Free-modules-and-vectors","page":"Free modules and vectors","title":"Free modules and vectors","text":"As generators of finitely generated modules in Singular.jl are given as submodule of free modules over a polynomial ring R, Singular.jl supports creation of the free module R^n and vectors of length n in such a module.\n\nThe Singular.jl type for a vector is svector{T}. For the most part, these exist to help interact with the smodule{T} type provided by Singular.\n\nThe types of vectors and associated parent objects are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular svector{T} Singular.FreeMod{T}\n\nThese types are parameterised by the type of elements in the polynomial ring R.\n\nAll free module types belong directly to the abstract type Module{T} and vector types belong directly to ModuleElem{T}.","category":"section"},{"location":"vector/#Free-module-and-vector-functionality","page":"Free modules and vectors","title":"Free module and vector functionality","text":"Singular.jl modules implement standard operations one would expect on vectors and their associated parent modules.\n\nThese include:\n\nOperations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.\nArithmetic operations on vectors: (unary) -, +, -\nScalar multiplication of vectors by polynomials, constants and integers\nComparison operators: ==\n\nBelow, we describe all of the functionality for Singular.jl free modules that is not included in this list of basic operations.","category":"section"},{"location":"vector/#Constructors","page":"Free modules and vectors","title":"Constructors","text":"Given a Singular polynomial ring R and a rank n, the following constructors are available for creating free modules.\n\nFreeModule{T <: AbstractAlgebra.RingElem}(R::PolyRing{T}, n::Int)\n\nConstruct the free module R^n over the polynomial ring R. Elements of the module returned by this function are vectors of length n, with entries in R.\n\nvector{T <: AbstractAlgebra.RingElem}(R::PolyRing{T}, coords::spoly{T}...)\n\nConstruct the vector whose coordinates (which are elements of R) are the given parameters.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> M = FreeModule(R, 3)\nFree module of rank 3 over Singular polynomial ring (QQ),(x,y),(dp(2),C)\n\njulia> v2 = M([x + 1, x*y + 1, y])\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)","category":"section"},{"location":"vector/#Basic-manipulation","page":"Free modules and vectors","title":"Basic manipulation","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> M = FreeModule(R, 5)\nFree module of rank 5 over Singular polynomial ring (QQ),(x,y),(dp(2),C)\n\njulia> v = gens(M)\n5-element Vector{svector{spoly{n_Q}}}:\n gen(1)\n gen(2)\n gen(3)\n gen(4)\n gen(5)\n\njulia> r = rank(M)\n5","category":"section"},{"location":"vector/#Conversions","page":"Free modules and vectors","title":"Conversions","text":"To convert the internal Singular representation of an svector{T} to a Julia array whose entries have type T, we have the following conversion routine.\n\nArray{T <: Nemo.RingElem}(v::svector{spoly{T}})\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> V = Array(v1)\n3-element Vector{spoly{n_Q}}:\n x + 1\n x*y + 1\n y","category":"section"},{"location":"vector/#Jet-of-vectors","page":"Free modules and vectors","title":"Jet of vectors","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v = vector(R, x^5 + 1, 2x^3 + 3y^2, x^2)\nx^5*gen(1)+2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)\n\njulia> w = jet(v, 3)\n2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)","category":"section"},{"location":"vector/#LinearAlgebra.rank-Tuple{FreeMod}","page":"Free modules and vectors","title":"LinearAlgebra.rank","text":"rank(M::FreeMod)\n\nReturn the rank of the given free module.\n\n\n\n\n\n","category":"method"},{"location":"vector/#AbstractAlgebra.gens-Union{Tuple{FreeMod{T}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Free modules and vectors","title":"AbstractAlgebra.gens","text":"gens(I::smodule)\n\nReturn the generators in the internal representation of the module I as an array.\n\n\n\n\n\ngens(I::sideal)\n\nReturn the generators in the internal representation of the ideal I as an array.\n\n\n\n\n\ngens{T <: AbstractAlgebra.RingElem}(M::FreeMod{T})\n\nReturn a Julia array whose entries are the generators of the given free module.\n\n\n\n\n\n","category":"method"},{"location":"vector/#Singular.jet-Union{Tuple{T}, Tuple{svector{spoly{T}}, Int64}} where T<:AbstractAlgebra.RingElem","page":"Free modules and vectors","title":"Singular.jet","text":"jet(x::svector{spoly{T}}, n::Int)\n\nGiven a vector x this function truncates each entry of x up to degree n.\n\n\n\n\n\n","category":"method"},{"location":"modp/#Integers-mod-p","page":"Integers mod p","title":"Integers mod p","text":"Integers mod a prime p are implemented via the Singular n_Zp type for any positive prime modulus less than 2^29.\n\nThe associated field of integers mod p is represented by a parent object which can be constructed by a call to the Fp constructor.\n\nThe types of the parent objects and elements of the associated fields of integers modulo p are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular n_Zp Singular.N_ZpField\n\nAll integer mod p element types belong directly to the abstract type FieldElem and all the parent object types belong to the abstract type Field.","category":"section"},{"location":"modp/#Integer-mod-p-functionality","page":"Integers mod p","title":"Integer mod p functionality","text":"Singular.jl integers modulo p provides the field and residue ring functionality of AbstractAlgebra.\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/field\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/residue\n\nBelow, we describe the functionality that is specific to the Singular integers mod p field and not already listed at the given links.","category":"section"},{"location":"modp/#Constructors","page":"Integers mod p","title":"Constructors","text":"The following constructors are available to create the field of integers modulo a prime p.\n\nFp(p::Int; cached=true)\n\nConstruct the field of integers modulo p. By default, the field is cached, so that all fields of integers modulo p have the same parent object. If this is not the desired behaviour, the cached parameter can be set to false. If p is not a prime or p is not in the range (0 2^29), an exception is raised.\n\nGiven a field R of integers modulo p, we also have the following coercions in addition to the standard ones expected.\n\nR(n::n_Z)\nR(n::ZZRingElem)\n\nCoerce a Singular or Flint integer value into the field.","category":"section"},{"location":"modp/#Basic-manipulation","page":"Integers mod p","title":"Basic manipulation","text":"Examples\n\njulia> R = Fp(23)\nFinite field of characteristic 23\n\njulia> a = R(5)\n5\n\njulia> is_unit(a)\ntrue\n\njulia> c = characteristic(R)\n23","category":"section"},{"location":"modp/#Conversions","page":"Integers mod p","title":"Conversions","text":"Int(n::n_Zp)\n\nLift the integer n modulo p to a Julia Int. The result is always in the range 0 p).\n\nExamples\n\njulia> R = Fp(23)\nFinite field of characteristic 23\n\njulia> a = R(5)\n5\n\njulia> b = Int(a)\n5","category":"section"},{"location":"transExt/#Function-fields","page":"Function fields","title":"Function fields","text":"Function fields are implemented via the Singular n_transExt type for prime fields of any characteristic.\n\nThe associated function field is represented by a parent object which can be constructed by a call to the FunctionField constructor.\n\nThe types of the parent objects and elements of the associated function fields are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular n_transExt Singular.N_FField\n\nAll function field element types belong directly to the abstract type FieldElem and all the parent object types belong to the abstract type Field.","category":"section"},{"location":"transExt/#Function-field-functionality","page":"Function fields","title":"Function field functionality","text":"Singular.jl function fields provide all the functionality for fields described by AbstractAlgebra.jl.\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/field\n\nBelow, we describe the functionality that is specific to Singular function field and not already listed at the given link.","category":"section"},{"location":"transExt/#Constructors","page":"Function fields","title":"Constructors","text":"The following constructors are available to create function fields and their elements.\n\nIn case the user does not want to specify a transcendence basis the following constructor can be used.\n\nGiven a function field F, we also have the following coercions in addition to the standard ones expected.\n\nF(n::ZZRingElem)\n\nCoerce a Flint integer value into the field.\n\nExamples\n\njulia> F1, (a, b, c) = FunctionField(QQ, [\"a\", \"b\", \"c\"])\n(Function field over Rational field with transcendence basis n_transExt{Rationals}[a, b, c], n_transExt{Rationals}[a, b, c])\n\njulia> x1 = a*b + c\na*b + c\n\njulia> F2, (a1, a2, a3) = FunctionField(Fp(5), 3)\n(Function field over Finite field of characteristic 5 with transcendence basis n_transExt{N_ZpField}[a1, a2, a3], n_transExt{N_ZpField}[a1, a2, a3])\n\njulia> x2 = a1^5 + a2*a3^4\na1^5 + a2*a3^4","category":"section"},{"location":"transExt/#Basic-manipulation","page":"Function fields","title":"Basic manipulation","text":"Examples\n\njulia> F1, (a, b, c) = FunctionField(QQ, [\"a\", \"b\", \"c\"])\n(Function field over Rational field with transcendence basis n_transExt{Rationals}[a, b, c], n_transExt{Rationals}[a, b, c])\n\njulia> x = F1(5)*a\n5*a\n\njulia> y = a^2 *b+a*b+b^2\na^2*b + a*b + b^2\n\njulia> is_unit(x)\ntrue\n\njulia> char = characteristic(F1)\n0\n\njulia> d = transcendence_degree(F1)\n3\n\njulia> S, = polynomial_ring(QQ, [\"a\", \"b\", \"c\"])\n(Singular polynomial ring (QQ),(a,b,c),(dp(3),C), spoly{n_Q}[a, b, c])\n\njulia> p = n_transExt_to_spoly(y, parent_ring = S)\na^2*b + a*b + b^2\n\njulia> F2, = FunctionField(Fp(7), 4)\n(Function field over Finite field of characteristic 7 with transcendence basis n_transExt{N_ZpField}[a1, a2, a3, a4], n_transExt{N_ZpField}[a1, a2, a3, a4])\n\njulia> B = transcendence_basis(F2)\n4-element Vector{n_transExt{N_ZpField}}:\n a1\n a2\n a3\n a4","category":"section"},{"location":"transExt/#Singular.FunctionField-Tuple{Singular.Field, AbstractVector{<:Union{Char, AbstractString, Symbol}}}","page":"Function fields","title":"Singular.FunctionField","text":"FunctionField(F::Singular.Field, S::AbstractVector{<:VarName})\n\nReturn a tuple K a consisting of a function field K over the field F with transcendence basis stored in the array S.\n\n\n\n\n\n","category":"method"},{"location":"transExt/#Singular.FunctionField-Tuple{Singular.Field, Int64}","page":"Function fields","title":"Singular.FunctionField","text":"FunctionField(F::Singular.Field, n::Int)\n\nReturn a tuple K a consisting of a function field K over the field F with transcendence degree n and transcendence basis a1  an.\n\n\n\n\n\n","category":"method"},{"location":"transExt/#Base.numerator-Tuple{n_transExt}","page":"Function fields","title":"Base.numerator","text":"numerator(x::n_transExt)\n\nReturn the numerator of x.\n\n\n\n\n\n","category":"method"},{"location":"transExt/#Base.denominator-Tuple{n_transExt}","page":"Function fields","title":"Base.denominator","text":"denominator(x::n_transExt)\n\nReturn the denominator of x.\n\n\n\n\n\n","category":"method"},{"location":"transExt/#Singular.transcendence_degree-Tuple{N_FField}","page":"Function fields","title":"Singular.transcendence_degree","text":"transcendence_degree(F::N_FField)\n\nReturn the transcendence degree of the given function field.\n\n\n\n\n\n","category":"method"},{"location":"transExt/#Singular.transcendence_basis-Tuple{N_FField}","page":"Function fields","title":"Singular.transcendence_basis","text":"basis(F::N_FField)\n\nReturn the transcendence basis of the given function field.\n\n\n\n\n\n","category":"method"},{"location":"transExt/#Singular.n_transExt_to_spoly-Tuple{n_transExt}","page":"Function fields","title":"Singular.n_transExt_to_spoly","text":"n_transExt_to_spoly(x::n_transExt; parent::PolyRing)\n\nReturn the numerator of x as a polynomial in a polynomial ring with at least as many variables as the transcendence degree of parent(x). If a ring parent is given to the function, it will be the parent ring of the output.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Ideals","page":"Ideals","title":"Ideals","text":"Singular.jl allows the creation of ideals over a Singular polynomial ring. These are internally stored as a list of (polynomial) generators. This list of generators can also have the property of being a Groebner basis.\n\nThe default ideal type in Singular.jl is the Singular sideal type.\n\nIdeals objects have a parent object which represents the set of ideals they belong to, the data for which is given by the polynomial ring their generators belong to.\n\nThe types of ideals and associated parent objects are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular sideal{T} Singular.IdealSet{T}\n\nThese types are parameterised by the type of elements of the polynomial ring over which the ideals are defined.\n\nAll ideal types belong directly to the abstract type Module{T} and all the ideal set parent object types belong to the abstract type Set.","category":"section"},{"location":"ideal/#Ideal-functionality","page":"Ideals","title":"Ideal functionality","text":"Singular.jl ideals implement standard operations one would expect on modules. These include:\n\nOperations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.\nAddition\n\nAlso implements is the following operations one expects for ideals:\n\nMultiplication\nPowering\n\nBelow, we describe all of the functionality for Singular.jl ideals that is not included in this list of basic operations.","category":"section"},{"location":"ideal/#Constructors","page":"Ideals","title":"Constructors","text":"Given a Singular polynomial ring R, the following constructors are available for creating ideals.\n\nIdeal(R::PolyRing{T}, ids::spoly{T}...) where T <: Nemo.RingElem\nIdeal(R::PolyRing{T}, ids::Vector{spoly{T}}) where T <: Nemo.RingElem\n\nConstruct the ideal over the polynomial ring R whose (polynomial) generators are given by the given parameter list or array of polynomials, respectively. The list may be empty, resulting in the zero ideal.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])\n\njulia> I1 = Ideal(R, x*y + 1, x^2)\nSingular ideal over Singular polynomial ring (ZZ),(x,y),(dp(2),C) with generators (x*y + 1, x^2)\n\njulia> I2 = Ideal(R, [x*y + 1, x^2])\nSingular ideal over Singular polynomial ring (ZZ),(x,y),(dp(2),C) with generators (x*y + 1, x^2)","category":"section"},{"location":"ideal/#Basic-manipulation","page":"Ideals","title":"Basic manipulation","text":"Singular.jl overloads the setindex! and getindex functions so that one can access the generators of an ideal using array notation.\n\nI[n::Int]\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(ZZ, [\"x\", \"y\"])\n(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (ZZ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> n = number_of_generators(I)\n2\n\njulia> p = I[1]\nx^2 + 1\n\njulia> I[1] = 2x + y^2\ny^2 + 2*x\n\njulia> is_constant(I) == false\ntrue\n\njulia> is_var_generated(I) == false\ntrue\n\njulia> is_zerodim(I) == false\nERROR: Not a Groebner basis\n\njulia> S, (u, v) = polynomial_ring(QQ, [\"u\", \"v\"])\n(Singular polynomial ring (QQ),(u,v),(dp(2),C), spoly{n_Q}[u, v])\n\njulia> J = Ideal(S, u^2 + 1, u*v)\nSingular ideal over Singular polynomial ring (QQ),(u,v),(dp(2),C) with generators (u^2 + 1, u*v)\n\njulia> dimension(std(J)) == 0\ntrue","category":"section"},{"location":"ideal/#Containment","page":"Ideals","title":"Containment","text":"","category":"section"},{"location":"ideal/#Comparison","page":"Ideals","title":"Comparison","text":"Checking whether two ideals are algebraically equal is very expensive, as it usually requires computing Groebner bases. Therefore we do not overload the == operator for ideals. Instead we have the following two functions.\n\nExamples\n\njulia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + x*y + 1, x^2 - x*y + 1)\n\njulia> isequal(I, J) == false\ntrue\n\njulia> equal(I, J) == true\ntrue","category":"section"},{"location":"ideal/#Intersection","page":"Ideals","title":"Intersection","text":"","category":"section"},{"location":"ideal/#Quotient","page":"Ideals","title":"Quotient","text":"","category":"section"},{"location":"ideal/#Leading-terms","page":"Ideals","title":"Leading terms","text":"","category":"section"},{"location":"ideal/#Homogeneous-ideals","page":"Ideals","title":"Homogeneous ideals","text":"","category":"section"},{"location":"ideal/#Saturation","page":"Ideals","title":"Saturation","text":"","category":"section"},{"location":"ideal/#Standard-basis","page":"Ideals","title":"Standard basis","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + x*y + 1, 2y^2 + 3)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + x*y + 1, 2*y^2 + 3)\n\njulia> J = Ideal(R, 2*y^2 + 3, x^2 + x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 3, x^2 + x*y + 1)\n\njulia> A = std(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 3, x^2 + x*y + 1)\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, (x*y + 1)*(2x^2*y^2 + x*y - 2) + 2x*y^2 + x, 2x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*x^3*y^3 + 3*x^2*y^2 + 2*x*y^2 - x*y + x - 2, 2*x*y + 1)\n\njulia> J = Ideal(R, x)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x)\n\njulia> B = satstd(I, J)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x - y - 1, 2*y^2 + 2*y + 1)\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"], ordering = :lex)\n(Singular polynomial ring (QQ),(x,y,z),(lp(3),C), spoly{n_Q}[x, y, z])\n\njulia> I = Ideal(R, y^3+x^2, x^2*y+x^2, x^3-x^2, z^4-x^2-y)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(lp(3),C) with generators (x^2 + y^3, x^2*y + x^2, x^3 - x^2, -x^2 - y + z^4)\n\njulia> J = fglm(I, :degrevlex)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(lp(3),C) with generators (z^12, y*z^4 - z^8, y^2 + y - z^8 - z^4, x*y - x*z^4 - y + z^4, x^2 + y - z^4)","category":"section"},{"location":"ideal/#Reduction","page":"Ideals","title":"Reduction","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> f = x^2*y + 2y + 1\nx^2*y + 2*y + 1\n\njulia> g = y^2 + 1\ny^2 + 1\n\njulia> I = Ideal(R, (x^2 + 1)*f + (x + y)*g + x + 1, (2y^2 + x)*f + y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^4*y + 3*x^2*y + x*y^2 + y^3 + x^2 + 2*x + 3*y + 2, 2*x^2*y^3 + x^3*y + 4*y^3 + 2*x*y + 2*y^2 + x + y)\n\njulia> J = std(Ideal(R, f, g))\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (y^2 + 1, x^2 - y + 2)\n\njulia> V = reduce(I, J)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x + 1, y)\n\njulia> h1 = (x^2 + 1)*f + (x + y)*g + x + 1\nx^4*y + 3*x^2*y + x*y^2 + y^3 + x^2 + 2*x + 3*y + 2\n\njulia> h2 = reduce(h1, J)\nx + 1","category":"section"},{"location":"ideal/#Elimination","page":"Ideals","title":"Elimination","text":"","category":"section"},{"location":"ideal/#Syzygies","page":"Ideals","title":"Syzygies","text":"","category":"section"},{"location":"ideal/#Free-resolutions","page":"Ideals","title":"Free resolutions","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2*y + 2*y + 1, y^2 + 1)\n\njulia> F1 = fres(std(I), 0)\nSingular resolution: R^1 <- R^2 <- R^1\n\njulia> F2 = sres(std(I), 2)\nSingular resolution: R^1 <- R^2 <- R^1","category":"section"},{"location":"ideal/#Differential-operations","page":"Ideals","title":"Differential operations","text":"","category":"section"},{"location":"ideal/#Operations-on-zero-dimensional-ideals","page":"Ideals","title":"Operations on zero-dimensional ideals","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]; ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y),(ds(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, 3*x^2 + y^3, x*y^2)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (3*x^2 + y^3, x*y^2)\n\njulia> I = std(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (3*x^2 + y^3, x*y^2, y^5)\n\njulia> n = vdim(I)\n7\n\njulia> J = kbase(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (y^4, y^3, y^2, x*y, y, x, 1)\n\njulia> f = highcorner(I)\ny^4","category":"section"},{"location":"ideal/#Operations-over-local-rings","page":"Ideals","title":"Operations over local rings","text":"If the base ring R is a local ring, a minimal generating set can be computed using the following function\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]; ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y),(ds(2),C), spoly{n_Q}[x, y])\n\njulia> has_local_ordering(R) == true\ntrue\n\njulia> I = Ideal(R, y, x^2, (1 + y^3) * (x^2 - y))\nSingular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (y, x^2, -y + x^2 - y^4 + x^2*y^3)\n\njulia> min = minimal_generating_set(I)\n2-element Vector{spoly{n_Q}}:\n x^2\n y","category":"section"},{"location":"ideal/#Independent-sets-of-monomial-ideals","page":"Ideals","title":"Independent sets of monomial ideals","text":"Let I be an ideal of Kx_1  x_n An independent set is a subset u subseteq x_1  x_n such that I cap Ku= 0 In case u cannot be enlarged, it is called non-extendable independent set. If in addition u = dim(Kx_1  x_nI) u is called maximal independent set. Using Singular.jl one can compute non-extendable, resp. maximal independent sets for monomial ideals. If an arbitrary ideal I is passed to the function, the computation is performed on the leading ideal of I.\n\njulia> R, (x, y, u, v, w) = polynomial_ring(QQ, [\"x\", \"y\", \"u\", \"v\", \"w\"])\n(Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C), spoly{n_Q}[x, y, u, v, w])\n\njulia> has_local_ordering(R) == true\nfalse\n\njulia> I = Ideal(R, x*y*w, y*v*w, u*y*w, x*v)\nSingular ideal over Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C) with generators (x*y*w, y*v*w, y*u*w, x*v)\n\njulia> I = std(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C) with generators (x*v, y*v*w, y*u*w, x*y*w)\n\njulia> L1 = independent_sets(I)\n5-element Vector{Vector{spoly{n_Q}}}:\n [x, y, u]\n [y, u, v]\n [x, u, w]\n [u, v, w]\n [y, w]\n\njulia> L2 = maximal_independent_set(I)\n3-element Vector{spoly{n_Q}}:\n x\n y\n u\n\njulia> L3 = maximal_independent_set(I, all = true)\n4-element Vector{Vector{spoly{n_Q}}}:\n [x, y, u]\n [y, u, v]\n [x, u, w]\n [u, v, w]","category":"section"},{"location":"ideal/#AbstractAlgebra.number_of_generators-Tuple{sideal}","page":"Ideals","title":"AbstractAlgebra.number_of_generators","text":"number_of_generators(I::sideal)\n\nReturn the number of generators in the internal representation of the ideal I.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#AbstractAlgebra.gens-Tuple{sideal}","page":"Ideals","title":"AbstractAlgebra.gens","text":"gens(I::smodule)\n\nReturn the generators in the internal representation of the module I as an array.\n\n\n\n\n\ngens(I::sideal)\n\nReturn the generators in the internal representation of the ideal I as an array.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Base.iszero-Tuple{sideal}","page":"Ideals","title":"Base.iszero","text":"iszero(I::sideal)\n\nReturn true if the given ideal is algebraically the zero ideal.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.is_zerodim-Tuple{sideal}","page":"Ideals","title":"Singular.is_zerodim","text":"is_zerodim(I::sideal)\n\nReturn true if the given ideal is zero dimensional, i.e. the Krull dimension of RI is zero, where R is the polynomial ring over which I is an ideal.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.dimension-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.dimension","text":"dimension(I::sideal{spoly{T}}) where T <: Nemo.RingElem\n\nGiven an ideal I this function computes the Krull dimension of the ring RI, where R is the polynomial ring over which I is an ideal. The ideal must be over a polynomial ring and a Groebner basis.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#AbstractAlgebra.is_constant-Tuple{sideal}","page":"Ideals","title":"AbstractAlgebra.is_constant","text":"is_constant(I::sideal)\n\nReturn true if the given ideal is a constant ideal, i.e. generated by constants in the polynomial ring over which it is an ideal.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.is_var_generated-Tuple{sideal}","page":"Ideals","title":"Singular.is_var_generated","text":"is_var_generated(I::sideal)\n\nReturn true if each generator in the representation of the ideal I is a generator of the polynomial ring, i.e. a variable.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#LinearAlgebra.normalize!-Tuple{sideal}","page":"Ideals","title":"LinearAlgebra.normalize!","text":"normalize!(I::sideal)\n\nNormalize the polynomial generators of the ideal I in-place. This means to reduce their coefficients to lowest terms. In most cases this does nothing, but if the coefficient ring were the rational numbers for example, the coefficients of the polynomials would be reduced to lowest terms.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.interreduce-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T<:AbstractAlgebra.RingElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.interreduce","text":"interreduce(I::sideal{S}) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}\n\nInterreduce the elements of I such that no leading term is divisible by another leading term. This returns a new ideal and does not modify the input ideal.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Base.contains-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Base.contains","text":"contains(I::sideal{S}, J::sideal{S}) where S\n\nReturn true if the ideal I contains the ideal J. This will be expensive if I is not a Groebner ideal, since its standard basis must be computed.\n\nExamples\n\njulia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> J = Ideal(R, x^2 + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1)\n\njulia> contains(I, J) == true\ntrue\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Base.isequal-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Base.isequal","text":"isequal(I1::sideal{S}, I2::sideal{S}) where S <: SPolyUnion\n\nReturn true if the given ideals have the same generators in the same order. Note that two algebraically equal ideals with different generators will return false.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.equal-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Singular.equal","text":"equal(I1::sideal{S}, I2::sideal{S}) where S <: SPolyUnion\n\nReturn true if the two ideals are contained in each other, i.e. are the same ideal mathematically. This function should be called only as a last resort; it is exceptionally expensive to test equality of ideals! Do not define == as an alias for this function!\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.intersection-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, sideal{S}}} where {T<:AbstractAlgebra.RingElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.intersection","text":"intersection(I::sideal{S}, J::sideal{S}) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}\n\nReturn the intersection of the two given ideals.\n\nExamples\n\njulia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + x*y + 1, x^2 - x*y + 1)\n\njulia> V = intersection(I, J)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (y, x^2 - x*y + 1)\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.quotient-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:spoly","page":"Ideals","title":"Singular.quotient","text":"quotient(I::sideal{S}, J::sideal{S}) where S <: spoly\n\nReturn the quotient of the two given ideals. Recall that the ideal quotient (IJ) over a polynomial ring R is defined by r in R  rJ subseteq I.\n\nExamples\n\njulia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> J = Ideal(R, x + y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x + y)\n\njulia> V = quotient(I, J)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (y, x^2 + 1)\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.quotient-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:spluralg","page":"Ideals","title":"Singular.quotient","text":"quotient(I::sideal{S}, J::sideal{S}) where S <: spluralg\n\nReturn the quotient of the two given ideals, where J must be two-sided.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.lead-Union{Tuple{sideal{S}}, Tuple{S}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Singular.lead","text":"lead(I::sideal{S}) where S <: SPolyUnion\n\nReturn the ideal generated by the leading terms of the polynomials generating I.\n\nExamples\n\njulia> R, (x , y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)\n\njulia> V = lead(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2, x*y)\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.is_homogeneous-Tuple{sideal}","page":"Ideals","title":"Singular.is_homogeneous","text":"is_homogeneous(I::sideal)\n\nReturn true if each stored generator of I is homogeneous, otherwise false. If base_ring(I) has a weighted monomial ordering, the test is conducted with respect to the corresponding weights.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.homogenize-Union{Tuple{S}, Tuple{sideal{S}, S}} where S<:spoly","page":"Ideals","title":"Singular.homogenize","text":"homogenize(I::sideal{S}, v::S) where S <: spoly\n\nMultiply each monomial in the generators of I by a suitable power of the variable v and return the corresponding homogeneous ideal. The variable v must have weight 1.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.saturation-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.saturation","text":"saturation(I::sideal{T}, J::sideal{T}) where T <: Nemo.RingElem\n\nReturn the saturation of the ideal I with respect to J, i.e. returns the quotient ideal (IJ^infty) and the number of iterations.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, (x^2 + x*y + 1)*(2y^2+1)^3, (2y^2 + 3)*(2y^2+1)^2)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (8*x^2*y^6 + 8*x*y^7 + 12*x^2*y^4 + 12*x*y^5 + 8*y^6 + 6*x^2*y^2 + 6*x*y^3 + 12*y^4 + x^2 + x*y + 6*y^2 + 1, 8*y^6 + 20*y^4 + 14*y^2 + 3)\n\njulia> J = Ideal(R, 2y^2 + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 1)\n\njulia> S = saturation(I, J)\n(Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 3, x^2 + x*y + 1), 2)\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.std-Union{Tuple{sideal{S}}, Tuple{S}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Singular.std","text":"std(I::sideal{S}; complete_reduction::Bool=false) where S <: SPolyUnion\n\nCompute a Groebner basis for the ideal I. Note that without complete_reduction set to true, the generators of the Groebner basis only have unique leading terms (up to permutation and multiplication by constants). If complete_reduction is set to true (and the ordering is a global ordering) then the Groebner basis is unique.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.fglm-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Symbol}} where T<:AbstractAlgebra.RingElem","page":"Ideals","title":"Singular.fglm","text":"fglm(I::sideal{spoly{T}}, ordering::Symbol) where T <: Nemo.RingElem\n\nCompute a Groebner basis for the zero - dimensional ideal I in the ring R using the FGLM algorithm. All involved orderings have to be global.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.satstd-Union{Tuple{T}, Tuple{sideal{spoly{T}}, sideal{spoly{T}}}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.satstd","text":"satstd(I::sideal{spoly{T}}, J::sideal{spoly{T}} = Ideal(base_ring(I), gens(base_ring(I)))) where T <: Nemo.RingElem\n\nGiven an ideal J generated by variables, computes a standard basis of saturation(I, J). This is accomplished by dividing polynomials that occur throughout the std computation by variables occurring in J, where possible. Thus the result can be obtained faster than by first computing the saturation and then the standard basis.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.lift_std-Union{Tuple{sideal{S}}, Tuple{S}} where S<:spoly","page":"Ideals","title":"Singular.lift_std","text":"lift_std(M::sideal{S}; complete_reduction::Bool = false) where S <: spoly\n\nComputes the Groebner base G of M and the transformation matrix T such that (Matrix(G) = Matrix(M) * T)\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.lift_std_syz-Union{Tuple{sideal{S}}, Tuple{S}} where S<:spoly","page":"Ideals","title":"Singular.lift_std_syz","text":"lift_std_syz(M::sideal{S}; complete_reduction::Bool = false) where S <: spoly\n\nComputes the Groebner base G of I, the transformation matrix T and the syzygies of M. Returns G,T,S (Matrix(G) = Matrix(I) * T, 0=Matrix(M)*Matrix(S))\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Base.reduce-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Base.reduce","text":"reduce(I::sideal{S}, G::sideal{S}) where S <: SPolyUnion\n\nReturn an ideal whose generators are the generators of I reduced by the ideal G. The ideal G need not be a Groebner basis. The returned ideal will have the same number of generators as I, even if they are zero. For PLURAL rings (S <: spluralg, GAlgebra, WeylAlgebra), the reduction is only a left reduction, and hence cannot be used to test containment in a two-sided ideal. For LETTERPLACE rings (S <: slpalg, FreeAlgebra), the reduction is two-sided as only two-sided ideals can be constructed here.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Base.reduce-Union{Tuple{S}, Tuple{S, sideal{S}}} where S<:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T<:AbstractAlgebra.RingElem)","page":"Ideals","title":"Base.reduce","text":"reduce(p::S, G::sideal{S}) where S <: SPolyUnion\n\nReturn the polynomial which is p reduced by the polynomials generating G. The ideal G need not be a Groebner basis. For PLURAL rings (S <: spluralg, GAlgebra, WeylAlgebra), the reduction is only a left reduction, and hence cannot be used to test membership in a two-sided ideal. For LETTERPLACE rings (S <: slpalg, FreeAlgebra), the reduction is the full two-sided reduction as only two-sided ideals can be constructed here.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.eliminate-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, Vararg{S}}} where {T<:AbstractAlgebra.RingElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.eliminate","text":"eliminate(I::sideal{S}, polys::S...) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven a list of polynomials which are variables, construct the ideal corresponding geometrically to the projection of the variety given by the ideal I where those variables have been eliminated.\n\nExamples\n\njulia> R, (x, y, t) = polynomial_ring(QQ, [\"x\", \"y\", \"t\"])\n(Singular polynomial ring (QQ),(x,y,t),(dp(3),C), spoly{n_Q}[x, y, t])\n\njulia> I = Ideal(R, x - t^2, y - t^3)\nSingular ideal over Singular polynomial ring (QQ),(x,y,t),(dp(3),C) with generators (-t^2 + x, -t^3 + y)\n\njulia> J = eliminate(I, t)\nSingular ideal over Singular polynomial ring (QQ),(x,y,t),(dp(3),C) with generators (x^3 - y^2)\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.syz-Tuple{sideal}","page":"Ideals","title":"Singular.syz","text":"syz(I::sideal)\n\nCompute the module of syzygies of the ideal.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2*y + 2*y + 1, y^2 + 1)\n\njulia> F = syz(I)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\nx^2*y*gen(2)-y^2*gen(1)+2*y*gen(2)+gen(2)-gen(1)\n\njulia> M = Singular.Matrix(I)\n[x^2*y + 2*y + 1, y^2 + 1]\n\njulia> N = Singular.Matrix(F)\n[-y^2 - 1\nx^2*y + 2*y + 1]\n\njulia> iszero(M*N)  # check they are actually syzygies\ntrue\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.fres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64, String}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.fres","text":"fres(id::sideal{spoly{T}}, max_length::Int, method::String=\"complete\") where T <: Nemo.FieldElem\n\nCompute a free resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The possible methods are \"complete\", \"frame\", \"extended frame\" and \"single module\". The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal/module. The max_length can be set to 0 if the full free resolution is required.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.sres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.sres","text":"sres(id::sideal{spoly{T}}, max_length::Int) where T <: Nemo.FieldElem\n\nCompute a (free) Schreyer resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal. The max_length can be set to 0 if the full free resolution is required.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.jet-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, Int64}} where {T<:AbstractAlgebra.RingElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.jet","text":"jet(I::sideal{S}, n::Int) where {T <: Nemo.RingElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven an ideal I this function truncates the generators of I up to degree n.\n\nExamples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])\n\njulia> I = Ideal(R, x^5 - y^2, y^3 - x^6 + z^3)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(dp(3),C) with generators (x^5 - y^2, -x^6 + y^3 + z^3)\n\njulia> J1 = jet(I, 3)\nSingular ideal over Singular polynomial ring (QQ),(x,y,z),(dp(3),C) with generators (-y^2, y^3 + z^3)\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.vdim-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T<:AbstractAlgebra.FieldElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.vdim","text":"vdim(I::sideal{S}) where {T <: Nemo.FieldElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven a zero-dimensional ideal I this function computes the dimension of the vector space base_ring(I)/I, where base_ring(I) must be a polynomial ring over a field, and I must be a Groebner basis. The return is -1 if !is_zerodim(I).\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.kbase-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T<:AbstractAlgebra.FieldElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.kbase","text":"kbase(I::sideal{S}) where {T <: Nemo.FieldElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven a zero-dimensional ideal I this function computes a vector space basis of the vector space base_ring(I)/I, where base_ring(I) must be a polynomial ring over a field, and I must be a Groebner basis. The array of vector space basis elements is returned as a Singular ideal, and this array consists of one zero polynomial if !is_zerodim(I).\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.highcorner-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T<:AbstractAlgebra.FieldElem, S<:Union{spluralg{T}, spoly{T}}}","page":"Ideals","title":"Singular.highcorner","text":"highcorner(I::sideal{S}) where {T <: Nemo.FieldElem, S <: Union{spoly{T}, spluralg{T}}}\n\nGiven a zero-dimensional ideal I this function computes its highest corner, which is a polynomial. The ideal must be over a polynomial ring over a field, and a Groebner basis. The return is the zero polynomial if !is_zerodim(I).\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.minimal_generating_set-Union{Tuple{sideal{S}}, Tuple{S}} where S<:spoly","page":"Ideals","title":"Singular.minimal_generating_set","text":"minimal_generating_set(I::sideal{S}) where S <: spoly\n\nGiven an ideal I in ring R with local ordering, this returns an array containing the minimal generators of I.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.independent_sets-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.independent_sets","text":"independent_sets(I::sideal{spoly{T}}) where T <: Nemo.FieldElem\n\nReturn all non-extendable independent sets of lead(I). I has to be given by a Groebner basis.\n\n\n\n\n\n","category":"method"},{"location":"ideal/#Singular.maximal_independent_set-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T<:AbstractAlgebra.FieldElem","page":"Ideals","title":"Singular.maximal_independent_set","text":"maximal_independent_set(I::sideal{spoly{T}}; all::Bool = false) where T <: Nemo.FieldElem\n\nReturns, by default, an array containing a maximal independent set of lead(I). I has to be given by a Groebner basis. If the additional parameter \"all\" is set to true, an array containing all maximal independent sets of lead(I) is returned.\n\n\n\n\n\n","category":"method"},{"location":"GF/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"Finite fields are implemented via the Singular n_GF type for any characteristic and degree contained in the Singular Conway tables.\n\nThe associated finite field is represented by a parent object which can be constructed by a call to the FiniteField constructor.\n\nThe types of the parent objects and elements of the associated finite fields are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular n_GF Singular.N_GField\n\nAll finite field element types belong directly to the abstract type FieldElem and all the parent object types belong to the abstract type Field.","category":"section"},{"location":"GF/#Finite-field-functionality","page":"Finite fields","title":"Finite field functionality","text":"Singular.jl finite fields implement the Field interface of AbstractAlgebra.jl.\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/fields.html\n\nBelow, we describe the functionality that is specific to Singular finite field and not already listed at the given link.","category":"section"},{"location":"GF/#Constructors","page":"Finite fields","title":"Constructors","text":"The following constructors are available to create finite fields and their elements.\n\nGiven a finite field R, we also have the following coercions in addition to the standard ones expected.\n\nR(n::ZZRingElem)\n\nCoerce a Flint integer value into the field.","category":"section"},{"location":"GF/#Basic-manipulation","page":"Finite fields","title":"Basic manipulation","text":"Examples\n\njulia> R,w = FiniteField(7, 2, \"w\")\n(Finite field of characteristic 7 and degree 2, w)\n\njulia> w^48 == 1\ntrue\n\njulia> a = R(5)\nw^40\n\njulia> is_unit(a)\ntrue\n\njulia> c = characteristic(R)\n7\n\njulia> d = degree(R)\n2","category":"section"},{"location":"GF/#Singular.FiniteField-Tuple{Int64, Int64, Union{Char, AbstractString, Symbol}}","page":"Finite fields","title":"Singular.FiniteField","text":"FiniteField(p::Int, n::Int, S::VarName; cached=true)\n\nReturn a tuple K, a consisting of a finite field K of characteristic p and degree n, and its generator a. The string used to print the generator is given by S. If the finite field is not listed in the Conway tables included in Singular, an error will be raised. By default, finite fields are cached globally, so that there is only one finite field in the system with given characteristic, degree and string. If this is not the desired behaviour, one can pass false for the optional cached parameter.\n\n\n\n\n\n","category":"method"},{"location":"GF/#AbstractAlgebra.degree-Tuple{N_GField}","page":"Finite fields","title":"AbstractAlgebra.degree","text":"degree(R::N_GField)\n\nReturn the degree of the field as an extension of mathbbF_p.\n\n\n\n\n\n","category":"method"},{"location":"integer/#Integers","page":"Integers","title":"Integers","text":"The default integer type in Singular.jl is the Singular n_Z integer type.\n\nThe associated ring of integers is represented by the constant parent object which can be constructed by a call to Singular.Integers().\n\nFor convenience we define\n\nZZ = Singular.Integers()\n\nso that integers can be constructed using ZZ. Note that this is the name of a specific parent object, not the name of its type.\n\nThe types of the integer ring parent objects and elements of the associated rings of integers are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular n_Z Singular.Integers\n\nAll integer element types belong directly to the abstract type RingElem and all the integer ring parent object types belong to the abstract type Ring.","category":"section"},{"location":"integer/#Integer-functionality","page":"Integers","title":"Integer functionality","text":"Singular.jl provides all the ring and possibly some parts of the Euclidean ring functionality of AbstractAlgebra.jl.\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/ring\n\nhttps://nemocas.github.io/AbstractAlgebra.jl/latest/euclidean_interface\n\nBelow, we describe the functionality that is specific to the Singular integer ring.","category":"section"},{"location":"integer/#Constructors","page":"Integers","title":"Constructors","text":"ZZ(n::Integer)\n\nCoerce a Julia integer value into the integer ring.","category":"section"},{"location":"integer/#Basic-manipulation","page":"Integers","title":"Basic manipulation","text":"Examples\n\njulia> a = ZZ(-12)\n-12\n\njulia> is_unit(a)\nfalse\n\njulia> n = numerator(a)\n-12\n\njulia> d = denominator(a)\n1\n\njulia> c = abs(a)\n12","category":"section"},{"location":"integer/#Euclidean-division","page":"Integers","title":"Euclidean division","text":"Singular.jl provides a number of Euclidean division operations. Recall that for a dividend a and divisor b, we can write a = bq + r with 0 leq r  b. We call q the quotient and r the remainder.\n\nIn the following table we list the division functions and their rounding behaviour. We also give the return value of the function, with q representing return of the quotient and r representing return of the remainder.\n\nFunction Return Rounding\ndivrem(a::n_Z, b::n_Z) q, r towards zero\nrem(a::n_Z, b::n_Z) r towards zero\nmod(a::n_Z, b::n_Z) r down\n\nExamples\n\njulia> a = ZZ(-12)\n-12\n\njulia> b = ZZ(5)\n5\n\njulia> q, r = divrem(a, b)\n(-2, -2)\n\njulia> r = mod(a, b)\n3\n\njulia> c = a % b\n-2","category":"section"},{"location":"integer/#Comparison","page":"Integers","title":"Comparison","text":"Here is a list of the comparison functions implemented, with the understanding that isless provides all the usual comparison operators.\n\nFunction\nisless(a::n_Z, b::n_Z)\n\nWe also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.\n\nFunction\nisless(a::n_Z, b::Integer)\nisless(a::Integer, b::n_Z)\n\nExamples\n\njulia> a = ZZ(12)\n12\n\njulia> b = ZZ(3)\n3\n\njulia> a < b\nfalse\n\njulia> a != b\ntrue\n\njulia> a > 4\ntrue\n\njulia> 5 <= b\nfalse","category":"section"},{"location":"integer/#Base.denominator-Tuple{n_Z}","page":"Integers","title":"Base.denominator","text":"denominator(n::n_Z)\n\nReturn the denominator of n (which will always be 1).\n\n\n\n\n\n","category":"method"},{"location":"integer/#Base.numerator-Tuple{n_Z}","page":"Integers","title":"Base.numerator","text":"numerator(n::n_Z)\n\nReturn the numerator of n (which is n itself).\n\n\n\n\n\n","category":"method"},{"location":"noncommutative/#Noncommutative-algebras","page":"Noncommutative algebras","title":"Noncommutative algebras","text":"Singular.jl allows the creation of various noncommutative algebras over any of the coefficient rings described above. The constructors of the parent objects and elements thereof are given in the following table.\n\nConstructor Element type Parent type SINGULAR kernel subsystem\nGAlgebra spluralg{T} PluralRing{T} PLURAL\nWeylAlgebra spluralg{T} PluralRing{T} PLURAL\nFreeAlgebra slpalg{T} LPRing{T} LETTERPLACE\n\nThese types are parameterized by the type of elements in the coefficient ring of the algebra. All noncommutative algebra element types belong directly to the abstract type AbstractAlgebra.NCRingElem and all the noncommuative algebra parent object types belong to the abstract type AbstractAlgebra.NCRing. The following union types cover all of Singular polynomial rings and algebras.\n\nconst PolyRingUnion{T} = Union{PolyRing{T}, PluralRing{T}, LPRing{T}} where T <: Nemo.RingElem\n\nconst SPolyUnion{T} = Union{spoly{T}, spluralg{T}, slpalg{T}} where T <: Nemo.RingElem","category":"section"},{"location":"noncommutative/#Constructors","page":"Noncommutative algebras","title":"Constructors","text":"All constructors returns a tuple, R x consisting of a parent object R and an array x of variables from which elements of the algebra can be constructed.\n\nFor constructors taking an ordering, two orderings can be specified by symbol, one for term ordering, and a second one for ordering of module components. The first ordering can also be specified by a non-symbol as with polynomial_ring, in which case the second ordering is ignored.\n\nBy default there will only be one parent object in the system for each combination of arguments. This is accomplished by making use of a global cache. If this is not the desired behaviour cached = false may be passed.","category":"section"},{"location":"noncommutative/#GAlgebra","page":"Noncommutative algebras","title":"GAlgebra","text":"GAlgebra(R::PolyRing{T}, C::smatrix{spoly{T}}, D::smatrix{spoly{T}};\n         cached::Bool = true) where T <: Nemo.RingElem\n\nConstruct the G-algebra from a commutative polynomial ring R and matrices C, D over R. If the variables of R are x_1dotsx_n, then the noncommutative algebra is constructed with relations x_j x_i = c_ij x_i x_j + d_ij for 1 le i  j le n. The c_ij must be nonzero constant polynomials and the relations x_i x_j  mathrmlm(d_ij) must hold in the monomial ordering of the ring R.\n\nThe entries of the matrices C and D on or below the main diagonal are ignored. A non-matrix argument a for either C or D is turned into a matrix with all relevant entries set to a.\n\nnote: Note\nThe conditions that assure that multiplication is associative in the resulting algebra are currently not checked. The example below illustrates how this condition can be checked.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]);\n\njulia> G, (x, y) = GAlgebra(R, 2, Singular.Matrix(R, [0 x; 0 0]))\n(Singular G-algebra (QQ),(x,y),(dp(2),C), spluralg{n_Q}[x, y])\n\njulia> y*x\n2*x*y + x\n\nAssociativity can be checked via Interpreter Functionality.\n\njulia> iszero(Singular.LibNctools.ndcond(G))\ntrue\n\nThe construction of a GR-algebra proceeds by taking the quotient of a G-algebra by a two-sided ideal. Continuing with the above example:\n\njulia> I = Ideal(G, [x^2 + y^2], twosided = true)\nSingular two-sided ideal over Singular G-algebra (QQ),(x,y),(dp(2),C) with generators (x^2 + y^2)\n\njulia> Q, (x, y) = QuotientRing(G, std(I))\n(Singular G-algebra quotient ring (QQ),(x,y),(dp(2),C), spluralg{n_Q}[x, y])","category":"section"},{"location":"noncommutative/#WeylAlgebra","page":"Noncommutative algebras","title":"WeylAlgebra","text":"function WeylAlgebra(R::Union{Ring, Field}, s::AbstractVector{<:VarName};\n                     ordering = :degrevlex, ordering2::Symbol = :comp1min,\n                     cached::Bool = true, degree_bound::Int = 0)\n\nfunction WeylAlgebra(R::Union{Ring, Field}, s::AbstractMatrix{<:VarName};\n                     ordering = :degrevlex, ordering2::Symbol = :comp1min,\n                     cached::Bool = true, degree_bound::Int = 0)\n\nConstruct the ring of differential operators partial_1 dots partial_n with coefficients in Rx_1 dots x_n. In the first variant, the differential operators are named by simply appending the letter \"d\" to each of the strings in x. The second variant takes the names of the x_i from the first row of the matrix and the names of the partial_i from the second row of the matrix. Note that the functionality of this constructor can be achieved with the GAlgebra constructor: it is provided only for convenience. Note also that due to the ordering constraint on G-algebras, the orderings :neglex, :negdeglex, :negdevrevlex are excluded.\n\nExamples\n\njulia> R, (x, y, dx, dy) = WeylAlgebra(ZZ, [\"x\", \"y\"])\n(Singular G-algebra (ZZ),(x,y,dx,dy),(dp(4),C), spluralg{n_Z}[x, y, dx, dy])\n\njulia> (dx*x, dx*y, dy*x, dy*y)\n(x*dx + 1, y*dx, x*dy, y*dy + 1)\n\nThe ideals of G-algebras are left ideals by default.\n\njulia> R, (x1, x2, x3, d1, d2, d3) = WeylAlgebra(QQ, [\"x1\" \"x2\" \"x3\"; \"d1\" \"d2\" \"d3\"])\n(Singular G-algebra (QQ),(x1,x2,x3,d1,d2,d3),(dp(6),C), spluralg{n_Q}[x1, x2, x3, d1, d2, d3])\n\njulia> gens(std(Ideal(R, [x1^2*d2^2 + x2^2*d3^2, x1*d2 + x3])))\n7-element Vector{spluralg{n_Q}}:\n x1*d2 + x3\n x3^2\n x2*x3 - x1\n x1*x3\n x2^2\n x1*x2\n x1^2","category":"section"},{"location":"noncommutative/#FreeAlgebra","page":"Noncommutative algebras","title":"FreeAlgebra","text":"FreeAlgebra(R::Field, s::AbstractVector{<:VarName}, degree_bound::Int;\n            ordering = :degrevlex, ordering2::Symbol = :comp1min,\n            cached::Bool = true)\n\nConstruct the free associative algebra R langle x_1dotsx_n rangle. The ordering must be global.\n\nnote: Note\nSince this uses the LETTERPLACE backend, the degree_bound, which is the maximum length on any monomial word in the algebra, must be specified. Multiplication is checked and throws when the resulting degree exceeds this bound.\n\nExamples\n\njulia> R, (x, y) = FreeAlgebra(QQ, [\"x\", \"y\"], 5)\n(Singular letterplace ring (QQ),(x,y,x,y,x,y,x,y,x,y),(dp(10),C,L(3)), slpalg{n_Q}[x, y])\n\njulia> (x*y)^2\nx*y*x*y\n\njulia> (x*y)^3\nERROR: degree bound of Letterplace ring is 5, but at least 6 is needed for this multiplication\n\nThe ideals are two-sided by default for this algebra, and there is currently no possibility of constructing one-sided ideals.\n\njulia> R, (x, y, z) = FreeAlgebra(QQ, [\"x\", \"y\", \"z\"], 4)\n(Singular letterplace ring (QQ),(x,y,z,x,y,z,x,y,z,x,y,z),(dp(12),C,L(3)), slpalg{n_Q}[x, y, z])\n\njulia> gens(std(Ideal(R, [x*y + y*z, x*x + x*y - y*x - y*y])))\n8-element Vector{slpalg{n_Q}}:\n x*y + y*z\n x^2 - y*x - y^2 - y*z\n y^3 + y*z*y - y^2*z - y*z^2\n y^2*x + y*z*x + y^2*z + y*z^2\n y^2*z*y + y*z^2*y - y^2*z^2 - y*z^3\n y*z*y^2 + y*z^2*y - y*z*y*z - y*z^3\n y^2*z*x + y*z^2*x + y^2*z^2 + y*z^3\n y*z*y*x + y*z^2*x + y*z*y*z + y*z^3","category":"section"},{"location":"noncommutative/#Term-Iterators","page":"Noncommutative algebras","title":"Term Iterators","text":"For GAlgebra and WeylAlgebra, the elements can be and are represented using commutative data structures, and the function exponent_vectors is repurposed for access to the individual exponents.\n\nExamples\n\njulia> R, (x, y, dx, dy) = WeylAlgebra(QQ, [\"x\", \"y\"])\n(Singular G-algebra (QQ),(x,y,dx,dy),(dp(4),C), spluralg{n_Q}[x, y, dx, dy])\n\njulia> p = (dx + dy)*(x + y)\nx*dx + y*dx + x*dy + y*dy + 2\n\njulia> show(collect(exponent_vectors(p)))\n[[1, 0, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1], [0, 1, 0, 1], [0, 0, 0, 0]]\n\nFor FreeAlgebra, the function exponent_vectors is undefined on elements and replaced by exponent_words which reads off in order the indices of the variables in a monomial. Also, the monomials for the MPolyBuildCtx are specified by these exponent words. Other than these differences the term iterators have the same behavior as in the commutative case.\n\nExamples\n\njulia> R, (x, y, z) = FreeAlgebra(QQ, [\"x\", \"y\", \"z\"], 6)\n(Singular letterplace ring (QQ),(x,y,z,x,y,z,x,y,z,x,y,z,x,y,z,x,y,z),(dp(18),C,L(3)), slpalg{n_Q}[x, y, z])\n\njulia> p = (1 + x*z + y)^2\nx*z*x*z + x*z*y + y*x*z + y^2 + 2*x*z + 2*y + 1\n\njulia> show(collect(coefficients(p)))\nn_Q[1, 1, 1, 1, 2, 2, 1]\n\njulia> show(collect(monomials(p)))\nslpalg{n_Q}[x*z*x*z, x*z*y, y*x*z, y^2, x*z, y, 1]\n\njulia> show(collect(terms(p)))\nslpalg{n_Q}[x*z*x*z, x*z*y, y*x*z, y^2, 2*x*z, 2*y, 1]\n\njulia> show(collect(exponent_words(p)))\n[[1, 3, 1, 3], [1, 3, 2], [2, 1, 3], [2, 2], [1, 3], [2], Int64[]]\n\njulia> B = MPolyBuildCtx(R)\nBuilder for an element of Singular letterplace ring (QQ),(x,y,z,x,y,z,x,y,z,x,y,z,x,y,z,x,y,z),(dp(18),C,L(3))\n\njulia> push_term!(B, QQ(2), [3,2,1,3]);\n\njulia> push_term!(B, QQ(-1), Int[]);\n\njulia> finish(B)\n2*z*y*x*z - 1","category":"section"},{"location":"resolution/#Resolutions","page":"Resolutions","title":"Resolutions","text":"Functions for creating free resolutions of modules and ideals in Singular.jl return a special Singular object of type sresolution{T}. The support in Singular.jl for this type primarily exists to allow interaction with such resolutions. Free resolutions can have the property of being minimal, which is specified by the minimal field of the sresolution{T} type.\n\nResolution objects have a parent object which represents the set of resolutions they belong to, the data for which is given by the polynomial ring R over which the modules in the resolution are defined.\n\nThe types of resolutions and associated parent objects are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular sresolution{T} Singular.ResolutionSet{T}\n\nThese types are parameterised by the type of elements in the polynomial ring R over which the modules belonging to the resolution are defined.\n\nAll resolution types belong directly to the abstract type SetElem and all the resolution set parent object types belong to the abstract type Set.","category":"section"},{"location":"resolution/#Resolution-functionality","page":"Resolutions","title":"Resolution functionality","text":"Singular.jl resolutions implement standard operations one would expect on all AbstractAlgebra compatible objects. These include:\n\nOperations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.\n\nBelow, we describe all of the functionality for Singular.jl resolutions that is not included in this list of basic operations.","category":"section"},{"location":"resolution/#Constructors","page":"Resolutions","title":"Constructors","text":"There are currently two ways to create resolutions in Singular.jl: They can either be created by taking the free resolution of an ideal or module over a polynomial ring, as described in the relevant sections of the documentation, or they can be created by the following constructor:\n\nExample\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular Polynomial Ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> M1 = Singular.Module(R, vector(R, x), vector(R, y))\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\nx*gen(1)\ny*gen(1)\n\njulia> M2 = Singular.Module(R, vector(R, y, -x))\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\n-x*gen(2)+y*gen(1)\n\njulia> F = Resolution([M1, M2]);\n\njulia> F[1]\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\nx*gen(1)\ny*gen(1)\n\njulia> F[2]\nSingular Module over Singular Polynomial Ring (QQ),(x,y),(dp(2),C), with Generators:\n-x*gen(2)+y*gen(1)\n\nAlternatively, resolutions can be refined to minimal resolutions, as described below.\n\nOther than this, there are currently no additional ways to create resolutions in Singular.jl.","category":"section"},{"location":"resolution/#Basic-manipulation","page":"Resolutions","title":"Basic manipulation","text":"Singular.jl overloads the getindex function so that one can access the modules in a resolution F.\n\nF[n::Int]\n\nExamples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [\"w\", \"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C), spoly{n_Q}[w, x, y, z])\n\njulia> I = Ideal(R, w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\nSingular ideal over Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C) with generators (w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\n\njulia> F = fres(std(I), 0)\nSingular resolution: R^1 <- R^5 <- R^6 <- R^2\n\njulia> n = length(F)\n3\n\njulia> M1 = F[1]\nSingular ideal over Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C) with generators (y^2 - w*z, x*y - z^2, x^2 - w*y, w*x - y*z, w^2 - x*z)","category":"section"},{"location":"resolution/#Betti-numbers","page":"Resolutions","title":"Betti numbers","text":"Examples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [\"w\", \"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C), spoly{n_Q}[w, x, y, z])\n\njulia> I = Ideal(R, w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\nSingular ideal over Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C) with generators (w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\n\njulia> F = fres(std(I), 3)\nSingular resolution: R^1 <- R^5 <- R^6 <- R^2\n\njulia> M = minres(F)\nSingular resolution: R^1 <- R^5 <- R^5 <- R^1\n\njulia> B = betti(M)\n34 Matrix{Int32}:\n 1  0  0  0\n 0  5  5  0\n 0  0  0  1","category":"section"},{"location":"resolution/#Minimal-resolutions","page":"Resolutions","title":"Minimal resolutions","text":"Examples\n\njulia> R, (w, x, y, z) = polynomial_ring(QQ, [\"w\", \"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C), spoly{n_Q}[w, x, y, z])\n\njulia> I = Ideal(R, w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\nSingular ideal over Singular polynomial ring (QQ),(w,x,y,z),(dp(4),C) with generators (w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z)\n\njulia> F = fres(std(I), 3)\nSingular resolution: R^1 <- R^5 <- R^6 <- R^2\n\njulia> M = minres(F)\nSingular resolution: R^1 <- R^5 <- R^5 <- R^1","category":"section"},{"location":"resolution/#Singular.Resolution-Union{Tuple{Array{smodule{T}, 1}}, Tuple{T}} where T<:AbstractAlgebra.FieldElem","page":"Resolutions","title":"Singular.Resolution","text":"Resolution(C::Vector{smodule{T}}) where T <: AbstractAlgebra.RingElem\n\nCreate a new resolution whose maps are given by the elements of an array C of modules. Note that it is not checked that the maps are actually composable and that their pairwise composition is the zero map, that is, that the created resolution is a complex.\n\n\n\n\n\n","category":"method"},{"location":"resolution/#Base.length-Tuple{sresolution}","page":"Resolutions","title":"Base.length","text":"length(r::sresolution)\n\nReturn the length of the resolution. This is what is mathematically meant by the length of a resolution. Over a field, this should be at most the number of variables in the polynomial ring.\n\n\n\n\n\n","category":"method"},{"location":"resolution/#Singular.betti-Tuple{sresolution}","page":"Resolutions","title":"Singular.betti","text":"betti(r::sresolution)\n\nReturn the Betti numbers, i.e. the ranks of the free modules in the given free resolution. These are returned as a Julia array of Ints. Note that the output of this command is useful only in the graded case.\n\n\n\n\n\n","category":"method"},{"location":"resolution/#Singular.minres-Union{Tuple{sresolution{spoly{T}}}, Tuple{T}} where T<:AbstractAlgebra.FieldElem","page":"Resolutions","title":"Singular.minres","text":"minres{T <: Nemo.FieldElem}(r::sresolution{spoly{T}})\n\nReturn a minimal free resolution, given any free resolution. In the graded case, there exists a uniquely determined minimal resolution. If the supplied resolution is already minimal, it may be returned without making a copy.\n\n\n\n\n\n","category":"method"},{"location":"#Getting-Started","page":"Getting Started","title":"Getting Started","text":"Singular.jl is a Julia interface to the Singular computer algebra system. It was written by Oleksandr Motsak, William Hart and other contributors, and is maintained by Hans Schoenemann and Max Horn. It is part of the Oscar project which is supported by the Deutsche Forschungsgemeinschaft DFG within the Collaborative Research Center TRR 195.\n\nhttps://www.singular.uni-kl.de/ (Singular website)\nhttps://github.com/oscar-system/Singular.jl (Singular.jl source code)\nhttps://oscar-system.github.io/Singular.jl/stable/ (Singular.jl online documentation)\n\nThe features of Singular so far include:\n\nSingular integers, rationals Z/nZ, Z/pZ, Galois fields\nMultivariate polynomials, including several noncommutative variants\nIdeals over polynomial rings\nFree modules over polynomial rings and submodules given by a finite generating set\nGroebner basis over a field\nFree/minimal resolutions\nSyzygy modules\nNemo.jl rings can be used as coefficient rings","category":"section"},{"location":"#Installation","page":"Getting Started","title":"Installation","text":"To use Singular.jl we require Julia 1.10 or higher. Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system.\n\nAt the Julia prompt simply type\n\njulia> using Pkg; Pkg.add(\"Singular\")\n\nHere is an example of using Singular.jl\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> I = Ideal(R, x^2 + 1, x*y + 1)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y + 1)\n\njulia> G = std(I)\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x - y, y^2 + 1)\n\njulia> Z = syz(G)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\ny^2*gen(1)-x*gen(2)+y*gen(2)+gen(1)\n\njulia> F = fres(G, 0)\nSingular resolution: R^1 <- R^2 <- R^1\n\njulia> F[1]\nSingular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x - y, y^2 + 1)","category":"section"},{"location":"module/#Finitely-generated-modules","page":"Finitely generated modules","title":"Finitely generated modules","text":"Singular.jl allows the creation of submodules of a free module over a Singular polynomial ring, given by a finite generating set. These are internally stored as a list of elements of a free module over a polynomial ring R. This list of generators can also have the property of being a Groebner basis.\n\nThe default finitely generated module type in Singular.jl is the Singular smodule type.\n\nModule objects have a parent object which represents the class of R-modules they belong to, the data for which is given by the polynomial ring R over which the modules are defined.\n\nThe types of modules and associated parent objects are given in the following table according to the library providing them.\n\nLibrary Element type Parent type\nSingular smodule{T} Singular.ModuleClass{T}\n\nThese types are parameterised by the type of elements in the polynomial ring R.\n\nAll module types belong directly to the abstract type Module{T} and all the module class parent object types belong to the abstract type Set.","category":"section"},{"location":"module/#Module-functionality","page":"Finitely generated modules","title":"Module functionality","text":"Singular.jl modules implement standard operations one would expect on modules. These include:\n\nOperations common to all AbstractAlgebra objects, such as parent, base_ring, elem_type, parent_type, parent, deepcopy, etc.\n\nBelow, we describe all of the functionality for Singular.jl modules that is not included in this list of basic operations.","category":"section"},{"location":"module/#Constructors","page":"Finitely generated modules","title":"Constructors","text":"Given a Singular polynomial ring R, the following constructors are available for creating modules.\n\nModule{T <: Nemo.RingElem}(R::PolyRing{T}, vecs::svector{spoly{T}}...)\n\nConstruct the module over the polynomial ring R whose generators are given by the given parameter list of vectors (of length n), each component of which is a polynomial. These vectors represent elements of the free module R^n.\n\nNote that Module must be prepended with the package name Singular to disambiguate from Base.Module.\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^2 + 1, 2x + 3y, x)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> M = Singular.Module(R, v1, v2)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)","category":"section"},{"location":"module/#Basic-manipulation","page":"Finitely generated modules","title":"Basic manipulation","text":"Singular.jl overloads the setindex! and getindex functions so that one can access the generators of a module using array notation. Each entry is a vector in R^n.\n\nM[n::Int]\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^2 + 1, 2x + 3y, x)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> M = Singular.Module(R, v1, v2)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> iszero(M) == false\ntrue\n\njulia> M[1] == v1\ntrue\n\njulia> n = rank(M)\n3\n\njulia> d = number_of_generators(M)\n2","category":"section"},{"location":"module/#Standard-basis","page":"Finitely generated modules","title":"Standard basis","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^2 + 1, 2x + 3y, x)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> v3 = x*v1 + y*v2 + vector(R, x, y + 1, y^2)\nx^2*y*gen(2)+x^2*y*gen(1)+x^2*gen(1)+2*x*y*gen(3)+2*x*y*gen(2)+y^2*gen(3)+3*y^2*gen(2)+x*gen(2)+2*x*gen(1)+y*gen(2)+y*gen(1)+gen(2)\n\njulia> M = Singular.Module(R, v1, v2, v3)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\nx^2*y*gen(2)+x^2*y*gen(1)+x^2*gen(1)+2*x*y*gen(3)+2*x*y*gen(2)+y^2*gen(3)+3*y^2*gen(2)+x*gen(2)+2*x*gen(1)+y*gen(2)+y*gen(1)+gen(2)\n\njulia> G = std(M; complete_reduction=true)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\ny^2*gen(3)+x*gen(1)+y*gen(2)+gen(2)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)","category":"section"},{"location":"module/#Reduction","page":"Finitely generated modules","title":"Reduction","text":"Examples\n\njulia> R, (x, y, z) = polynomial_ring(QQ, [\"x\", \"y\", \"z\"])\n(Singular polynomial ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])\n\njulia> v1 = vector(R, R(0), z, -y)\n-y*gen(3)+z*gen(2)\n\njulia> v2 = vector(R, -z, R(0), x)\nx*gen(3)-z*gen(1)\n\njulia> v3 = vector(R, y, x, R(0))\nx*gen(2)+y*gen(1)\n\njulia> v = y*v1+x*v2+z*v3\nx^2*gen(3)-y^2*gen(3)+x*z*gen(2)-x*z*gen(1)+y*z*gen(2)+y*z*gen(1)\n\njulia> M = Singular.Module(R, v1, v2, v3)\nSingular module over Singular polynomial ring (QQ),(x,y,z),(dp(3),C), with generators:\n-y*gen(3)+z*gen(2)\nx*gen(3)-z*gen(1)\nx*gen(2)+y*gen(1)\n\njulia> B = std(M; complete_reduction=true)\nSingular module over Singular polynomial ring (QQ),(x,y,z),(dp(3),C), with generators:\ny*gen(3)-z*gen(2)\nx*gen(2)+y*gen(1)\nx*gen(3)-z*gen(1)\ny*z*gen(1)\n\njulia> V = Singular.Module(R, v)\nSingular module over Singular polynomial ring (QQ),(x,y,z),(dp(3),C), with generators:\nx^2*gen(3)-y^2*gen(3)+x*z*gen(2)-x*z*gen(1)+y*z*gen(2)+y*z*gen(1)\n\njulia> reduce(V,B)\nSingular module over Singular polynomial ring (QQ),(x,y,z),(dp(3),C), with generators:\n0\n","category":"section"},{"location":"module/#Syzygies","page":"Finitely generated modules","title":"Syzygies","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, (x + 1)*y, (x*y + 1)*y, y)\nx*y^2*gen(2)+x*y*gen(1)+y*gen(3)+y*gen(2)+y*gen(1)\n\njulia> v2 = vector(R, (x + 1)*x, (x*y + 1)*x, x)\nx^2*y*gen(2)+x^2*gen(1)+x*gen(3)+x*gen(2)+x*gen(1)\n\njulia> M = Singular.Module(R, v1, v2)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\nx*y^2*gen(2)+x*y*gen(1)+y*gen(3)+y*gen(2)+y*gen(1)\nx^2*y*gen(2)+x^2*gen(1)+x*gen(3)+x*gen(2)+x*gen(1)\n\njulia> Z = syz(M)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\nx*gen(1)-y*gen(2)","category":"section"},{"location":"module/#Free-resolutions","page":"Finitely generated modules","title":"Free resolutions","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^2 + 1, 2x + 3y, x)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> M = std(Singular.Module(R, v1, v2))\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^2*gen(1)+x*gen(3)+2*x*gen(2)+3*y*gen(2)+gen(1)\n\njulia> F = sres(M, 0)\nSingular resolution: R^3 <- R^2\n\njulia> M1 = Singular.Matrix(M)\n[x + 1, x^2 + 1\nx*y + 1, 2*x + 3*y\ny, x]\n\njulia> M2 = Singular.Matrix(F[2])\n[0\n0]\n\njulia> iszero(M1*M2) # test we have a complex\ntrue","category":"section"},{"location":"module/#Jet-of-module","page":"Finitely generated modules","title":"Jet of module","text":"Examples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"])\n(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])\n\njulia> v1 = vector(R, x + 1, x*y + 1, y)\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n\njulia> v2 = vector(R, x^5 + 1, 2x^3 + 3y^2, x^2)\nx^5*gen(1)+2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)\n\njulia> M = Singular.Module(R, v1, v2)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\nx^5*gen(1)+2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)\n\njulia> N = jet(M,3)\nSingular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:\nx*y*gen(2)+x*gen(1)+y*gen(3)+gen(2)+gen(1)\n2*x^3*gen(2)+x^2*gen(3)+3*y^2*gen(2)+gen(1)","category":"section"},{"location":"module/#Operations-over-local-rings","page":"Finitely generated modules","title":"Operations over local rings","text":"If the base ring R is a local ring, a minimal generating set can be computed using the following function\n\nExamples\n\njulia> R, (x, y) = polynomial_ring(QQ, [\"x\", \"y\"]; ordering=:negdegrevlex)\n(Singular polynomial ring (QQ),(x,y),(ds(2),C), spoly{n_Q}[x, y])\n\njulia> has_local_ordering(R) == true\ntrue\n\njulia> v1 = vector(R, x, y^2)\nx*gen(1)+y^2*gen(2)\n\njulia> v2 = vector(R, y - x, y - y^2)\n-x*gen(1)+y*gen(2)+y*gen(1)-y^2*gen(2)\n\njulia> v3 = v1 + v2\ny*gen(2)+y*gen(1)\n\njulia> M = Singular.Module(R, v1, v2, v3)\nSingular module over Singular polynomial ring (QQ),(x,y),(ds(2),C), with generators:\nx*gen(1)+y^2*gen(2)\n-x*gen(1)+y*gen(2)+y*gen(1)-y^2*gen(2)\ny*gen(2)+y*gen(1)\n\njulia> min = minimal_generating_set(M)\n2-element Vector{svector{spoly{n_Q}}}:\n y*gen(2)+y*gen(1)\n x*gen(1)-y*gen(2)-y*gen(1)+y^2*gen(2)","category":"section"},{"location":"module/#AbstractAlgebra.number_of_generators-Tuple{smodule}","page":"Finitely generated modules","title":"AbstractAlgebra.number_of_generators","text":"number_of_generators(I::smodule)\n\nReturn the number of generators in the current representation of the module (as a list of vectors).\n\n\n\n\n\n","category":"method"},{"location":"module/#LinearAlgebra.rank-Tuple{smodule}","page":"Finitely generated modules","title":"LinearAlgebra.rank","text":"rank(I::smodule)\n\nReturn the rank n of the ambient space R^n of which this module is a submodule.\n\n\n\n\n\n","category":"method"},{"location":"module/#Base.iszero-Tuple{smodule}","page":"Finitely generated modules","title":"Base.iszero","text":"iszero(p::smodule)\n\nReturn true if this is algebraically the zero module.\n\n\n\n\n\n","category":"method"},{"location":"module/#Singular.std-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.std","text":"std(I::smodule; complete_reduction::Bool=false)\n\nCompute the Groebner basis of the module I. If complete_reduction is set to true, the result is unique, up to permutation of the generators and multiplication by constants. If not, only the leading terms are unique (up to permutation of the generators and multiplication by constants, of course). Presently the polynomial ring used must be over a field or over the Singular integers.\n\n\n\n\n\n","category":"method"},{"location":"module/#Singular.lift_std-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.lift_std","text":"lift_std(M::smodule)\n\nComputes the Groebner base G of M and the transformation matrix T such that (Matrix(G) = Matrix(M) * T).\n\n\n\n\n\n","category":"method"},{"location":"module/#Singular.lift_std_syz-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.lift_std_syz","text":"lift_std_syz(M::smodule)\n\nComputes the Groebner base G of M, the transformation matrix T and the syzygies of M. Returns a tuple (G,T,S) satisfying (Matrix(G) = Matrix(M) * T, 0=Matrix(M)*Matrix(S)).\n\n\n\n\n\n","category":"method"},{"location":"module/#Base.reduce-Tuple{smodule, smodule}","page":"Finitely generated modules","title":"Base.reduce","text":"reduce(M::smodule, G::smodule; complete_reduction::Bool = true)\n\nReturn a submodule whose generators are the generators of M reduced by the submodule G. The submodule G need not be a Groebner basis. The returned submodule will have the same number of generators as M, even if they are zero.\n\n\n\n\n\n","category":"method"},{"location":"module/#Singular.syz-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.syz","text":"syz(M::smodule)\n\nCompute the module of syzygies of the given module. This will be given as a set of generators in an ambient space R^n, where n is the number of generators in M.\n\n\n\n\n\n","category":"method"},{"location":"module/#Singular.sres-Union{Tuple{T}, Tuple{smodule{spoly{T}}, Int64}} where T<:AbstractAlgebra.FieldElem","page":"Finitely generated modules","title":"Singular.sres","text":"sres(I::smodule{spoly{T}}, max_length::Int) where T <: Singular.FieldElem\n\nCompute a free resolution of the given module I of length up to the given maximum length. If max_length is set to zero, a full length free resolution is computed. Each element of the resolution is itself a module.\n\n\n\n\n\n","category":"method"},{"location":"module/#Singular.jet-Tuple{smodule, Int64}","page":"Finitely generated modules","title":"Singular.jet","text":"jet(M::smodule, n::Int)\n\nGiven a module M this function truncates the generators of M up to degree n.\n\n\n\n\n\n","category":"method"},{"location":"module/#Singular.minimal_generating_set-Tuple{smodule}","page":"Finitely generated modules","title":"Singular.minimal_generating_set","text":"minimal_generating_set(M::smodule)\n\nReturn a vector containing the minimal generators of M.\n\n\n\n\n\n","category":"method"}]
}
