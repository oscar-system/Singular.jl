<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ideals · Singular.jl</title><meta name="title" content="Ideals · Singular.jl"/><meta property="og:title" content="Ideals · Singular.jl"/><meta property="twitter:title" content="Ideals · Singular.jl"/><meta name="description" content="Documentation for Singular.jl."/><meta property="og:description" content="Documentation for Singular.jl."/><meta property="twitter:description" content="Documentation for Singular.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Singular.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><span class="tocitem">Coefficient rings</span><ul><li><a class="tocitem" href="../integer/">Integers</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../modn/">Integers mod n</a></li><li><a class="tocitem" href="../modp/">Integers mod p</a></li><li><a class="tocitem" href="../transExt/">Function fields</a></li><li><a class="tocitem" href="../GF/">Finite fields</a></li><li><a class="tocitem" href="../nemo/">Nemo rings and fields</a></li></ul></li><li><a class="tocitem" href="../polynomial/">Multivariate polynomials</a></li><li><a class="tocitem" href="../noncommutative/">Noncommutative algebras</a></li><li class="is-active"><a class="tocitem" href>Ideals</a><ul class="internal"><li><a class="tocitem" href="#Ideal-functionality"><span>Ideal functionality</span></a></li></ul></li><li><a class="tocitem" href="../qring/">Quotient Rings</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module/">Finitely generated modules</a></li><li><a class="tocitem" href="../vector/">Free modules and vectors</a></li></ul></li><li><a class="tocitem" href="../alghom/">Algebra Homomorphisms</a></li><li><a class="tocitem" href="../resolution/">Resolutions</a></li><li><a class="tocitem" href="../matrix/">Matrices</a></li><li><a class="tocitem" href="../caller/">Interpreter Functionality</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ideals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ideals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oscar-system/Singular.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/ideal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Ideals"><a class="docs-heading-anchor" href="#Ideals">Ideals</a><a id="Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Ideals" title="Permalink"></a></h1><p>Singular.jl allows the creation of ideals over a Singular polynomial ring. These are internally stored as a list of (polynomial) generators. This list of generators can also have the property of being a Groebner basis.</p><p>The default ideal type in Singular.jl is the Singular <code>sideal</code> type.</p><p>Ideals objects have a parent object which represents the set of ideals they belong to, the data for which is given by the polynomial ring their generators belong to.</p><p>The types of ideals and associated parent objects are given in the following table according to the library providing them.</p><table><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Singular</td><td style="text-align: right"><code>sideal{T}</code></td><td style="text-align: right"><code>Singular.IdealSet{T}</code></td></tr></table><p>These types are parameterised by the type of elements of the polynomial ring over which the ideals are defined.</p><p>All ideal types belong directly to the abstract type <code>Module{T}</code> and all the ideal set parent object types belong to the abstract type <code>Set</code>.</p><h2 id="Ideal-functionality"><a class="docs-heading-anchor" href="#Ideal-functionality">Ideal functionality</a><a id="Ideal-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-functionality" title="Permalink"></a></h2><p>Singular.jl ideals implement standard operations one would expect on modules. These include:</p><ul><li><p>Operations common to all AbstractAlgebra objects, such as <code>parent</code>, <code>base_ring</code>, <code>elem_type</code>, <code>parent_type</code>, <code>parent</code>, <code>deepcopy</code>, etc.</p></li><li><p>Addition</p></li></ul><p>Also implements is the following operations one expects for ideals:</p><ul><li><p>Multiplication</p></li><li><p>Powering</p></li></ul><p>Below, we describe all of the functionality for Singular.jl ideals that is not included in this list of basic operations.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>Given a Singular polynomial ring <span>$R$</span>, the following constructors are available for creating ideals.</p><pre><code class="language-julia hljs">Ideal(R::PolyRing{T}, ids::spoly{T}...) where T &lt;: Nemo.RingElem
Ideal(R::PolyRing{T}, ids::Vector{spoly{T}}) where T &lt;: Nemo.RingElem</code></pre><p>Construct the ideal over the polynomial ring <span>$R$</span> whose (polynomial) generators are given by the given parameter list or array of polynomials, respectively. The list may be empty, resulting in the zero ideal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])

julia&gt; I1 = Ideal(R, x*y + 1, x^2)
Singular ideal over Singular polynomial ring (ZZ),(x,y),(dp(2),C) with generators (x*y + 1, x^2)

julia&gt; I2 = Ideal(R, [x*y + 1, x^2])
Singular ideal over Singular polynomial ring (ZZ),(x,y),(dp(2),C) with generators (x*y + 1, x^2)</code></pre><h3 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.number_of_generators-Tuple{sideal}" href="#AbstractAlgebra.number_of_generators-Tuple{sideal}"><code>AbstractAlgebra.number_of_generators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">number_of_generators(I::sideal)</code></pre><p>Return the number of generators in the internal representation of the ideal <span>$I$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.gens-Tuple{sideal}" href="#AbstractAlgebra.gens-Tuple{sideal}"><code>AbstractAlgebra.gens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gens(I::sideal)</code></pre><p>Return the generators in the internal representation of the ideal <span>$I$</span> as an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L38-L42">source</a></section></article><p>Singular.jl overloads the <code>setindex!</code> and <code>getindex</code> functions so that one can access the generators of an ideal using array notation.</p><pre><code class="language-julia hljs">I[n::Int]</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iszero-Tuple{sideal}" href="#Base.iszero-Tuple{sideal}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iszero(I::sideal)</code></pre><p>Return <code>true</code> if the given ideal is algebraically the zero ideal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.is_zerodim-Tuple{sideal}" href="#Singular.is_zerodim-Tuple{sideal}"><code>Singular.is_zerodim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_zerodim(I::sideal)</code></pre><p>Return <code>true</code> if the given ideal is zero dimensional, i.e. the Krull dimension of <span>$R/I$</span> is zero, where <span>$R$</span> is the polynomial ring over which <span>$I$</span> is an ideal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.dimension-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.dimension-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.dimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimension(I::sideal{spoly{T}}) where T &lt;: Nemo.RingElem</code></pre><p>Given an ideal <span>$I$</span> this function computes the Krull dimension of the ring <span>$R/I$</span>, where <span>$R$</span> is the polynomial ring over which <span>$I$</span> is an ideal. The ideal must be over a polynomial ring and a Groebner basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L96-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractAlgebra.is_constant-Tuple{sideal}" href="#AbstractAlgebra.is_constant-Tuple{sideal}"><code>AbstractAlgebra.is_constant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_constant(I::sideal)</code></pre><p>Return <code>true</code> if the given ideal is a constant ideal, i.e. generated by constants in the polynomial ring over which it is an ideal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.is_var_generated-Tuple{sideal}" href="#Singular.is_var_generated-Tuple{sideal}"><code>Singular.is_var_generated</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_var_generated(I::sideal)</code></pre><p>Return <code>true</code> if each generator in the representation of the ideal <span>$I$</span> is a generator of the polynomial ring, i.e. a variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.normalize!-Tuple{sideal}" href="#LinearAlgebra.normalize!-Tuple{sideal}"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize!(I::sideal)</code></pre><p>Normalize the polynomial generators of the ideal <span>$I$</span> in-place. This means to reduce their coefficients to lowest terms. In most cases this does nothing, but if the coefficient ring were the rational numbers for example, the coefficients of the polynomials would be reduced to lowest terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L243-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.interreduce-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T&lt;:AbstractAlgebra.RingElem, S&lt;:Union{spluralg{T}, spoly{T}}}" href="#Singular.interreduce-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T&lt;:AbstractAlgebra.RingElem, S&lt;:Union{spluralg{T}, spoly{T}}}"><code>Singular.interreduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interreduce(I::sideal{S}) where {T &lt;: Nemo.RingElem, S &lt;: Union{spoly{T}, spluralg{T}}}</code></pre><p>Interreduce the elements of I such that no leading term is divisible by another leading term. This returns a new ideal and does not modify the input ideal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L709-L714">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (ZZ),(x,y),(dp(2),C), spoly{n_Z}[x, y])

julia&gt; I = Ideal(R, x^2 + 1, x*y)
Singular ideal over Singular polynomial ring (ZZ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)

julia&gt; n = number_of_generators(I)
2

julia&gt; p = I[1]
x^2 + 1

julia&gt; I[1] = 2x + y^2
y^2 + 2*x

julia&gt; is_constant(I) == false
true

julia&gt; is_var_generated(I) == false
true

julia&gt; is_zerodim(I) == false
ERROR: Not a Groebner basis

julia&gt; S, (u, v) = polynomial_ring(QQ, [&quot;u&quot;, &quot;v&quot;])
(Singular polynomial ring (QQ),(u,v),(dp(2),C), spoly{n_Q}[u, v])

julia&gt; J = Ideal(S, u^2 + 1, u*v)
Singular ideal over Singular polynomial ring (QQ),(u,v),(dp(2),C) with generators (u^2 + 1, u*v)

julia&gt; dimension(std(J)) == 0
true</code></pre><h3 id="Containment"><a class="docs-heading-anchor" href="#Containment">Containment</a><a id="Containment-1"></a><a class="docs-heading-anchor-permalink" href="#Containment" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.contains-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem" href="#Base.contains-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>Base.contains</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contains(I::sideal{S}, J::sideal{S}) where S</code></pre><p>Return <code>true</code> if the ideal <span>$I$</span> contains the ideal <span>$J$</span>. This will be expensive if <span>$I$</span> is not a Groebner ideal, since its standard basis must be computed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x , y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, x^2 + 1, x*y)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)

julia&gt; J = Ideal(R, x^2 + 1)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1)

julia&gt; contains(I, J) == true
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L378-L399">source</a></section></article><h3 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h3><p>Checking whether two ideals are algebraically equal is very expensive, as it usually requires computing Groebner bases. Therefore we do not overload the <code>==</code> operator for ideals. Instead we have the following two functions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isequal-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)" href="#Base.isequal-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isequal(I1::sideal{S}, I2::sideal{S}) where S &lt;: SPolyUnion</code></pre><p>Return <code>true</code> if the given ideals have the same generators in the same order. Note that two algebraically equal ideals with different generators will return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L420-L425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.equal-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)" href="#Singular.equal-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)"><code>Singular.equal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equal(I1::sideal{S}, I2::sideal{S}) where S &lt;: SPolyUnion</code></pre><p>Return <code>true</code> if the two ideals are contained in each other, i.e. are the same ideal mathematically. This function should be called only as a last resort; it is exceptionally expensive to test equality of ideals! Do not define <code>==</code> as an alias for this function!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L435-L442">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x , y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, x^2 + 1, x*y)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)

julia&gt; J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + x*y + 1, x^2 - x*y + 1)

julia&gt; isequal(I, J) == false
true

julia&gt; equal(I, J) == true
true</code></pre><h3 id="Intersection"><a class="docs-heading-anchor" href="#Intersection">Intersection</a><a id="Intersection-1"></a><a class="docs-heading-anchor-permalink" href="#Intersection" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.intersection-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, sideal{S}}} where {T&lt;:AbstractAlgebra.RingElem, S&lt;:Union{spluralg{T}, spoly{T}}}" href="#Singular.intersection-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, sideal{S}}} where {T&lt;:AbstractAlgebra.RingElem, S&lt;:Union{spluralg{T}, spoly{T}}}"><code>Singular.intersection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersection(I::sideal{S}, J::sideal{S}) where {T &lt;: Nemo.RingElem, S &lt;: Union{spoly{T}, spluralg{T}}}</code></pre><p>Return the intersection of the two given ideals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x , y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, x^2 + 1, x*y)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)

julia&gt; J = Ideal(R, x^2 + x*y + 1, x^2 - x*y + 1)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + x*y + 1, x^2 - x*y + 1)

julia&gt; V = intersection(I, J)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (y, x^2 - x*y + 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L484-L503">source</a></section></article><h3 id="Quotient"><a class="docs-heading-anchor" href="#Quotient">Quotient</a><a id="Quotient-1"></a><a class="docs-heading-anchor-permalink" href="#Quotient" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.quotient-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:spoly" href="#Singular.quotient-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:spoly"><code>Singular.quotient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quotient(I::sideal{S}, J::sideal{S}) where S &lt;: spoly</code></pre><p>Return the quotient of the two given ideals. Recall that the ideal quotient <span>$(I:J)$</span> over a polynomial ring <span>$R$</span> is defined by <span>$\{r \in R \;|\; rJ \subseteq I\}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x , y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, x^2 + 1, x*y)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)

julia&gt; J = Ideal(R, x + y)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x + y)

julia&gt; V = quotient(I, J)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (y, x^2 + 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L535-L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.quotient-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:spluralg" href="#Singular.quotient-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:spluralg"><code>Singular.quotient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quotient(I::sideal{S}, J::sideal{S}) where S &lt;: spluralg</code></pre><p>Return the quotient of the two given ideals, where <span>$J$</span> must be two-sided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L564-L568">source</a></section></article><h3 id="Leading-terms"><a class="docs-heading-anchor" href="#Leading-terms">Leading terms</a><a id="Leading-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Leading-terms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.lead-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)" href="#Singular.lead-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)"><code>Singular.lead</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lead(I::sideal{S}) where S &lt;: SPolyUnion</code></pre><p>Return the ideal generated by the leading terms of the polynomials generating <span>$I$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x , y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, x^2 + 1, x*y)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + 1, x*y)

julia&gt; V = lead(I)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2, x*y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L454-L471">source</a></section></article><h3 id="Homogeneous-ideals"><a class="docs-heading-anchor" href="#Homogeneous-ideals">Homogeneous ideals</a><a id="Homogeneous-ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Homogeneous-ideals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.is_homogeneous-Tuple{sideal}" href="#Singular.is_homogeneous-Tuple{sideal}"><code>Singular.is_homogeneous</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_homogeneous(I::sideal)</code></pre><p>Return <code>true</code> if each stored generator of <code>I</code> is homogeneous, otherwise <code>false</code>. If <code>base_ring(I)</code> has a weighted monomial ordering, the test is conducted with respect to the corresponding weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L170-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.homogenize-Union{Tuple{S}, Tuple{sideal{S}, S}} where S&lt;:spoly" href="#Singular.homogenize-Union{Tuple{S}, Tuple{sideal{S}, S}} where S&lt;:spoly"><code>Singular.homogenize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">homogenize(I::sideal{S}, v::S) where S &lt;: spoly</code></pre><p>Multiply each monomial in the generators of <code>I</code> by a suitable power of the variable <code>v</code> and return the corresponding homogeneous ideal. The variable <code>v</code> must have weight <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L183-L189">source</a></section></article><h3 id="Saturation"><a class="docs-heading-anchor" href="#Saturation">Saturation</a><a id="Saturation-1"></a><a class="docs-heading-anchor-permalink" href="#Saturation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.saturation-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.saturation-Union{Tuple{T}, Tuple{sideal{T}, sideal{T}}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.saturation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">saturation(I::sideal{T}, J::sideal{T}) where T &lt;: Nemo.RingElem</code></pre><p>Return the saturation of the ideal <span>$I$</span> with respect to <span>$J$</span>, i.e. returns the quotient ideal <span>$(I:J^\infty)$</span> and the number of iterations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, (x^2 + x*y + 1)*(2y^2+1)^3, (2y^2 + 3)*(2y^2+1)^2)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (8*x^2*y^6 + 8*x*y^7 + 12*x^2*y^4 + 12*x*y^5 + 8*y^6 + 6*x^2*y^2 + 6*x*y^3 + 12*y^4 + x^2 + x*y + 6*y^2 + 1, 8*y^6 + 20*y^4 + 14*y^2 + 3)

julia&gt; J = Ideal(R, 2y^2 + 1)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 1)

julia&gt; S = saturation(I, J)
(Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 3, x^2 + x*y + 1), 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L583-L603">source</a></section></article><h3 id="Standard-basis"><a class="docs-heading-anchor" href="#Standard-basis">Standard basis</a><a id="Standard-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-basis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.std-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)" href="#Statistics.std-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">std(I::sideal{S}; complete_reduction::Bool=false) where S &lt;: SPolyUnion</code></pre><p>Compute a Groebner basis for the ideal <span>$I$</span>. Note that without <code>complete_reduction</code> set to <code>true</code>, the generators of the Groebner basis only have unique leading terms (up to permutation and multiplication by constants). If <code>complete_reduction</code> is set to <code>true</code> (and the ordering is a global ordering) then the Groebner basis is unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L658-L666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.fglm-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Symbol}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.fglm-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Symbol}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.fglm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fglm(I::sideal{spoly{T}}, ordering::Symbol) where T &lt;: Nemo.RingElem</code></pre><p>Compute a Groebner basis for the zero - dimensional ideal <span>$I$</span> in the ring <span>$R$</span> using the FGLM algorithm. All involved orderings have to be global.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L741-L746">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.satstd-Union{Tuple{T}, Tuple{sideal{spoly{T}}, sideal{spoly{T}}}} where T&lt;:AbstractAlgebra.FieldElem" href="#Singular.satstd-Union{Tuple{T}, Tuple{sideal{spoly{T}}, sideal{spoly{T}}}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.satstd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">satstd(I::sideal{spoly{T}}, J::sideal{spoly{T}} = Ideal(base_ring(I), gens(base_ring(I)))) where T &lt;: Nemo.RingElem</code></pre><p>Given an ideal <span>$J$</span> generated by variables, computes a standard basis of <code>saturation(I, J)</code>. This is accomplished by dividing polynomials that occur throughout the std computation by variables occurring in <span>$J$</span>, where possible. Thus the result can be obtained faster than by first computing the saturation and then the standard basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L723-L731">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.lift_std-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:spoly" href="#Singular.lift_std-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:spoly"><code>Singular.lift_std</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lift_std(M::sideal{S}; complete_reduction::Bool = false) where S &lt;: spoly</code></pre><p>Computes the Groebner base G of M and the transformation matrix T such that (Matrix(G) = Matrix(M) * T)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1045-L1050">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.lift_std_syz-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:spoly" href="#Singular.lift_std_syz-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:spoly"><code>Singular.lift_std_syz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lift_std_syz(M::sideal{S}; complete_reduction::Bool = false) where S &lt;: spoly</code></pre><p>Computes the Groebner base G of I, the transformation matrix T and the syzygies of M. Returns G,T,S (Matrix(G) = Matrix(I) * T, 0=Matrix(M)*Matrix(S))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1032-L1038">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, x^2 + x*y + 1, 2y^2 + 3)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2 + x*y + 1, 2*y^2 + 3)

julia&gt; J = Ideal(R, 2*y^2 + 3, x^2 + x*y + 1)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 3, x^2 + x*y + 1)

julia&gt; A = std(I)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*y^2 + 3, x^2 + x*y + 1)

julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, (x*y + 1)*(2x^2*y^2 + x*y - 2) + 2x*y^2 + x, 2x*y + 1)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (2*x^3*y^3 + 3*x^2*y^2 + 2*x*y^2 - x*y + x - 2, 2*x*y + 1)

julia&gt; J = Ideal(R, x)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x)

julia&gt; B = satstd(I, J)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x - y - 1, 2*y^2 + 2*y + 1)

julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], ordering = :lex)
(Singular polynomial ring (QQ),(x,y,z),(lp(3),C), spoly{n_Q}[x, y, z])

julia&gt; I = Ideal(R, y^3+x^2, x^2*y+x^2, x^3-x^2, z^4-x^2-y)
Singular ideal over Singular polynomial ring (QQ),(x,y,z),(lp(3),C) with generators (x^2 + y^3, x^2*y + x^2, x^3 - x^2, -x^2 - y + z^4)

julia&gt; J = fglm(I, :degrevlex)
Singular ideal over Singular polynomial ring (QQ),(x,y,z),(lp(3),C) with generators (z^12, y*z^4 - z^8, y^2 + y - z^8 - z^4, x*y - x*z^4 - y + z^4, x^2 + y - z^4)</code></pre><h3 id="Reduction"><a class="docs-heading-anchor" href="#Reduction">Reduction</a><a id="Reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)" href="#Base.reduce-Union{Tuple{S}, Tuple{sideal{S}, sideal{S}}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce(I::sideal{S}, G::sideal{S}) where S &lt;: SPolyUnion</code></pre><p>Return an ideal whose generators are the generators of <span>$I$</span> reduced by the ideal <span>$G$</span>. The ideal <span>$G$</span> need not be a Groebner basis. The returned ideal will have the same number of generators as <span>$I$</span>, even if they are zero. For PLURAL rings (S &lt;: spluralg, GAlgebra, WeylAlgebra), the reduction is only a left reduction, and hence cannot be used to test containment in a two-sided ideal. For LETTERPLACE rings (S &lt;: slpalg, FreeAlgebra), the reduction is two-sided as only two-sided ideals can be constructed here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L770-L780">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Union{Tuple{S}, Tuple{S, sideal{S}}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)" href="#Base.reduce-Union{Tuple{S}, Tuple{S, sideal{S}}} where S&lt;:(Union{slpalg{T}, spluralg{T}, spoly{T}} where T&lt;:AbstractAlgebra.RingElem)"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce(p::S, G::sideal{S}) where S &lt;: SPolyUnion</code></pre><p>Return the polynomial which is <span>$p$</span> reduced by the polynomials generating <span>$G$</span>. The ideal <span>$G$</span> need not be a Groebner basis. For PLURAL rings (S &lt;: spluralg, GAlgebra, WeylAlgebra), the reduction is only a left reduction, and hence cannot be used to test membership in a two-sided ideal. For LETTERPLACE rings (S &lt;: slpalg, FreeAlgebra), the reduction is the full two-sided reduction as only two-sided ideals can be constructed here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L792-L801">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; f = x^2*y + 2y + 1
x^2*y + 2*y + 1

julia&gt; g = y^2 + 1
y^2 + 1

julia&gt; I = Ideal(R, (x^2 + 1)*f + (x + y)*g + x + 1, (2y^2 + x)*f + y)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^4*y + 3*x^2*y + x*y^2 + y^3 + x^2 + 2*x + 3*y + 2, 2*x^2*y^3 + x^3*y + 4*y^3 + 2*x*y + 2*y^2 + x + y)

julia&gt; J = std(Ideal(R, f, g))
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (y^2 + 1, x^2 - y + 2)

julia&gt; V = reduce(I, J)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x + 1, y)

julia&gt; h1 = (x^2 + 1)*f + (x + y)*g + x + 1
x^4*y + 3*x^2*y + x*y^2 + y^3 + x^2 + 2*x + 3*y + 2

julia&gt; h2 = reduce(h1, J)
x + 1</code></pre><h3 id="Elimination"><a class="docs-heading-anchor" href="#Elimination">Elimination</a><a id="Elimination-1"></a><a class="docs-heading-anchor-permalink" href="#Elimination" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.eliminate-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, Vararg{S}}} where {T&lt;:AbstractAlgebra.RingElem, S&lt;:Union{spluralg{T}, spoly{T}}}" href="#Singular.eliminate-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, Vararg{S}}} where {T&lt;:AbstractAlgebra.RingElem, S&lt;:Union{spluralg{T}, spoly{T}}}"><code>Singular.eliminate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eliminate(I::sideal{S}, polys::S...) where {T &lt;: Nemo.RingElem, S &lt;: Union{spoly{T}, spluralg{T}}}</code></pre><p>Given a list of polynomials which are variables, construct the ideal corresponding geometrically to the projection of the variety given by the ideal <span>$I$</span> where those variables have been eliminated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, t) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;t&quot;])
(Singular polynomial ring (QQ),(x,y,t),(dp(3),C), spoly{n_Q}[x, y, t])

julia&gt; I = Ideal(R, x - t^2, y - t^3)
Singular ideal over Singular polynomial ring (QQ),(x,y,t),(dp(3),C) with generators (-t^2 + x, -t^3 + y)

julia&gt; J = eliminate(I, t)
Singular ideal over Singular polynomial ring (QQ),(x,y,t),(dp(3),C) with generators (x^3 - y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L884-L902">source</a></section></article><h3 id="Syzygies"><a class="docs-heading-anchor" href="#Syzygies">Syzygies</a><a id="Syzygies-1"></a><a class="docs-heading-anchor-permalink" href="#Syzygies" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.syz-Tuple{sideal}" href="#Singular.syz-Tuple{sideal}"><code>Singular.syz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syz(I::sideal)</code></pre><p>Compute the module of syzygies of the ideal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2*y + 2*y + 1, y^2 + 1)

julia&gt; F = syz(I)
Singular module over Singular polynomial ring (QQ),(x,y),(dp(2),C), with generators:
x^2*y*gen(2)-y^2*gen(1)+2*y*gen(2)+gen(2)-gen(1)

julia&gt; M = Singular.Matrix(I)
[x^2*y + 2*y + 1, y^2 + 1]

julia&gt; N = Singular.Matrix(F)
[-y^2 - 1
x^2*y + 2*y + 1]

julia&gt; iszero(M*N)  # check they are actually syzygies
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L937-L964">source</a></section></article><h3 id="Free-resolutions"><a class="docs-heading-anchor" href="#Free-resolutions">Free resolutions</a><a id="Free-resolutions-1"></a><a class="docs-heading-anchor-permalink" href="#Free-resolutions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.fres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64, String}} where T&lt;:AbstractAlgebra.FieldElem" href="#Singular.fres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64, String}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.fres</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fres(id::sideal{spoly{T}}, max_length::Int, method::String=&quot;complete&quot;) where T &lt;: Nemo.FieldElem</code></pre><p>Compute a free resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The possible methods are &quot;complete&quot;, &quot;frame&quot;, &quot;extended frame&quot; and &quot;single module&quot;. The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal/module. The <code>max_length</code> can be set to <span>$0$</span> if the full free resolution is required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1063-L1074">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.sres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64}} where T&lt;:AbstractAlgebra.FieldElem" href="#Singular.sres-Union{Tuple{T}, Tuple{sideal{spoly{T}}, Int64}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.sres</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sres(id::sideal{spoly{T}}, max_length::Int) where T &lt;: Nemo.FieldElem</code></pre><p>Compute a (free) Schreyer resolution of the given ideal up to the maximum given length. The ideal must be over a polynomial ring over a field, and a Groebner basis. The result is given as a resolution, whose i-th entry is the syzygy module of the previous module, starting with the given ideal. The <code>max_length</code> can be set to <span>$0$</span> if the full free resolution is required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1093-L1101">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Singular polynomial ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, x^2*y + 2y + 1, y^2 + 1)
Singular ideal over Singular polynomial ring (QQ),(x,y),(dp(2),C) with generators (x^2*y + 2*y + 1, y^2 + 1)

julia&gt; F1 = fres(std(I), 0)
Singular resolution: R^1 &lt;- R^2 &lt;- R^1

julia&gt; F2 = sres(std(I), 2)
Singular resolution: R^1 &lt;- R^2 &lt;- R^1</code></pre><h3 id="Differential-operations"><a class="docs-heading-anchor" href="#Differential-operations">Differential operations</a><a id="Differential-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-operations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.jet-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, Int64}} where {T&lt;:AbstractAlgebra.RingElem, S&lt;:Union{spluralg{T}, spoly{T}}}" href="#Singular.jet-Union{Tuple{S}, Tuple{T}, Tuple{sideal{S}, Int64}} where {T&lt;:AbstractAlgebra.RingElem, S&lt;:Union{spluralg{T}, spoly{T}}}"><code>Singular.jet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jet(I::sideal{S}, n::Int) where {T &lt;: Nemo.RingElem, S &lt;: Union{spoly{T}, spluralg{T}}}</code></pre><p>Given an ideal <span>$I$</span> this function truncates the generators of <span>$I$</span> up to degree <span>$n$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Singular polynomial ring (QQ),(x,y,z),(dp(3),C), spoly{n_Q}[x, y, z])

julia&gt; I = Ideal(R, x^5 - y^2, y^3 - x^6 + z^3)
Singular ideal over Singular polynomial ring (QQ),(x,y,z),(dp(3),C) with generators (x^5 - y^2, -x^6 + y^3 + z^3)

julia&gt; J1 = jet(I, 3)
Singular ideal over Singular polynomial ring (QQ),(x,y,z),(dp(3),C) with generators (-y^2, y^3 + z^3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1233-L1250">source</a></section></article><h3 id="Operations-on-zero-dimensional-ideals"><a class="docs-heading-anchor" href="#Operations-on-zero-dimensional-ideals">Operations on zero-dimensional ideals</a><a id="Operations-on-zero-dimensional-ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-zero-dimensional-ideals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.vdim-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T&lt;:AbstractAlgebra.FieldElem, S&lt;:Union{spluralg{T}, spoly{T}}}" href="#Singular.vdim-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T&lt;:AbstractAlgebra.FieldElem, S&lt;:Union{spluralg{T}, spoly{T}}}"><code>Singular.vdim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vdim(I::sideal{S}) where {T &lt;: Nemo.FieldElem, S &lt;: Union{spoly{T}, spluralg{T}}}</code></pre><p>Given a zero-dimensional ideal <span>$I$</span> this function computes the dimension of the vector space <code>base_ring(I)/I</code>, where <code>base_ring(I)</code> must be a polynomial ring over a field, and <span>$I$</span> must be a Groebner basis. The return is <span>$-1$</span> if <code>!is_zerodim(I)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1264-L1271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.kbase-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T&lt;:AbstractAlgebra.FieldElem, S&lt;:Union{spluralg{T}, spoly{T}}}" href="#Singular.kbase-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T&lt;:AbstractAlgebra.FieldElem, S&lt;:Union{spluralg{T}, spoly{T}}}"><code>Singular.kbase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kbase(I::sideal{S}) where {T &lt;: Nemo.FieldElem, S &lt;: Union{spoly{T}, spluralg{T}}}</code></pre><p>Given a zero-dimensional ideal <span>$I$</span> this function computes a vector space basis of the vector space <code>base_ring(I)/I</code>, where <code>base_ring(I)</code> must be a polynomial ring over a field, and <span>$I$</span> must be a Groebner basis. The array of vector space basis elements is returned as a Singular ideal, and this array consists of one zero polynomial if <code>!is_zerodim(I)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1279-L1287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.highcorner-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T&lt;:AbstractAlgebra.FieldElem, S&lt;:Union{spluralg{T}, spoly{T}}}" href="#Singular.highcorner-Union{Tuple{sideal{S}}, Tuple{S}, Tuple{T}} where {T&lt;:AbstractAlgebra.FieldElem, S&lt;:Union{spluralg{T}, spoly{T}}}"><code>Singular.highcorner</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">highcorner(I::sideal{S}) where {T &lt;: Nemo.FieldElem, S &lt;: Union{spoly{T}, spluralg{T}}}</code></pre><p>Given a zero-dimensional ideal <span>$I$</span> this function computes its highest corner, which is a polynomial. The ideal must be over a polynomial ring over a field, and a Groebner basis. The return is the zero polynomial if <code>!is_zerodim(I)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1314-L1321">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]; ordering=:negdegrevlex)
(Singular polynomial ring (QQ),(x,y),(ds(2),C), spoly{n_Q}[x, y])

julia&gt; I = Ideal(R, 3*x^2 + y^3, x*y^2)
Singular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (3*x^2 + y^3, x*y^2)

julia&gt; I = std(I)
Singular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (3*x^2 + y^3, x*y^2, y^5)

julia&gt; n = vdim(I)
7

julia&gt; J = kbase(I)
Singular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (y^4, y^3, y^2, x*y, y, x, 1)

julia&gt; f = highcorner(I)
y^4</code></pre><h3 id="Operations-over-local-rings"><a class="docs-heading-anchor" href="#Operations-over-local-rings">Operations over local rings</a><a id="Operations-over-local-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-over-local-rings" title="Permalink"></a></h3><p>If the base ring <code>R</code> is a local ring, a minimal generating set can be computed using the following function</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.minimal_generating_set-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:spoly" href="#Singular.minimal_generating_set-Union{Tuple{sideal{S}}, Tuple{S}} where S&lt;:spoly"><code>Singular.minimal_generating_set</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimal_generating_set(I::sideal{S}) where S &lt;: spoly</code></pre><p>Given an ideal <span>$I$</span> in ring <span>$R$</span> with local ordering, this returns an array containing the minimal generators of <span>$I$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1336-L1341">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]; ordering=:negdegrevlex)
(Singular polynomial ring (QQ),(x,y),(ds(2),C), spoly{n_Q}[x, y])

julia&gt; has_local_ordering(R) == true
true

julia&gt; I = Ideal(R, y, x^2, (1 + y^3) * (x^2 - y))
Singular ideal over Singular polynomial ring (QQ),(x,y),(ds(2),C) with generators (y, x^2, -y + x^2 - y^4 + x^2*y^3)

julia&gt; min = minimal_generating_set(I)
2-element Vector{spoly{n_Q}}:
 x^2
 y</code></pre><h3 id="Independent-sets-of-monomial-ideals"><a class="docs-heading-anchor" href="#Independent-sets-of-monomial-ideals">Independent sets of monomial ideals</a><a id="Independent-sets-of-monomial-ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-sets-of-monomial-ideals" title="Permalink"></a></h3><p>Let <span>$I$</span> be an ideal of <span>$K[x_1, ..., x_n].$</span> An <code>independent set</code> is a subset <span>$u \subseteq \{x_1, ..., x_n\},$</span> such that <span>$I \cap K[u]= 0.$</span> In case <span>$u$</span> cannot be enlarged, it is called <code>non-extendable independent set</code>. If in addition <span>$|u| = dim(K[x_1, ..., x_n]/I),$</span> <span>$u$</span> is called <code>maximal independent set</code>. Using Singular.jl one can compute non-extendable, resp. maximal independent sets for monomial ideals. If an arbitrary ideal <span>$I$</span> is passed to the function, the computation is performed on the leading ideal of <span>$I$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.independent_sets-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.FieldElem" href="#Singular.independent_sets-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.independent_sets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">independent_sets(I::sideal{spoly{T}}) where T &lt;: Nemo.FieldElem</code></pre><p>Return all non-extendable independent sets of <span>$lead(I)$</span>. <span>$I$</span> has to be given by a Groebner basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1357-L1362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Singular.maximal_independent_set-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.FieldElem" href="#Singular.maximal_independent_set-Union{Tuple{sideal{spoly{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.FieldElem"><code>Singular.maximal_independent_set</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maximal_independent_set(I::sideal{spoly{T}}; all::Bool = false) where T &lt;: Nemo.FieldElem</code></pre><p>Returns, by default, an array containing a maximal independent set of <span>$lead(I)$</span>. <span>$I$</span> has to be given by a Groebner basis. If the additional parameter &quot;all&quot; is set to true, an array containing all maximal independent sets of <span>$lead(I)$</span> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Singular.jl/blob/9d9b9756549fd6594f1fd555039650d19c11652f/src/ideal/ideal.jl#L1382-L1389">source</a></section></article><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, u, v, w) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;])
(Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C), spoly{n_Q}[x, y, u, v, w])

julia&gt; has_local_ordering(R) == true
false

julia&gt; I = Ideal(R, x*y*w, y*v*w, u*y*w, x*v)
Singular ideal over Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C) with generators (x*y*w, y*v*w, y*u*w, x*v)

julia&gt; I = std(I)
Singular ideal over Singular polynomial ring (QQ),(x,y,u,v,w),(dp(5),C) with generators (x*v, y*v*w, y*u*w, x*y*w)

julia&gt; L1 = independent_sets(I)
5-element Vector{Vector{spoly{n_Q}}}:
 [x, y, u]
 [y, u, v]
 [x, u, w]
 [u, v, w]
 [y, w]

julia&gt; L2 = maximal_independent_set(I)
3-element Vector{spoly{n_Q}}:
 x
 y
 u

julia&gt; L3 = maximal_independent_set(I, all = true)
4-element Vector{Vector{spoly{n_Q}}}:
 [x, y, u]
 [y, u, v]
 [x, u, w]
 [u, v, w]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../noncommutative/">« Noncommutative algebras</a><a class="docs-footer-nextpage" href="../qring/">Quotient Rings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 30 November 2024 03:16">Saturday 30 November 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
