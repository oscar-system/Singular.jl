<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Multivariate polynomials · Singular.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Singular.jl</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><span class="tocitem">Coefficient rings</span><ul><li><a class="tocitem" href="../integer/">Integers</a></li><li><a class="tocitem" href="../rational/">Rational field</a></li><li><a class="tocitem" href="../modn/">Integers mod n</a></li><li><a class="tocitem" href="../modp/">Integers mod p</a></li><li><a class="tocitem" href="../transExt/">Function fields</a></li><li><a class="tocitem" href="../GF/">Finite fields</a></li><li><a class="tocitem" href="../nemo/">Nemo rings and fields</a></li></ul></li><li class="is-active"><a class="tocitem" href="">Multivariate polynomials</a><ul class="internal"><li><a class="tocitem" href="#Multivariate-polynomial-functionality"><span>Multivariate polynomial functionality</span></a></li></ul></li><li><a class="tocitem" href="../ideal/">Ideals</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../module/">Finitely generated modules</a></li><li><a class="tocitem" href="../vector/">Free modules and vectors</a></li></ul></li><li><a class="tocitem" href="../alghom/">Algebra Homomorphisms</a></li><li><a class="tocitem" href="../resolution/">Resolutions</a></li><li><a class="tocitem" href="../matrix/">Matrices</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">Multivariate polynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Multivariate polynomials</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/polynomial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Multivariate-polynomials"><a class="docs-heading-anchor" href="#Multivariate-polynomials">Multivariate polynomials</a><a id="Multivariate-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-polynomials" title="Permalink"></a></h1><p>Singular.jl allows the creation of multivariate polynomials over any of the coefficient rings described above.</p><p>The default multivariate polynomial type in Singular.jl is the Singular <code>spoly</code> type.</p><p>The associated polynomial ring is represented by a parent object which can be constructed by a call to the <code>PolynomialRing</code> constructor.</p><p>The types of the polynomial ring parent objects and elements thereof are given in the following table according to the library providing them.</p><table><tbody><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Singular</td><td style="text-align: right"><code>spoly{T}</code></td><td style="text-align: right"><code>Singular.PolyRing{T}</code></td></tr></tbody></table><p>These types are parameterised by the type of elements in the coefficient ring of the polynomials.</p><p>All polynomial types belong directly to the abstract type <code>MPolyElem</code> and all the polynomial ring parent object types belong to the abstract type <code>MPolyRing</code>.</p><h2 id="Multivariate-polynomial-functionality"><a class="docs-heading-anchor" href="#Multivariate-polynomial-functionality">Multivariate polynomial functionality</a><a id="Multivariate-polynomial-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-polynomial-functionality" title="Permalink"></a></h2><p>Singular.jl polynomials implement the Multivariate Polynomial Ring interface of AbstractAlgebra.jl.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/mpolynomial_rings.html">https://nemocas.github.io/AbstractAlgebra.jl/mpolynomial_rings.html</a></p><p>In particular, Singular polynomials are sparse distributed, but do not have random access. Instead, they implement iterator access to terms. This is due to their storage in a linked list, for efficient implementation of Groebner basis algorithms.</p><p>Some polynomial rings may also implement part of the Euclidean Ring interface, where this is appropriate.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html">https://nemocas.github.io/AbstractAlgebra.jl/euclidean.html</a></p><p>Below, we describe the functionality that is specific to the Singular multivariate polynomials that is not documented in the general multivariate interface.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><pre><code class="language-julia">PolynomialRing(R::Union{Ring, Field}, s::Array{String, 1};
   cached::Bool = true, ordering::Symbol = :degrevlex,
      ordering2::Symbol = :comp1min, degree_bound::Int = 0)</code></pre><p>Returns a tuple, <span>$S, x$</span> consisting of a multivariate polynomial ring <span>$S$</span> and an array <span>$x$</span> of variables (from which polynomials can be constructed). The ring <span>$R$</span> must be a valid Singular coefficient ring, or any Nemo/AbstractAlgebra coefficient ring. The array <span>$s$</span> must be a list of strings corresponding to how the variables will be printed. By default, there will only be one Singular polynomial ring in the system for each combination of coefficient ring, list of variable names, ordering and degree bound. This is accomplished by making use of a global cache. If this is not the desired behaviour, <code>false</code> can be passed to the optional argument <code>cached</code>.</p><p>Two orderings can be specified, one for term ordering of the polynomials, and another for ordering of module components. They can occur in either order, the first taking precedence over the other, when the polynomials are used to represent module generators. If either is not specified, the indicated default is used.</p><p>The options for polynomial term ordering are the symbols, <code>:lex</code>, <code>:deglex</code>, <code>:degrevlex</code>, <code>:neglex</code>, <code>:negdeglex</code> and <code>:negdegrevlex</code>, and the options for module component ordering are <code>comp1min</code> and <code>comp1max</code>.</p><p>If one has an a priori bound on the degree in each variable of a polynomial (including for all intermediate computations in this ring), one can specify it using the <code>degree_bound</code> optional parameter. Singular may then be able to use a more efficient representation internally, which will use less memory and allow for faster arithmetic. By default, Singular uses a bound of 16 bits internally for the exponent of each variable, however this is a signed value, so that the default is for nonnegative exponents that fit in 15 bits.</p><p>Note that internally, Singular may use a higher bound than specified, if it will not increase the amount of storage required.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, z) = PolynomialRing(ZZ, ["x", "y", "z"])

S, vars = PolynomialRing(QQ, ["x", "y"]; ordering=:deglex)

T, x = PolynomialRing(ZZ, ["x$i" for i in 1:5];
       ordering=:comp1max, ordering2=:degrevlex, degree_bound=5)</code></pre><p>See also the convenience macros below for simple use cases.</p><p>The following function allows creating a Singular polynomial ring from a given polynomial ring of type AbstractAlgebra.Generic.MPolyRing:</p><pre><code class="language-julia">PolynomialRing(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true, ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min, degree_bound::Int = 0)  where {T &lt;: RingElement}</code></pre><p>Polynomials can be constructed using arithmetic operations on the generators, but this can be extremely inefficient. For this purpose, Singular polynomials support construction using a build context, as described in the AbstractAlgebra documentation:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/mpolynomial_rings.html">https://nemocas.github.io/AbstractAlgebra.jl/mpolynomial_rings.html</a></p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])
C = MPolyBuildCtx(R)

push_term!(C, ZZ(1), [1, 2])
push_term!(C, ZZ(3), [1, 1])
push_term!(C, -ZZ(1), [0, 1])
f = finish(C)</code></pre><h3 id="Polynomial-ring-macros"><a class="docs-heading-anchor" href="#Polynomial-ring-macros">Polynomial ring macros</a><a id="Polynomial-ring-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-ring-macros" title="Permalink"></a></h3><p>For convenience, we provide some macros for constructing polynomial rings and injecting the variables into scope. These are easier to use, but have some limitations. In particular, they can only be used at the top level by the user, and cannot be used programmatically or in library code (it is not possible to inject an arbitrary number of variables into scope inside a function).</p><p>The macros are designed for simple use cases, and do not offer the full power of the most general constructor above.</p><pre><code class="language-julia">@PolynomialRing(R, s, n, o)</code></pre><p>Given a coefficient ring <span>$R$</span>, a root variable name, e.g. <code>"x"</code>, a number of variable <span>$n$</span> and a polynomial term ordering <code>o</code>, create the variables <code>x1, x2, ..., xn</code> and inject them into scope, and return the corresponding polynomial ring <code>S</code>.</p><pre><code class="language-julia">@PolynomialRing(R, s, n)</code></pre><p>As per the previous macro, with a default of <code>:degrevlex</code> for the polynomial term ordering.</p><p><strong>Examples</strong></p><pre><code class="language-julia">S = @PolynomialRing(ZZ, "x", 5, :deglex)

T = @PolynomialRing(QQ, "y", 10)</code></pre><h3 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.nvars-Tuple{PolyRing}" id="AbstractAlgebra.Generic.nvars-Tuple{PolyRing}"><code>AbstractAlgebra.Generic.nvars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nvars(R::PolyRing)</code></pre><p>Return the number of variables in the given polynomial ring.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L29" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.symbols-Tuple{PolyRing}" id="AbstractAlgebra.Generic.symbols-Tuple{PolyRing}"><code>AbstractAlgebra.Generic.symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symbols(R::PolyRing)</code></pre><p>Return symbols for the generators of the polynomial ring <span>$R$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L82" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.has_global_ordering-Tuple{PolyRing}" id="Singular.has_global_ordering-Tuple{PolyRing}"><code>Singular.has_global_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_global_ordering(R::PolyRing)</code></pre><p>Return <code>true</code> if the given ring has a global ordering, i.e. if <span>$1 &lt; x$</span> for each variable <span>$x$</span> in the ring. This include <code>:lex</code>, <code>:deglex</code> and <code>:degrevlex</code> orderings.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L36" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.has_mixed_ordering-Tuple{PolyRing}" id="Singular.has_mixed_ordering-Tuple{PolyRing}"><code>Singular.has_mixed_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_mixed_ordering(R::PolyRing)</code></pre><p>Return <code>true</code> if the given ring has a mixed ordering, i.e. if <span>$1 &lt; x_i$</span> for a variable <span>$x_i$</span> and <span>$1&gt;x_j$</span> for another variable <span>$x_j$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L45" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.has_local_ordering-Tuple{PolyRing}" id="Singular.has_local_ordering-Tuple{PolyRing}"><code>Singular.has_local_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_local_ordering(R::PolyRing)</code></pre><p>Return <code>true</code> if the given ring has a local ordering, i.e. if <span>$1 &gt; x$</span> for all variables <span>$x$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L53" target="_blank">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Singular.characteristic(R::PolyRing)</code>. Check Documenter's build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" href="#Singular.degree_bound-Tuple{PolyRing}" id="Singular.degree_bound-Tuple{PolyRing}"><code>Singular.degree_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degree_bound(R::PolyRing)</code></pre><p>Return the internal degree bound in each variable, enforced by Singular. This is the largest positive value any degree can have before an overflow will occur. This internal bound may be higher than the bound requested by the user via the <code>degree_bound</code> parameter of the <code>PolynomialRing</code> constructor.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L93" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.lead_exponent-Tuple{spoly}" id="Singular.lead_exponent-Tuple{spoly}"><code>Singular.lead_exponent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lead_exponent(p::spoly)</code></pre><p>Return the exponent vector of the leading term of the given polynomial. The return value is a Julia 1-dimensional array giving the exponent for each variable of the leading term.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L192" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.total_degree-Tuple{spoly}" id="AbstractAlgebra.Generic.total_degree-Tuple{spoly}"><code>AbstractAlgebra.Generic.total_degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">total_degree(p::spoly)</code></pre><p>Return the total degree (largest sum of exponents of any monomial) of <span>$p$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L159" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.order-Tuple{spoly}" id="AbstractAlgebra.Generic.order-Tuple{spoly}"><code>AbstractAlgebra.Generic.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order(p::spoly)</code></pre><p>Returns the order of <span>$p$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L169" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-none">R = @PolynomialRing(ZZ, "x", 3)

n = ngens(R)
has_global_ordering(R) == true
c = characteristic(R)
L = degree_bound(R)
exps = lead_exponent(x1*x2 + 3x1*x2^2 + x3 + 2)
deg = total_degree(x1*x2 + 3x1*x2^2 + x3 + 2)
ord = order(x1*x2 + 3x1*x2^2 + x3 + 2)</code></pre><h3 id="Differential-functions"><a class="docs-heading-anchor" href="#Differential-functions">Differential functions</a><a id="Differential-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-functions" title="Permalink"></a></h3><p>Working over any coefficient ring, basic functionality involving differential operations is available.</p><article class="docstring"><header><a class="docstring-binding" href="#Singular.jet-Tuple{spoly,Int64}" id="Singular.jet-Tuple{spoly,Int64}"><code>Singular.jet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>jet(x::spoly, n::Int) Given a polynomial <span>$x$</span> this function truncates <span>$x$</span> up to degree <span>$n$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L846" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.derivative-Tuple{spoly,Int64}" id="AbstractAlgebra.Generic.derivative-Tuple{spoly,Int64}"><code>AbstractAlgebra.Generic.derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative(x::spoly, n::Int) Given a polynomial <span>$x$</span> this function returns the derivative of <span>$x$</span> with respect to the variable with number <span>$n$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L856" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.derivative-Tuple{spoly,spoly}" id="AbstractAlgebra.Generic.derivative-Tuple{spoly,spoly}"><code>AbstractAlgebra.Generic.derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative(x::spoly, v::spoly) Given a polynomial <span>$x$</span> this function returns the derivative of <span>$x$</span> with respect to the variable <span>$v$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L872" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.jacobian_ideal-Tuple{spoly}" id="Singular.jacobian_ideal-Tuple{spoly}"><code>Singular.jacobian_ideal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>jacobian_ideal(x::spoly) Given a polynomial <span>$x$</span> this function returns the Jacobian ideal of <span>$x$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L888" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.jacobian_matrix-Tuple{spoly}" id="Singular.jacobian_matrix-Tuple{spoly}"><code>Singular.jacobian_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>jacobian_matrix(x::spoly) Given a polynomial <span>$x$</span> this function returns the Jacobian matrix of <span>$x$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L903" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.jacobian_matrix-Union{Tuple{Array{spoly{T},1}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" id="Singular.jacobian_matrix-Union{Tuple{Array{spoly{T},1}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.jacobian_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>jacobian_matrix(A::Vector{spoly, 1}) Given an array <span>$A$</span> of polynomials over the same base ring, this function returns the Jacobian matrix of <span>$A$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L917" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, z) = PolynomialRing(QQ, ["x", "y", "z"])

f = x^2*y*z + z^2*x + x*y*z

g = jet(f, 3)

derivative(f, 1)

derivative(f, y)

J = jacobian_ideal(f)

Jf1 = jacobian_matrix(f)

Jf2 = jacobian_matrix([f, g])</code></pre><h3 id="Content-and-primitive-part"><a class="docs-heading-anchor" href="#Content-and-primitive-part">Content and primitive part</a><a id="Content-and-primitive-part-1"></a><a class="docs-heading-anchor-permalink" href="#Content-and-primitive-part" title="Permalink"></a></h3><p>When coefficient rings have a meaningful GCD function, the following functions are available.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.primpart-Tuple{spoly}" id="AbstractAlgebra.Generic.primpart-Tuple{spoly}"><code>AbstractAlgebra.Generic.primpart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primpart(x::spoly)</code></pre><p>Return the primitive part of the polynomial, i.e. the polynomial divided by the GCD of its coefficients.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L572" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.content-Tuple{spoly}" id="AbstractAlgebra.Generic.content-Tuple{spoly}"><code>AbstractAlgebra.Generic.content</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">content(x::spoly)</code></pre><p>Return the content of the polynomial, i.e. the GCD of its coefficients.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L585" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R = @PolynomialRing(ZZ, "x", 2)

f = 3x1^2 + 3x1*x2 + 6x2^2

p = primpart(f)
c = content(f)</code></pre><h3 id="Multivariate-Factorisation"><a class="docs-heading-anchor" href="#Multivariate-Factorisation">Multivariate Factorisation</a><a id="Multivariate-Factorisation-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Factorisation" title="Permalink"></a></h3><p>For the Singular base fields <code>QQ</code> and <code>Fp</code> a function to compute a squarefree factorization is available.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.factor_squarefree-Tuple{spoly}" id="AbstractAlgebra.factor_squarefree-Tuple{spoly}"><code>AbstractAlgebra.factor_squarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_squarefree(x::spoly)</code></pre><p>Returns a squarefree factorization of <span>$x$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L688" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R = @PolynomialRing(QQ, "x", 4)

f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2

Fac = factor(f)</code></pre><p>For the Singular base rings <code>QQ</code>, <code>ZZ</code> and <code>Fp</code> a function to compute the multivariate factorization is available.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.factor-Tuple{spoly}" id="AbstractAlgebra.factor-Tuple{spoly}"><code>AbstractAlgebra.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(x::spoly)</code></pre><p>Returns the factorization of <span>$x$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L717" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R = @PolynomialRing(ZZ, "x", 4)

f = 123*(57*x2^3 + x4^5)^3*(x1^2 + x1+1)^2*(x1 + x2*x3)^2

Fac = factor(f)</code></pre><h3 id="Change-of-coefficient-rings"><a class="docs-heading-anchor" href="#Change-of-coefficient-rings">Change of coefficient rings</a><a id="Change-of-coefficient-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Change-of-coefficient-rings" title="Permalink"></a></h3><p>It is possible to change the coefficient ring of a given polynomial <span>$p$</span> via the function 'change<em>base</em>ring'.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.change_base_ring-Tuple{Union{Singular.Field, Singular.Ring},spoly}" id="AbstractAlgebra.change_base_ring-Tuple{Union{Singular.Field, Singular.Ring},spoly}"><code>AbstractAlgebra.change_base_ring</code></a> — <span class="docstring-category">Method</span></header><section><div><p>change<em>base</em>ring(C::T, p::spoly) where T &lt;: Union{Ring, Field}</p><blockquote><p>Return a polynomial ring, whose coefficient ring is subsituted by the ring <span>$C$</span>.</p></blockquote></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L995" target="_blank">source</a></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])

p = x^5 + y^3+1

change_base_ring(QQ, p)</code></pre><p>It also possible to work with Nemo rings, if a type conversion for the Singular coefficients is implemented. One has to cast the Nemo ring via 'CoefficientRing' to a suitable Singular type.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, ["x", "y"])

p = x^5 + y^3+1

change_base_ring(CoefficientRing(Nemo.QQ), p)</code></pre><h3 id="Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials"><a class="docs-heading-anchor" href="#Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials">Conversion between Singular.jl polynomials and MPoly polynomials</a><a id="Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-between-Singular.jl-polynomials-and-MPoly-polynomials" title="Permalink"></a></h3><p>There are conversion functions between the polynomial ring implementation from Singular.jl and the generic MPoly implementation from AbstractAlgebra.jl.</p><article class="docstring"><header><a class="docstring-binding" href="#Singular.AsEquivalentSingularPolynomialRing-Union{Tuple{AbstractAlgebra.Generic.MPolyRing{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" id="Singular.AsEquivalentSingularPolynomialRing-Union{Tuple{AbstractAlgebra.Generic.MPolyRing{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.AsEquivalentSingularPolynomialRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AsEquivalentSingularPolynomialRing(R::AbstractAlgebra.Generic.MPolyRing{T}; cached::Bool = true,
  ordering::Symbol = :degrevlex, ordering2::Symbol = :comp1min,
  degree_bound::Int = 0)  where {T &lt;: RingElem}</code></pre><p>Return a Singular (multivariate) polynomial ring over the base ring of <span>$R$</span> in variables having the same names as those of R.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L787" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Singular.AsEquivalentAbstractAlgebraPolynomialRing-Union{Tuple{PolyRing{Singular.n_unknown{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" id="Singular.AsEquivalentAbstractAlgebraPolynomialRing-Union{Tuple{PolyRing{Singular.n_unknown{T}}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.AsEquivalentAbstractAlgebraPolynomialRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AsEquivalentAbstractAlgebraPolynomialRing(R::Singular.PolyRing{Singular.n_unknown{T}}; ordering::Symbol = :degrevlex)  where {T &lt;: RingElem}</code></pre><p>Return an AbstractAlgebra (multivariate) polynomial ring over the base ring of <span>$R$</span> in variables having the same names as those of R.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Singular.jl/blob/64a61409a52b9d6aa79bc0b2d48a8012999478d0/src/poly/poly.jl#L799" target="_blank">source</a></section></article><p><strong>Examples</strong></p><p>Conversion of generic AbstractAlgebra polynomials to Singular.jl polynomials:</p><pre><code class="language-julia">K = Nemo.ZZ
R, (x, y) = AbstractAlgebra.Generic.PolynomialRing(K, ["x", "y"]);
Rsing, vars_Rsing = Singular.AsEquivalentSingularPolynomialRing(R);
Rsing(x + y) == Rsing(x) + Rsing(y)</code></pre><p>Conversion of Singular.jl polynomials to generic AbstractAlgebra polynomials:</p><pre><code class="language-julia">K = Nemo.ZZ
S, (u, v) = Singular.PolynomialRing(K, ["u", "v"])
Saa, (uu, vv) = Singular.AsEquivalentAbstractAlgebraPolynomialRing(S)
Saa(u) + Saa(v) == Saa(u) + Saa(v)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nemo/">« Nemo rings and fields</a><a class="docs-footer-nextpage" href="../ideal/">Ideals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 15 March 2021 15:39">Monday 15 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>